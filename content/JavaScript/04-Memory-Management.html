<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>内存管理与垃圾回收</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="../../global.css"> <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" /> <style>
        /* Minimal inline styles - Primarily rely on global.css and Tailwind */

        /* --- Base & Layout Adjustments --- */
        html {
            scroll-padding-top: 2rem; /* Adjust if header is sticky */
        }

        body {
            /* Base font, bg, color assumed from global.css */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- Typography (Assuming base H1-H6, p, strong, a, pre, code from global.css) --- */
        h1, h2, h3, h4, h5, h6 {
            scroll-margin-top: 2rem; /* Offset for sticky nav */
        }

        h2 {
            border-bottom: 1px solid var(--border-color-light);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem; /* Consistent spacing */
        }

        h3 {
            margin-top: 0; /* Reset top margin as card handles spacing */
            margin-bottom: 1rem;
            color: var(--primary-color-dark); /* Use a distinct color for card titles */
            font-size: 1.25rem; /* Ensure size consistency */
        }
        /* Sub-heading for visualizations */
        h4.viz-title {
             font-size: 1.1rem; /* Slightly smaller than h3 */
             font-weight: 600;
             margin-top: 1.5rem;
             margin-bottom: 0.75rem;
             color: var(--text-color-dark);
        }


        /* Specific list styling within article (using global.css .prose/.content-main styles) */
        article ul { list-style: disc; padding-left: 1.5em; margin-bottom: 1em; }
        article ol { list-style: decimal; padding-left: 1.5em; margin-bottom: 1em; }
        article li { margin-bottom: 0.5em; }
        article ul ul, article ol ol, article ul ol, article ol ul { margin-top: 0.5em; margin-bottom: 0.5em; }

        /* Ensure pre uses the mono font and has appropriate styling */
        article pre {
            font-family: var(--font-family-mono);
            border-radius: 0.375rem; /* Ensure rounding */
            margin: 1rem 0; /* Ensure margin */
            padding: 1em; /* Ensure padding */
            overflow: auto;
            /* Background/border from global.css or Prism theme */
        }

        /* Reset inline code styles within pre for Prism */
        article pre code[class*="language-"] {
            background: none; /* Remove potential background */
            color: inherit; /* Inherit from pre or Prism theme */
            padding: 0;
            border-radius: 0;
            font-size: inherit; /* Inherit size from pre */
            font-family: inherit; /* Inherit font from pre */
            line-height: inherit; /* Inherit line height */
            text-shadow: none; /* Remove potential text shadow from theme */
            white-space: pre; /* Ensure whitespace is preserved */
            display: block; /* Ensure code takes full width for highlighting */
        }

        /* Add margin between nested cards */
        .content-section > .content-card + .content-card {
            margin-top: 1.5rem;
        }

        /* Remove bottom margin from last element inside a card */
        .content-card > *:last-child {
            margin-bottom: 0 !important; /* Use !important if needed */
        }

        /* --- Card Hover Effect --- */
        .content-card {
            transition: box-shadow 0.2s ease-in-out; /* Add transition for smooth effect */
        }
        .content-card:hover {
             box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* Tailwind shadow-lg */
        }

        /* --- Tooltips (Adapted from 01-Language-Basics.html) --- */
        .tooltip-term {
            border-bottom: 1px dotted var(--primary-color);
            cursor: help;
            position: relative;
            color: var(--primary-color);
            font-weight: 500;
        }
        .tooltip-term::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }
        .tooltip-term::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(0px);
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.85) transparent transparent transparent;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }
        .tooltip-term:hover::before,
        .tooltip-term:hover::after {
            opacity: 1;
            visibility: visible;
        }

       

        /* --- Visualization Canvas and Controls Styling --- */
        .visualization-container {
            border: 1px solid var(--border-color-default);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1.5rem;
            background-color: var(--bg-color-light);
        }
        .visualization-canvas {
            display: block;
            width: 100%;
            height: 250px; /* Adjust height as needed */
            background-color: white;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color-light);
            margin-bottom: 1rem;
        }
        .visualization-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem; /* Spacing between buttons */
            justify-content: center;
        }
        .visualization-controls button {
             /* Use existing button styles */
             padding: 0.5rem 1rem; /* Slightly smaller padding */
             font-size: 0.8rem; /* Smaller font size */
        }
        .visualization-status {
            font-size: 0.85rem;
            color: var(--text-color-light);
            text-align: center;
            margin-top: 0.5rem;
            min-height: 1.2em; /* Reserve space for status text */
        }


        /* --- Fade-in Animation (Keep if not in global.css) --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in-section {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* --- Quiz Card Styling (Ensure styles from global.css are sufficient) --- */
        /* Add ripple effect if desired and implemented in JS */
        .quiz-toggle {
            position: relative;
            overflow: hidden;
        }
        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(var(--primary-color-rgb, 59, 130, 246), 0.4); /* Use RGB for opacity */
            transform: scale(0);
            animation: ripple-animation 0.6s linear;
            pointer-events: none;
        }
        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        .quiz-toggle .material-icons {
            font-size: 1.1rem;
            transition: transform 0.3s ease-in-out;
        }
        .quiz-toggle .icon-arrow.rotated {
            transform: rotate(180deg);
        }
        .quiz-answer {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out, padding-bottom 0.5s ease-in-out, margin-top 0.5s ease-in-out;
            overflow: hidden;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            border: 1px solid var(--border-color-default);
            background-color: var(--bg-color-lighter);
            border-radius: 0.375rem;
            color: var(--text-color-default);
        }
        .quiz-answer.visible {
            max-height: 1000px; /* Adjust if needed for very long answers */
            opacity: 1;
            padding-top: 1rem;
            padding-bottom: 1rem;
            margin-top: 1rem;
            overflow: auto;
        }


    </style>

</head>

<body class="bg-gray-100"> <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">内存管理</h4> <ul id="local-toc">
                <li><a href="#lifecycle" class="active"><span class="material-icons nav-icon">recycling</span>内存生命周期</a></li>
                <li><a href="#gc-basics"><span class="material-icons nav-icon">cleaning_services</span>GC 基本原理</a></li>
                <li><a href="#gc-algorithms"><span class="material-icons nav-icon">memory</span>常见 GC 算法</a></li>
                 <li><a href="#gc-viz-mark-sweep" class="ml-4 text-sm"><span class="material-icons nav-icon text-base">movie</span>标记-清除可视化</a></li>
                 <li><a href="#gc-viz-ref-count" class="ml-4 text-sm"><span class="material-icons nav-icon text-base">movie</span>引用计数可视化</a></li>
                <li><a href="#memory-leaks"><span class="material-icons nav-icon">warning</span>常见内存泄漏</a></li>
            </ul>
            <a href="../../index.html" class="back-link">
                &larr; 返回大纲目录
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="intro" class="content-section fade-in-section" style="animation-delay: 0s;">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-icons text-3xl text-blue-600">memory</span>内存管理与垃圾回收
                    </h1>
                    <p class="mb-4">理解内存管理是编写高效、稳定应用程序的关键，尤其是在 JavaScript 这种自动管理内存的语言中。本节将探讨内存的生命周期、垃圾回收的基本原理、常见的回收算法以及需要警惕的内存泄漏场景。</p>
                    <p class="mt-4 bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md text-sm">💡
                        <strong>提示:</strong> 点击左侧导航可以快速跳转到相应主题。将鼠标悬停在 <span class="tooltip-term" data-tooltip="例如这个解释！">带下划线的术语</span> 上可查看解释。尝试下方的交互式可视化来理解 GC 算法！
                    </p>
                </section>

                <section id="lifecycle" class="content-section fade-in-section" style="animation-delay: 0.05s;">
                    <h2 class="flex items-center head2"><span class="material-icons">recycling</span>内存生命周期</h2>
                    <p class="mb-6">在编程中，内存的生命周期通常遵循三个主要阶段：分配、使用和释放。</p>

                    <div class="mermaid">
                    flowchart TD
                        A[1. 分配 Allocation] --> B(2. 使用 Usage);
                        B --> C{内存仍需?};
                        C -- Yes --> B;
                        C -- No --> D[3. 释放 Release];
                        D --> E((结束));
                    </div>

                    <div class="content-card mb-6">
                        <h3 class="head3">1. 分配 (Allocation)</h3>
                        <p class="mb-4">当程序需要存储数据（如变量、对象、函数）时，它会向操作系统申请内存空间。在 JavaScript 中，这个过程是隐式发生的。</p>
                        <pre><code class="language-javascript">// Memory Allocation Examples
let message = "Hello"; // Allocate memory for the string
let user = { id: 1, name: "Gemini" }; // Allocate memory for the object
let numbers = [1, 2, 3]; // Allocate memory for the array
function calculate() { /* ... */ } // Allocate memory for the function definition</code></pre>
                        <p class="mt-4 mb-2">内存通常在两个地方分配：</p>
                        <ul>
                            <li><strong><span class="tooltip-term" data-tooltip="存储原始类型值和函数调用信息，后进先出 (LIFO)，大小固定，访问快">栈 (Stack)</span>:</strong> 用于存储原始类型值（如 Number, String, Boolean）和函数调用的引用/指针。分配速度快，大小固定。</li>
                            <li><strong><span class="tooltip-term" data-tooltip="存储对象、数组等复杂类型，大小不固定，访问相对较慢">堆 (Heap)</span>:</strong> 用于存储复杂的数据结构，如对象和数组。分配速度相对较慢，大小不固定。JavaScript 的对象主要存储在堆上。</li>
                        </ul>
                        <div class="mermaid">
                            graph TD
                            subgraph 内存区域
                                A["栈 Stack<br>(原始类型, 引用地址)"]
                                B["堆 Heap<br>(对象, 数组, 函数体)"]
                            end
                            C(代码执行) --> A;
                            C --> B;
                            A -- 引用 --> B;
                         </div>
                    </div>
                    <div class="content-card mb-6">
                        <h3 class="head3">2. 使用 (Usage)</h3>
                        <p class="mb-4">这是程序实际读写已分配内存的阶段，包括读取变量值、修改对象属性、调用函数等。</p>
                        <pre><code class="language-javascript">// Memory Usage Examples
console.log(message); // Read the value of 'message'
user.id = 2; // Modify a property of the 'user' object
numbers.push(4); // Modify the 'numbers' array
calculate(); // Execute the function code</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">3. 释放 (Release)</h3>
                        <p class="mb-4">当内存不再被程序需要时（例如，变量离开作用域，对象不再被引用），其占用的空间应该被释放，以便操作系统可以重用。在 C/C++ 等语言中，这需要手动完成。但在 JavaScript 中，这个过程由<strong class="text-red-600"><span class="tooltip-term" data-tooltip="自动管理内存的程序，负责识别和回收不再使用的内存">垃圾回收器 (Garbage Collector, GC)</span></strong> 自动完成。</p>
                        <p>开发者不需要（也不能）显式释放内存。GC 会自动识别不再使用的内存并进行回收。</p>
                    </div>

                    <div class="quiz-card mt-6" id="quiz-lifecycle"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>生命周期测验： 在 JavaScript 中，开发者通常需要手动执行哪个内存生命周期阶段？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="a">
                                <span>分配 (Allocation)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="b">
                                <span>使用 (Usage)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="c">
                                <span>释放 (Release)</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="d">
                                <span>以上都不是</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_lifecycle"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_lifecycle', 'd')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                        <div class="quiz-answer" style="display: none;"> <p><strong>答案:</strong> D. 以上都不是</p>
                           <p><strong>解析:</strong> JavaScript 具有自动垃圾回收机制。内存的分配（声明变量/对象时）和使用（读写变量时）是开发者代码驱动的，但内存的释放是由垃圾回收器自动完成的，开发者通常不需要（也不能）手动释放内存。</p>
                       </div>
                    </div>
                </section>

                <section id="gc-basics" class="content-section fade-in-section" style="animation-delay: 0.1s;">
                    <h2 class="flex items-center head2"><span class="material-icons">cleaning_services</span>垃圾回收机制基本原理 (可达性)</h2>
                    <div class="content-card">
                        <h3 class="head3">可达性 (Reachability)</h3>
                        <p class="mb-4">现代 JavaScript 引擎主要采用基于<strong class="text-red-600"><span class="tooltip-term" data-tooltip="判断一个值是否能从根（如全局变量、当前函数变量）通过引用链访问到">可达性</span></strong>的垃圾回收策略。</p>
                        <p class="mb-4">核心思想：一个值被认为是“可达的”，如果它可以从一个已知的“根” (root) 通过引用链访问到。如果一个值无法从任何根访问到，它就被认为是“不可达的”或“垃圾”，可以被安全回收。</p>
                        <p class="mb-2"><strong>根 (Roots)</strong> 通常包括：</p>
                        <ul class="mb-4">
                            <li>全局对象（如浏览器的 <code>window</code>）及其所有属性。</li>
                            <li>当前正在执行的函数的局部变量和参数。</li>
                            <li>嵌套函数调用链上的所有变量和参数。</li>
                            <li>引擎内部持续引用的对象。</li>
                        </ul>
                        <p class="mb-4">GC 会定期从根开始遍历所有可达的对象。所有在遍历过程中无法访问到的对象，最终会被回收。</p>
                         <pre><code class="language-javascript">// Reachability Example
let globalUser = { name: "Global" }; // 可达，因为是全局变量 (Root)

function manageUsers() {
  let localUser = { name: "Local" }; // 可达，因为是当前函数局部变量 (Root during execution)
  let tempUser = { name: "Temporary" }; // 可达

  console.log(globalUser.name); // 访问可达对象
  console.log(localUser.name);  // 访问可达对象

  // 假设 tempUser 在某些操作后不再需要
  tempUser = null; // 解除引用，原 { name: "Temporary" } 对象可能变为不可达

} // 当 manageUsers 函数执行完毕，localUser 变量的作用域结束

manageUsers();
// manageUsers() 执行结束后，如果没有其他地方（如闭包）持有 localUser 的引用，
// { name: "Local" } 对象就变为不可达。
// { name: "Temporary" } 对象（如果 tempUser=null 执行了）也变为不可达。
// 这些不可达对象可以被 GC 回收。
// globalUser 仍然可达。</code></pre>
                    </div>
                     <div class="quiz-card mt-6" id="quiz-gc-basics"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>GC 原理测验： 在基于可达性的垃圾回收中，什么决定了一个对象是否应该被回收？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="a">
                                <span>对象的大小</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="b">
                                <span>对象创建的时间</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="c">
                                <span>对象是否能从根通过引用链访问到</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="d">
                                <span>对象的类型 (原始类型 vs 引用类型)</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_gc_basics"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_gc_basics', 'c')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                         <div class="quiz-answer" style="display: none;">
                            <p><strong>答案:</strong> C. 对象是否能从根通过引用链访问到</p>
                            <p><strong>解析:</strong> 可达性是现代垃圾回收的核心概念。只有当一个对象无法从任何根（全局变量、当前作用域变量等）通过直接或间接的引用访问到时，它才被认为是“垃圾”，可以被回收。对象的大小、创建时间或类型本身不直接决定其是否被回收。</p>
                        </div>
                    </div>
                </section>

                <section id="gc-algorithms" class="content-section fade-in-section" style="animation-delay: 0.15s;">
                    <h2 class="flex items-center head2"><span class="material-icons">memory</span>常见 GC 算法简介</h2>
                    <div class="content-card mb-6">
                        <h3 class="head3">1. 标记-清除 (Mark-and-Sweep)</h3>
                        <p class="mb-4">这是最常见的基于可达性的 GC 算法，也是 V8 等现代引擎的基础。</p>
                        <div class="mermaid">
                        flowchart TD
                            subgraph GC 过程
                                direction LR
                                A(Start GC) --> B{标记阶段};
                                B -- 从 Roots 开始 --> C(遍历可达对象);
                                C -- 标记对象 --> C;
                                C -- 完成遍历 --> D{清除阶段};
                                D -- 遍历 Heap --> E{对象已标记?};
                                E -- Yes --> F(保留对象, 取消标记);
                                E -- No --> G(回收对象内存);
                                F --> H(End GC);
                                G --> H;
                            end
                        </div>
                        <ul class="mb-4">
                            <li><strong>标记阶段 (Marking):</strong> 从根开始，递归访问所有可达对象，并打上标记。</li>
                            <li><strong>清除阶段 (Sweeping):</strong> 遍历整个堆内存，回收所有<strong class="text-red-600">未被标记</strong>的对象。</li>
                        </ul>
                        <p class="mb-2"><strong>优点：</strong>可以有效处理<span class="tooltip-term" data-tooltip="两个或多个对象相互引用，导致它们即使不再被外部访问也无法被简单引用计数回收">循环引用</span>。</p>
                        <p><strong>缺点：</strong>可能导致<span class="tooltip-term" data-tooltip="回收后内存中出现许多不连续的小块空闲空间">内存碎片化</span>；GC 运行时可能暂停应用（现代引擎有优化策略如增量 GC、并发 GC、<span class="tooltip-term" data-tooltip="将堆内存分为新生代和老生代分别处理，提高效率">分代 GC</span> 等来缓解）。</p>

                        <div id="gc-viz-mark-sweep" class="visualization-container">
                            <h4 class="viz-title flex items-center gap-2"><span class="material-icons text-lg">movie</span>标记-清除 可视化</h4>
                            <canvas id="markSweepCanvas" class="visualization-canvas"></canvas>
                            <div class="visualization-controls">
                                <button id="msResetBtn" class="button button-secondary">重置场景</button>
                                <button id="msCreateCycleBtn" class="button button-secondary">创建循环引用</button>
                                <button id="msMarkBtn" class="button button-primary">执行标记阶段</button>
                                <button id="msSweepBtn" class="button button-danger">执行清除阶段</button>
                            </div>
                             <div id="msStatus" class="visualization-status">点击按钮开始。</div>
                        </div>
                    </div>

                    <div class="content-card">
                        <h3 class="head3">2. 引用计数 (Reference Counting)</h3>
                        <p class="mb-4">一种较简单的算法，现在较少作为主要的 GC 策略。</p>
                        <div class="mermaid">
                         graph TD
                             subgraph 正常情况
                                 R1(Root 1) --> O1(Object A<br/>Count: 1);
                                 R2(Root 2) --> O1;
                                 %% O1 Count becomes 2
                             end
                             subgraph 循环引用问题
                                 O2(Object X<br/>Count: 1);
                                 O3(Object Y<br/>Count: 1);
                                 O2 -- linkToY --> O3;
                                 O3 -- linkToX --> O2;
                                 %% Root -> O2 (假设断开)
                                 %% Root -> O3 (假设断开)
                                 %% 即使 O2, O3 不可达, 它们的 Count 仍为 1
                             end
                             style O2 fill:#f9f,stroke:#333,stroke-width:2px;
                             style O3 fill:#f9f,stroke:#333,stroke-width:2px;
                         </div>
                        <ul class="mb-4">
                            <li><strong>原理：</strong>每个对象维护一个计数器，记录有多少引用指向它。</li>
                            <li>当引用增加时，计数器 +1；引用移除时，计数器 -1。</li>
                            <li>当计数器为 0 时，对象被回收。</li>
                        </ul>
                        <p class="mb-2"><strong>优点：</strong>垃圾可以被即时回收。</p>
                        <p class="mb-4"><strong>缺点：</strong><strong class="text-red-600">无法处理循环引用</strong>。如果两个对象相互引用，即使它们整体不可达，引用计数也永远不为 0，导致内存泄漏。</p>
                        <pre><code class="language-javascript">// Circular Reference Example (Problem for naive Reference Counting)
function createCycle() {
    let objA = {}; // objA count: 0
    let objB = {}; // objB count: 0

    // objA 和 objB 初始可达 (来自 createCycle 作用域)

    objA.linkToB = objB; // objB 被 objA 引用, objB count: 1
    objB.linkToA = objA; // objA 被 objB 引用, objA count: 1

    // 当 createCycle 执行完毕，来自作用域的引用消失
    // 但 objA 和 objB 互相引用，它们的 count 仍然是 1
    // 简单的引用计数无法回收它们
}

createCycle();</code></pre>
                        <p>由于循环引用的问题，现代主流 JS 引擎不单独使用引用计数作为主要 GC 策略，但标记-清除可以很好地处理这种情况。</p>

                         <div id="gc-viz-ref-count" class="visualization-container">
                            <h4 class="viz-title flex items-center gap-2"><span class="material-icons text-lg">movie</span>引用计数 可视化</h4>
                            <canvas id="refCountCanvas" class="visualization-canvas"></canvas>
                            <div class="visualization-controls">
                                <button id="rcResetBtn" class="button button-secondary">重置场景</button>
                                <button id="rcCreateObjBtn" class="button button-secondary">创建对象</button>
                                <button id="rcAddRefBtn" class="button button-secondary">添加引用</button>
                                <button id="rcRemoveRefBtn" class="button button-secondary">移除引用</button>
                                <button id="rcCreateCycleBtn" class="button button-secondary">创建循环引用</button>
                                <button id="rcCollectBtn" class="button button-danger">尝试回收 (Count=0)</button>
                            </div>
                            <div id="rcStatus" class="visualization-status">点击按钮开始。</div>
                        </div>
                    </div>
                     <div class="quiz-card mt-6" id="quiz-gc-algo"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>GC 算法测验： 哪个常见的垃圾回收算法的主要缺点是无法处理循环引用？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="a">
                                <span>标记-清除 (Mark-and-Sweep)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="b">
                                <span>引用计数 (Reference Counting)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="c">
                                <span>分代回收 (Generational Collection)</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="d">
                                <span>增量回收 (Incremental Collection)</span>
                            </label>
                        </div>
                         <div class="quiz-feedback mt-4" id="feedback-q_gc_algo"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_gc_algo', 'b')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                         <div class="quiz-answer" style="display: none;">
                            <p><strong>答案:</strong> B. 引用计数 (Reference Counting)</p>
                            <p><strong>解析:</strong> 引用计数算法通过跟踪指向每个对象的引用数量来工作。当计数归零时，对象被回收。然而，如果两个或多个对象相互引用（形成循环），即使它们不再被程序的其他部分访问（即从根不可达），它们的引用计数也永远不会变为零，导致它们无法被回收，这就是引用计数的主要局限性。标记-清除算法则可以正确处理循环引用。</p>
                        </div>
                    </div>
                </section>

                <section id="memory-leaks" class="content-section fade-in-section" style="animation-delay: 0.2s;">
                    <h2 class="flex items-center head2"><span class="material-icons">warning</span>常见的内存泄漏场景</h2>
                    <p class="mb-6"><span class="tooltip-term" data-tooltip="程序中不再需要的内存由于持续被引用而无法被GC回收的现象">内存泄漏</span>是指程序中不再需要的内存，由于某种原因（通常是意外的引用）未能被 GC 释放，导致可用内存逐渐减少。</p>
                    <div class="content-card mb-6">
                        <h3 class="head3">1. 意外的全局变量</h3>
                        <p class="mb-4">在非严格模式下，给未声明的变量赋值会创建全局变量，除非手动清除，否则不会被回收。</p>
                        <pre><code class="language-javascript">// Accidental Global Variable Leak
function createLeak() {
    // 忘记使用 'let', 'const', 或 'var'
    leakyData = new Array(1000).fill("leak"); // 在非严格模式下会创建 window.leakyData
}
// createLeak(); // 如果调用, leakyData 会一直存在于全局作用域
// 解决方法: 始终使用 'use strict'; 或确保用 let/const/var 声明变量</code></pre>
                    </div>
                    <div class="content-card mb-6">
                        <h3 class="head3">2. 被遗忘的定时器 (Timers)</h3>
                        <p class="mb-4"><code>setInterval</code> 或 <code>setTimeout</code> 的回调函数如果持有外部变量的引用（闭包），并且定时器未被清除 (<code>clearInterval</code>, <code>clearTimeout</code>)，会导致这些外部变量无法被回收。</p>
                        <pre><code class="language-javascript">// Forgotten Timer Leak
function startTimerLeak() {
    let largeObject = { data: new Array(10000).join('x') };
    // 定时器回调函数是一个闭包，它捕获了 largeObject
    let intervalId = setInterval(() => {
        // 只要定时器在运行，largeObject 就不会被回收，即使外部不再需要它
        console.log("Timer tick referencing data length:", largeObject.data.length);
    }, 5000);

    // 解决方法: 在不再需要定时器时，必须调用 clearInterval(intervalId)
    // 例如: setTimeout(() => clearInterval(intervalId), 20000); // 20秒后停止
}
// startTimerLeak();</code></pre>
                    </div>
                     <div class="content-card mb-6">
                        <h3 class="head3">3. 闭包 (Closures)</h3>
                        <p class="mb-4">闭包本身不是泄漏，但不当使用时可能导致。如果一个<strong class="text-red-600">长期存在</strong>的闭包（如事件监听器、全局函数）引用了不再需要的外部大对象，就会阻止该对象被回收。</p>
                         <pre><code class="language-javascript">// Closure Leak Example
function setupListener() {
    let potentiallyLargeData = { details: "Very large data..." };
    let button = document.getElementById('myButton'); // 假设按钮存在

    if (button) {
        // 事件监听器的回调函数是一个闭包，它捕获了 potentiallyLargeData
        button.addEventListener('click', function handleClick() {
            // 即使 handleClick 函数体内部没有直接使用 potentiallyLargeData,
            // 由于闭包机制，potentiallyLargeData 仍然被保持在内存中。
            alert('Button clicked!');
        });
        // 如果按钮和监听器一直存在，potentiallyLargeData 就不会被回收。
    }
    // 解决方法:
    // 1. 在按钮移除或不再需要监听时，明确移除监听器:
    //    button.removeEventListener('click', handleClick);
    // 2. 如果 handleClick 确实不需要 potentiallyLargeData，
    //    在监听器设置后将其设置为 null: potentiallyLargeData = null;
}
// setupListener();</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">4. DOM 引用 (Detached DOM Nodes)</h3>
                        <p class="mb-4">如果在 JavaScript 中保留了对 DOM 元素的引用，但该元素随后从 DOM 树中移除，只要 JS 引用存在，该 DOM 元素及其关联内存（包括子元素、事件监听器）就无法被回收。</p>
                        <pre><code class="language-javascript">// Detached DOM Leak Example
let detachedElements = []; // 用一个数组持有对 DOM 元素的引用

function removeAndLeak() {
    let parent = document.getElementById('container'); // 假设容器存在
    let elementToRemove = document.getElementById('leakyElement'); // 假设要移除的元素存在

    if (parent && elementToRemove) {
         // 在 JavaScript 中保留对该元素的引用
        detachedElements.push(elementToRemove);

        // 从真实的 DOM 树中移除该元素
        parent.removeChild(elementToRemove);

        // 此时，elementToRemove 已经不在页面上了，
        // 但是 detachedElements 数组仍然持有对它的引用。
        // 这会阻止该 DOM 节点及其相关资源（如事件监听器）被垃圾回收。
        console.log("Element removed, but reference kept. Potential leak.");
    }
}
// removeAndLeak();
// 解决方法: 当确定不再需要这些分离的 DOM 节点时，
// 需要清空 detachedElements 数组或移除其中的特定引用。
// 例如: detachedElements = [];</code></pre>
                         <p class="mt-4"><strong>关键：</strong>要特别注意那些<strong class="text-red-600">生命周期较长</strong>的对象（全局变量、事件监听器、缓存、定时器）所持有的引用，确保在不再需要时及时<strong class="text-red-600">断开这些引用</strong>（例如，设置为 <code>null</code>，移除监听器）。</p>
                    </div>
                     <div class="quiz-card mt-6" id="quiz-leaks"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>内存泄漏测验： 以下哪个操作最**不可能**直接导致内存泄漏？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="a">
                                <span>在函数内使用 <code>setInterval</code> 但忘记调用 <code>clearInterval</code>。</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="b">
                                <span>将 DOM 元素从页面移除，但 JS 中仍有变量引用它。</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="c">
                                <span>在函数内部声明一个局部变量，函数执行完毕后该变量不再被访问。</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="d">
                                <span>在非严格模式下，给一个未声明的变量赋值。</span>
                            </label>
                        </div>
                         <div class="quiz-feedback mt-4" id="feedback-q_leaks"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_leaks', 'c')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                         <div class="quiz-answer" style="display: none;">
                            <p><strong>答案:</strong> C. 在函数内部声明一个局部变量，函数执行完毕后该变量不再被访问。</p>
                            <p><strong>解析:</strong></p>
                            <ul>
                                <li>A: 被遗忘的定时器是常见的泄漏源，回调闭包可能持有外部引用。</li>
                                <li>B: 分离的 DOM 节点如果仍被 JS 引用，则无法被回收。</li>
                                <li>C: 函数执行完毕后，其局部变量通常会随着函数执行上下文的出栈而变得不可达（除非被闭包捕获），这是正常的内存管理，不是泄漏。</li>
                                <li>D: 意外的全局变量会一直存在，除非手动清除，是典型的泄漏场景。</li>
                            </ul>
                        </div>
                    </div>
                </section>

            </article>
        </main>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' }); // Using neutral theme

        // --- Color Constants for Visualizations ---
        const NODE_COLOR = '#60a5fa'; // blue-400
        const ROOT_COLOR = '#f87171'; // red-400
        const MARKED_COLOR = '#34d399'; // emerald-400
        const UNREACHABLE_COLOR = '#9ca3af'; // gray-400
        const CYCLIC_COLOR = '#facc15'; // yellow-400
        const LINE_COLOR = '#6b7280'; // gray-500
        const TEXT_COLOR = '#1f2937'; // gray-800
        const COUNT_COLOR = '#dc2626'; // red-600

        // --- Base Node Class for Visualizations ---
        class VizNode {
            constructor(id, x, y, radius = 20) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = NODE_COLOR;
                this.references = []; // Nodes this node points to
                this.isRoot = false;
                this.isMarked = false;
                this.isCyclic = false; // Specific flag for cycles
                this.refCount = 0; // For Reference Counting
                this.isCollected = false; // Flag for collected state
            }

            draw(ctx) {
                if (this.isCollected) return; // Don't draw collected nodes

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                // Determine fill color based on state
                let fillColor = this.color;
                if (this.isRoot) fillColor = ROOT_COLOR;
                else if (this.isMarked) fillColor = MARKED_COLOR;
                else if (this.isCyclic) fillColor = CYCLIC_COLOR; // Highlight cyclic nodes

                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = LINE_COLOR;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.closePath();

                // Draw Node ID
                ctx.fillStyle = TEXT_COLOR;
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);

                // Draw Reference Count (for RC viz)
                 if (this.refCount !== undefined && typeof this.refCount === 'number') {
                     ctx.fillStyle = COUNT_COLOR;
                     ctx.font = 'bold 10px Inter';
                     ctx.fillText(this.refCount, this.x + this.radius * 0.7, this.y - this.radius * 0.7);
                 }
            }

             drawReferences(ctx, nodes) {
                if (this.isCollected) return;
                ctx.strokeStyle = LINE_COLOR;
                ctx.lineWidth = 1.5;

                this.references.forEach(targetId => {
                    const targetNode = nodes.find(n => n.id === targetId);
                    if (targetNode && !targetNode.isCollected) {
                        ctx.beginPath();
                        // Calculate arrow position slightly outside the circles
                        const angle = Math.atan2(targetNode.y - this.y, targetNode.x - this.x);
                        const startX = this.x + this.radius * Math.cos(angle);
                        const startY = this.y + this.radius * Math.sin(angle);
                        const endX = targetNode.x - targetNode.radius * Math.cos(angle);
                        const endY = targetNode.y - targetNode.radius * Math.sin(angle);

                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw arrowhead
                        const arrowSize = 6;
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fillStyle = LINE_COLOR;
                        ctx.fill();
                    }
                });
            }
        }

        // --- Mark-and-Sweep Visualization Logic ---
        class MarkSweepVisualizer {
            constructor(canvasId, statusId) {
                this.canvas = document.getElementById(canvasId);
                this.statusElement = document.getElementById(statusId);
                if (!this.canvas) {
                    console.error(`Canvas element with ID ${canvasId} not found.`);
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.roots = [];
                this.animationFrameId = null;
                this.initialize();
            }

            initialize() {
                this.nodes = [];
                this.roots = [];
                // Create initial scene
                const root1 = new VizNode('R1', 50, this.canvas.height / 2);
                root1.isRoot = true;
                const nodeA = new VizNode('A', 150, this.canvas.height / 2 - 50);
                const nodeB = new VizNode('B', 150, this.canvas.height / 2 + 50);
                const nodeC = new VizNode('C', 250, this.canvas.height / 2); // Initially unreachable

                root1.references.push('A');
                root1.references.push('B');
                nodeA.references.push('C'); // A -> C

                this.nodes.push(root1, nodeA, nodeB, nodeC);
                this.roots.push(root1);

                this.draw();
                this.updateStatus("场景已重置。");
            }

            reset() {
                cancelAnimationFrame(this.animationFrameId);
                this.initialize();
            }

            createCycle() {
                 // Reset marks before creating cycle for clarity
                this.nodes.forEach(node => { node.isMarked = false; node.color = NODE_COLOR; node.isCyclic = false; node.isCollected = false; });

                const nodeD = new VizNode('D', 350, this.canvas.height / 2 - 50);
                const nodeE = new VizNode('E', 350, this.canvas.height / 2 + 50);
                nodeD.references.push('E');
                nodeE.references.push('D');
                nodeD.isCyclic = true; // Mark for visual distinction
                nodeE.isCyclic = true;
                this.nodes.push(nodeD, nodeE);
                this.draw();
                 this.updateStatus("创建了循环引用 D <-> E (目前不可达)。");
            }

             markPhase() {
                this.updateStatus("执行标记阶段...");
                // Reset previous marks but keep roots and cycles visually distinct if needed
                this.nodes.forEach(node => {
                    node.isMarked = false;
                    node.isCollected = false; // Ensure nodes are drawable
                    if (!node.isRoot && !node.isCyclic) node.color = NODE_COLOR;
                    else if (node.isCyclic) node.color = CYCLIC_COLOR;
                });
                this.draw(); // Redraw with reset marks

                const queue = [...this.roots];
                const markedSet = new Set(this.roots.map(r => r.id));
                this.roots.forEach(r => r.isMarked = true);

                let delay = 0;
                const markDelay = 500; // ms delay between marking steps

                const processQueue = () => {
                    if (queue.length === 0) {
                         this.updateStatus("标记阶段完成。");
                         this.draw(); // Final draw after marking
                        return;
                    }

                    const currentNode = queue.shift();
                    currentNode.isMarked = true; // Ensure marked
                    currentNode.color = MARKED_COLOR; // Visually mark

                    // Schedule redraw after a delay
                    setTimeout(() => {
                         this.draw(); // Draw current state
                         // Add reachable, unmarked neighbors to queue
                        currentNode.references.forEach(targetId => {
                            if (!markedSet.has(targetId)) {
                                const targetNode = this.nodes.find(n => n.id === targetId);
                                if (targetNode) {
                                    markedSet.add(targetId);
                                    queue.push(targetNode);
                                }
                            }
                        });
                         processQueue(); // Process next item in queue
                    }, delay);
                    delay += markDelay; // Increment delay for next step
                };

                processQueue(); // Start the marking process
            }


            sweepPhase() {
                this.updateStatus("执行清除阶段...");
                let delay = 0;
                const sweepDelay = 300;

                this.nodes.forEach((node, index) => {
                    if (!node.isMarked && !node.isRoot) { // Don't sweep roots
                        setTimeout(() => {
                            node.isCollected = true; // Mark as collected
                            this.draw(); // Redraw to show node removed
                            if (index === this.nodes.length - 1) {
                                this.updateStatus("清除阶段完成。不可达对象已被回收。");
                            }
                        }, delay);
                        delay += sweepDelay;
                    }
                });
                 // If no nodes to sweep, update status immediately
                if (delay === 0) {
                    this.updateStatus("清除阶段完成。没有需要回收的对象。");
                }
            }


            draw() {
                 // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw all references first (lines behind nodes)
                this.nodes.forEach(node => node.drawReferences(this.ctx, this.nodes));

                // Draw all nodes
                this.nodes.forEach(node => node.draw(this.ctx));
            }

             updateStatus(message) {
                if (this.statusElement) {
                    this.statusElement.textContent = message;
                }
            }
        }


        // --- Reference Counting Visualization Logic ---
        class RefCountVisualizer {
            constructor(canvasId, statusId) {
                this.canvas = document.getElementById(canvasId);
                 this.statusElement = document.getElementById(statusId);
                if (!this.canvas) {
                    console.error(`Canvas element with ID ${canvasId} not found.`);
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.references = []; // Store refs as { sourceId, targetId }
                this.objCounter = 0;
                this.initialize();
            }

            initialize() {
                this.nodes = [];
                this.references = [];
                this.objCounter = 0;
                // Create a root node representation (doesn't have count itself)
                const root = new VizNode('Root', 50, this.canvas.height / 2);
                root.isRoot = true;
                root.refCount = undefined; // Roots don't have counts in this model
                this.nodes.push(root);
                this.draw();
                this.updateStatus("场景已重置。");
            }

            reset() {
                this.initialize();
            }

            createObject() {
                this.objCounter++;
                const newNodeId = `Obj${this.objCounter}`;
                // Try to place new nodes without overlapping too much
                const x = 150 + (this.nodes.length -1) % 4 * 100;
                const y = 100 + Math.floor((this.nodes.length -1) / 4) * 100;
                const newNode = new VizNode(newNodeId, x, y);
                newNode.refCount = 0; // Initial count is 0
                this.nodes.push(newNode);
                this.draw();
                this.updateStatus(`创建了对象 ${newNodeId} (Count: 0)。`);
            }

            addReference() {
                // Simple logic: Add ref from Root to the last created object if possible
                const root = this.nodes.find(n => n.isRoot);
                const targetNode = this.nodes[this.nodes.length - 1]; // Last added node

                if (root && targetNode && targetNode !== root) {
                     // Check if reference already exists to avoid duplicates visually
                    const exists = this.references.some(ref => ref.sourceId === root.id && ref.targetId === targetNode.id);
                    if (!exists) {
                        this.references.push({ sourceId: root.id, targetId: targetNode.id });
                        targetNode.refCount++;
                        this.draw();
                        this.updateStatus(`添加引用 Root -> ${targetNode.id} (Count: ${targetNode.refCount})。`);
                    } else {
                         this.updateStatus(`引用 Root -> ${targetNode.id} 已存在。`);
                    }
                } else {
                    this.updateStatus("无法添加引用（需要先创建对象）。");
                }
            }

            removeReference() {
                 // Simple logic: Remove the last added reference from Root if possible
                const root = this.nodes.find(n => n.isRoot);
                if (this.references.length > 0) {
                    const lastRefIndex = this.references.findIndex(ref => ref.sourceId === root.id); // Find last ref FROM ROOT
                    if (lastRefIndex !== -1) {
                        const removedRef = this.references.splice(lastRefIndex, 1)[0];
                        const targetNode = this.nodes.find(n => n.id === removedRef.targetId);
                        if (targetNode) {
                            targetNode.refCount--;
                            this.draw();
                            this.updateStatus(`移除引用 Root -> ${targetNode.id} (Count: ${targetNode.refCount})。`);
                        }
                    } else {
                         this.updateStatus("没有从 Root 发出的引用可移除。");
                    }

                } else {
                    this.updateStatus("没有引用可移除。");
                }
            }

             createCycle() {
                // Create two new objects and make them reference each other
                if (this.nodes.filter(n => !n.isRoot).length >= 2) {
                     this.updateStatus("场景中已有对象，请重置后再创建循环。");
                     return;
                }
                 this.createObject(); // Obj1
                 const node1 = this.nodes[this.nodes.length - 1];
                 this.createObject(); // Obj2
                 const node2 = this.nodes[this.nodes.length - 1];

                 if (node1 && node2) {
                     // Add references Obj1 -> Obj2 and Obj2 -> Obj1
                     this.references.push({ sourceId: node1.id, targetId: node2.id });
                     node2.refCount++;
                     this.references.push({ sourceId: node2.id, targetId: node1.id });
                     node1.refCount++;
                     node1.isCyclic = true; // Mark for visual distinction
                     node2.isCyclic = true;
                     node1.color = CYCLIC_COLOR;
                     node2.color = CYCLIC_COLOR;

                     this.draw();
                     this.updateStatus(`创建了循环引用 ${node1.id} (Count: ${node1.refCount}) <-> ${node2.id} (Count: ${node2.refCount})。尝试移除 Root 的引用（如果存在）并回收。`);
                 }
            }

            collectGarbage() {
                this.updateStatus("尝试回收 Count 为 0 的对象...");
                let collected = false;
                const nodesToRemove = [];

                this.nodes.forEach(node => {
                    if (!node.isRoot && node.refCount === 0) {
                        nodesToRemove.push(node.id);
                        collected = true;
                         // Also remove references *originating* from the collected node
                        this.references = this.references.filter(ref => {
                            if (ref.sourceId === node.id) {
                                const target = this.nodes.find(n => n.id === ref.targetId);
                                if (target) target.refCount--; // Decrement target count
                                return false; // Remove this reference
                            }
                            return true;
                        });
                    }
                });

                 // Remove collected nodes from the main list
                 this.nodes = this.nodes.filter(node => !nodesToRemove.includes(node.id));
                 // Remove references *pointing to* collected nodes
                 this.references = this.references.filter(ref => !nodesToRemove.includes(ref.targetId));


                if (collected) {
                     this.updateStatus(`回收了 Count 为 0 的对象。${nodesToRemove.length > 1 ? '它们' : '它'}以及指向它们的引用已被移除。`);
                     // Recursively collect if removing references caused other counts to drop to 0
                     // Simple immediate check:
                     if (this.nodes.some(n => !n.isRoot && n.refCount === 0)) {
                         this.collectGarbage(); // Trigger another collection cycle if needed
                     } else {
                          this.draw(); // Redraw after collection
                     }
                } else {
                    this.updateStatus("没有 Count 为 0 的对象可回收。注意循环引用！");
                    this.draw();
                }
            }

             draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw references
                this.ctx.strokeStyle = LINE_COLOR;
                this.ctx.lineWidth = 1.5;
                this.references.forEach(ref => {
                    const sourceNode = this.nodes.find(n => n.id === ref.sourceId);
                    const targetNode = this.nodes.find(n => n.id === ref.targetId);
                    if (sourceNode && targetNode) {
                         // Draw line with arrow
                        const angle = Math.atan2(targetNode.y - sourceNode.y, targetNode.x - sourceNode.x);
                        const startRadius = sourceNode.isRoot ? sourceNode.radius * 0.6 : sourceNode.radius; // Smaller start for root
                        const startX = sourceNode.x + startRadius * Math.cos(angle);
                        const startY = sourceNode.y + startRadius * Math.sin(angle);
                        const endX = targetNode.x - targetNode.radius * Math.cos(angle);
                        const endY = targetNode.y - targetNode.radius * Math.sin(angle);

                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw arrowhead
                        const arrowSize = 6;
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fillStyle = LINE_COLOR;
                        ctx.fill();
                    }
                });

                // Draw nodes
                this.nodes.forEach(node => node.draw(this.ctx));
            }

             updateStatus(message) {
                if (this.statusElement) {
                    this.statusElement.textContent = message;
                }
            }
        }


        // --- Ripple Effect Logic ---
        function createRipple(event) {
            const button = event.currentTarget;
            if (!button || typeof button.getBoundingClientRect !== 'function') return;
            const circle = document.createElement("span");
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;
            const primaryColorRgb = getComputedStyle(document.documentElement).getPropertyValue('--primary-color-rgb') || '59, 130, 246';
            circle.style.width = circle.style.height = `${diameter}px`;
            const rect = button.getBoundingClientRect();
            circle.style.left = `${event.clientX - rect.left - radius}px`;
            circle.style.top = `${event.clientY - rect.top - radius}px`;
            circle.style.backgroundColor = `rgba(${primaryColorRgb}, 0.4)`;
            circle.classList.add("ripple");
            const existingRipple = button.querySelector(".ripple");
            if (existingRipple) existingRipple.remove();
            button.appendChild(circle);
            setTimeout(() => circle.remove(), 600);
        }

        // --- Quiz Toggle Logic ---
        function toggleAnswer(quizId, buttonElement) {
            const quizCard = document.getElementById(quizId);
            if (!quizCard) return;
            const answer = quizCard.querySelector('.quiz-answer');
            const icon = buttonElement.querySelector('.icon-arrow');
            const buttonTextSpan = buttonElement.querySelector('.button-text');
            if (!answer || !icon || !buttonTextSpan) return;
            const isVisible = answer.classList.contains('visible');
            if (isVisible) {
                answer.style.maxHeight = '0';
                answer.style.opacity = '0';
                answer.style.marginTop = '0';
                answer.style.paddingTop = '0';
                answer.style.paddingBottom = '0';
                answer.classList.remove('visible');
                icon.classList.remove('rotated');
                buttonTextSpan.textContent = ' 查看答案';
                setTimeout(() => {
                    if (!answer.classList.contains('visible')) {
                         answer.style.removeProperty('max-height');
                         answer.style.removeProperty('opacity');
                         answer.style.removeProperty('margin-top');
                         answer.style.removeProperty('padding-top');
                         answer.style.removeProperty('padding-bottom');
                         answer.style.display = 'none'; // Explicitly hide after transition
                    }
                }, 500);
            } else {
                answer.style.display = 'block'; // Make it visible to measure
                answer.style.paddingTop = '1rem';
                answer.style.paddingBottom = '1rem';
                answer.style.marginTop = '1rem';
                requestAnimationFrame(() => {
                    answer.style.maxHeight = answer.scrollHeight + 'px';
                    answer.style.opacity = '1';
                    answer.classList.add('visible');
                    icon.classList.add('rotated');
                    buttonTextSpan.textContent = ' 隐藏答案';
                });
            }
        }

        // --- Quiz Check Answer Logic ---
        function checkAnswer(questionName, correctAnswerValue) {
            const options = document.querySelectorAll(`input[name="${questionName}"]`);
            const feedbackElement = document.getElementById(`feedback-${questionName}`);
            const quizCard = feedbackElement ? feedbackElement.closest('.quiz-card') : null;
            let selectedValue = null;
            let selectedLabel = null;
            if (!feedbackElement || !quizCard) return;

            quizCard.querySelectorAll('.quiz-option').forEach(opt => opt.classList.remove('selected', 'correct', 'incorrect'));
            options.forEach(option => {
                if (option.checked) {
                    selectedValue = option.value;
                    selectedLabel = option.closest('.quiz-option');
                    if (selectedLabel) selectedLabel.classList.add('selected');
                }
            });

            if (!selectedValue) {
                feedbackElement.textContent = "请选择一个选项！";
                feedbackElement.className = 'quiz-feedback warning';
                feedbackElement.style.display = 'block';
                return;
            }

            let correctAnswerLabel = null;
            options.forEach(opt => { if (opt.value === correctAnswerValue) correctAnswerLabel = opt.closest('.quiz-option'); });

            if (selectedValue === correctAnswerValue) {
                feedbackElement.textContent = "回答正确！";
                feedbackElement.className = 'quiz-feedback correct';
                if(selectedLabel) selectedLabel.classList.add('correct');
            } else {
                let correctAnswerText = '';
                if (correctAnswerLabel) {
                    correctAnswerText = correctAnswerLabel.querySelector('span')?.textContent || `选项 ${correctAnswerValue}`;
                    correctAnswerLabel.classList.add('correct');
                }
                feedbackElement.textContent = `回答错误。正确答案是: "${correctAnswerText}"`;
                feedbackElement.className = 'quiz-feedback incorrect';
                if(selectedLabel) selectedLabel.classList.add('incorrect');
            }
            feedbackElement.style.display = 'block';

            // Show answer section when checking
            const answerSection = quizCard.querySelector('.quiz-answer');
            const toggleButton = quizCard.querySelector('.quiz-toggle'); // Find the toggle button for this quiz
             if (answerSection && !answerSection.classList.contains('visible') && toggleButton) {
                 // Find the associated toggle button and click it programmatically OR call toggleAnswer directly
                 // Calling toggleAnswer is safer if the button itself handles checking
                 // toggleAnswer(quizCard.id, toggleButton); // Uncomment if toggle button should reveal answer
            } else if (answerSection && answerSection.classList.contains('visible') && toggleButton) {
                 // If answer is already visible, maybe just ensure feedback is scrolled into view
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            // --- TOC Highlighting Logic ---
            const sections = document.querySelectorAll('main section[id]');
            const tocLinks = document.querySelectorAll('#local-toc a');
            let lastActiveTocLink = null;
            const tocObserverOptions = { root: null, rootMargin: '-20% 0px -60% 0px', threshold: 0 };
            const tocObserverCallback = (entries) => {
                let bestVisibleEntry = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (!bestVisibleEntry || entry.boundingClientRect.top < bestVisibleEntry.boundingClientRect.top) bestVisibleEntry = entry;
                    }
                });
                if (bestVisibleEntry) {
                    const id = bestVisibleEntry.target.getAttribute('id');
                    const activeLink = document.querySelector(`#local-toc a[href="#${id}"], #local-toc a[href="#gc-viz-${id.split('-').pop()}"]`); // Match section or viz ID
                    if (activeLink && activeLink !== lastActiveTocLink) {
                        if (lastActiveTocLink) lastActiveTocLink.classList.remove('active');
                        activeLink.classList.add('active');
                        lastActiveTocLink = activeLink;
                    }
                }
            };
            const tocObserver = new IntersectionObserver(tocObserverCallback, tocObserverOptions);
            sections.forEach(section => tocObserver.observe(section));
            // Also observe visualization containers for TOC highlighting
            document.querySelectorAll('.visualization-container[id]').forEach(viz => tocObserver.observe(viz));


            // Initial active link check
            const currentHash = window.location.hash;
            if (currentHash) {
                const initialActiveLink = document.querySelector(`#local-toc a[href="${currentHash}"]`);
                if (initialActiveLink) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    initialActiveLink.classList.add('active');
                    lastActiveTocLink = initialActiveLink;
                }
            } else if (tocLinks.length > 0 && !lastActiveTocLink) {
                 tocLinks.forEach(link => link.classList.remove('active'));
                 tocLinks[0].classList.add('active');
                 lastActiveTocLink = tocLinks[0];
            }

            // --- Fade-in Animation Logic ---
            const mainContentSections = document.querySelectorAll('main > article > section.content-section');
            const fadeObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
            const fadeObserverCallback = (entries, observer) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const delayIndex = Array.from(mainContentSections).indexOf(entry.target);
                        entry.target.style.animationDelay = `${delayIndex * 0.05}s`;
                        entry.target.classList.add('fade-in-section');
                        observer.unobserve(entry.target);
                    }
                });
            };
            const fadeObserver = new IntersectionObserver(fadeObserverCallback, fadeObserverOptions);
            mainContentSections.forEach(section => fadeObserver.observe(section));

            // --- Initialize Visualizations ---
            let msViz = null;
            let rcViz = null;
            try {
                 msViz = new MarkSweepVisualizer('markSweepCanvas', 'msStatus');
                 rcViz = new RefCountVisualizer('refCountCanvas', 'rcStatus');
            } catch (e) {
                console.error("Error initializing visualizations:", e);
            }


            // --- Attach Event Listeners ---
            // Mark-Sweep Controls
            document.getElementById('msResetBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.reset(); });
            document.getElementById('msCreateCycleBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.createCycle(); });
            document.getElementById('msMarkBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.markPhase(); });
            document.getElementById('msSweepBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.sweepPhase(); });

            // Reference Counting Controls
            document.getElementById('rcResetBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.reset(); });
            document.getElementById('rcCreateObjBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.createObject(); });
            document.getElementById('rcAddRefBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.addReference(); });
            document.getElementById('rcRemoveRefBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.removeReference(); });
            document.getElementById('rcCreateCycleBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.createCycle(); });
            document.getElementById('rcCollectBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.collectGarbage(); });


            // Quiz Toggle Buttons (using onclick in HTML for checkAnswer, need separate toggle logic)
             document.querySelectorAll('.quiz-card .quiz-toggle').forEach(button => {
                 // Find the quiz card ID to associate toggle with answer section
                 const quizCard = button.closest('.quiz-card');
                 const quizId = quizCard?.id;
                 const answerSection = quizCard?.querySelector('.quiz-answer');
                 const checkButton = quizCard?.querySelector('button[onclick^="checkAnswer"]'); // Find the check button

                 if (quizId && answerSection) {
                     // If the toggle button itself IS NOT the check button
                     if (button !== checkButton) {
                         button.addEventListener('click', (event) => {
                             createRipple(event);
                             toggleAnswer(quizId, button);
                         });
                     } else {
                        // If the toggle button IS the check button, add ripple but let onclick handle check/toggle
                         button.addEventListener('click', createRipple);
                         // Modify checkAnswer to call toggleAnswer if needed
                         // OR adjust HTML to have separate check and toggle buttons
                     }
                 }
             });

             // Adjust checkAnswer to toggle visibility
             const originalCheckAnswer = window.checkAnswer;
             window.checkAnswer = function(questionName, correctAnswerValue) {
                 originalCheckAnswer(questionName, correctAnswerValue); // Call original logic
                 const feedbackElement = document.getElementById(`feedback-${questionName}`);
                 const quizCard = feedbackElement?.closest('.quiz-card');
                 const toggleButton = quizCard?.querySelector('.quiz-toggle'); // Assuming one toggle button per card
                 const answerSection = quizCard?.querySelector('.quiz-answer');

                 // If feedback is shown, ensure the answer section is visible
                 if (quizCard && toggleButton && answerSection && !answerSection.classList.contains('visible')) {
                    toggleAnswer(quizCard.id, toggleButton);
                 }
             }

        });
    </script>

</body>

</html>
