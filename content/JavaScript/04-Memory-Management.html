<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å†…å­˜ç®¡ç†ä¸åƒåœ¾å›æ”¶</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="../../global.css"> <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" /> <style>
        /* Minimal inline styles - Primarily rely on global.css and Tailwind */

        /* --- Base & Layout Adjustments --- */
        html {
            scroll-padding-top: 2rem; /* Adjust if header is sticky */
        }

        body {
            /* Base font, bg, color assumed from global.css */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- Typography (Assuming base H1-H6, p, strong, a, pre, code from global.css) --- */
        h1, h2, h3, h4, h5, h6 {
            scroll-margin-top: 2rem; /* Offset for sticky nav */
        }

        h2 {
            border-bottom: 1px solid var(--border-color-light);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem; /* Consistent spacing */
        }

        h3 {
            margin-top: 0; /* Reset top margin as card handles spacing */
            margin-bottom: 1rem;
            color: var(--primary-color-dark); /* Use a distinct color for card titles */
            font-size: 1.25rem; /* Ensure size consistency */
        }
        /* Sub-heading for visualizations */
        h4.viz-title {
             font-size: 1.1rem; /* Slightly smaller than h3 */
             font-weight: 600;
             margin-top: 1.5rem;
             margin-bottom: 0.75rem;
             color: var(--text-color-dark);
        }


        /* Specific list styling within article (using global.css .prose/.content-main styles) */
        article ul { list-style: disc; padding-left: 1.5em; margin-bottom: 1em; }
        article ol { list-style: decimal; padding-left: 1.5em; margin-bottom: 1em; }
        article li { margin-bottom: 0.5em; }
        article ul ul, article ol ol, article ul ol, article ol ul { margin-top: 0.5em; margin-bottom: 0.5em; }

        /* Ensure pre uses the mono font and has appropriate styling */
        article pre {
            font-family: var(--font-family-mono);
            border-radius: 0.375rem; /* Ensure rounding */
            margin: 1rem 0; /* Ensure margin */
            padding: 1em; /* Ensure padding */
            overflow: auto;
            /* Background/border from global.css or Prism theme */
        }

        /* Reset inline code styles within pre for Prism */
        article pre code[class*="language-"] {
            background: none; /* Remove potential background */
            color: inherit; /* Inherit from pre or Prism theme */
            padding: 0;
            border-radius: 0;
            font-size: inherit; /* Inherit size from pre */
            font-family: inherit; /* Inherit font from pre */
            line-height: inherit; /* Inherit line height */
            text-shadow: none; /* Remove potential text shadow from theme */
            white-space: pre; /* Ensure whitespace is preserved */
            display: block; /* Ensure code takes full width for highlighting */
        }

        /* Add margin between nested cards */
        .content-section > .content-card + .content-card {
            margin-top: 1.5rem;
        }

        /* Remove bottom margin from last element inside a card */
        .content-card > *:last-child {
            margin-bottom: 0 !important; /* Use !important if needed */
        }

        /* --- Card Hover Effect --- */
        .content-card {
            transition: box-shadow 0.2s ease-in-out; /* Add transition for smooth effect */
        }
        .content-card:hover {
             box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* Tailwind shadow-lg */
        }

        /* --- Tooltips (Adapted from 01-Language-Basics.html) --- */
        .tooltip-term {
            border-bottom: 1px dotted var(--primary-color);
            cursor: help;
            position: relative;
            color: var(--primary-color);
            font-weight: 500;
        }
        .tooltip-term::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }
        .tooltip-term::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(0px);
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.85) transparent transparent transparent;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }
        .tooltip-term:hover::before,
        .tooltip-term:hover::after {
            opacity: 1;
            visibility: visible;
        }

       

        /* --- Visualization Canvas and Controls Styling --- */
        .visualization-container {
            border: 1px solid var(--border-color-default);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1.5rem;
            background-color: var(--bg-color-light);
        }
        .visualization-canvas {
            display: block;
            width: 100%;
            height: 250px; /* Adjust height as needed */
            background-color: white;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color-light);
            margin-bottom: 1rem;
        }
        .visualization-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem; /* Spacing between buttons */
            justify-content: center;
        }
        .visualization-controls button {
             /* Use existing button styles */
             padding: 0.5rem 1rem; /* Slightly smaller padding */
             font-size: 0.8rem; /* Smaller font size */
        }
        .visualization-status {
            font-size: 0.85rem;
            color: var(--text-color-light);
            text-align: center;
            margin-top: 0.5rem;
            min-height: 1.2em; /* Reserve space for status text */
        }


        /* --- Fade-in Animation (Keep if not in global.css) --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in-section {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* --- Quiz Card Styling (Ensure styles from global.css are sufficient) --- */
        /* Add ripple effect if desired and implemented in JS */
        .quiz-toggle {
            position: relative;
            overflow: hidden;
        }
        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(var(--primary-color-rgb, 59, 130, 246), 0.4); /* Use RGB for opacity */
            transform: scale(0);
            animation: ripple-animation 0.6s linear;
            pointer-events: none;
        }
        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }
        .quiz-toggle .material-icons {
            font-size: 1.1rem;
            transition: transform 0.3s ease-in-out;
        }
        .quiz-toggle .icon-arrow.rotated {
            transform: rotate(180deg);
        }
        .quiz-answer {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out, padding-bottom 0.5s ease-in-out, margin-top 0.5s ease-in-out;
            overflow: hidden;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            border: 1px solid var(--border-color-default);
            background-color: var(--bg-color-lighter);
            border-radius: 0.375rem;
            color: var(--text-color-default);
        }
        .quiz-answer.visible {
            max-height: 1000px; /* Adjust if needed for very long answers */
            opacity: 1;
            padding-top: 1rem;
            padding-bottom: 1rem;
            margin-top: 1rem;
            overflow: auto;
        }


    </style>

</head>

<body class="bg-gray-100"> <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">å†…å­˜ç®¡ç†</h4> <ul id="local-toc">
                <li><a href="#lifecycle" class="active"><span class="material-icons nav-icon">recycling</span>å†…å­˜ç”Ÿå‘½å‘¨æœŸ</a></li>
                <li><a href="#gc-basics"><span class="material-icons nav-icon">cleaning_services</span>GC åŸºæœ¬åŸç†</a></li>
                <li><a href="#gc-algorithms"><span class="material-icons nav-icon">memory</span>å¸¸è§ GC ç®—æ³•</a></li>
                 <li><a href="#gc-viz-mark-sweep" class="ml-4 text-sm"><span class="material-icons nav-icon text-base">movie</span>æ ‡è®°-æ¸…é™¤å¯è§†åŒ–</a></li>
                 <li><a href="#gc-viz-ref-count" class="ml-4 text-sm"><span class="material-icons nav-icon text-base">movie</span>å¼•ç”¨è®¡æ•°å¯è§†åŒ–</a></li>
                <li><a href="#memory-leaks"><span class="material-icons nav-icon">warning</span>å¸¸è§å†…å­˜æ³„æ¼</a></li>
            </ul>
            <a href="../../index.html" class="back-link">
                &larr; è¿”å›å¤§çº²ç›®å½•
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="intro" class="content-section fade-in-section" style="animation-delay: 0s;">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-icons text-3xl text-blue-600">memory</span>å†…å­˜ç®¡ç†ä¸åƒåœ¾å›æ”¶
                    </h1>
                    <p class="mb-4">ç†è§£å†…å­˜ç®¡ç†æ˜¯ç¼–å†™é«˜æ•ˆã€ç¨³å®šåº”ç”¨ç¨‹åºçš„å…³é”®ï¼Œå°¤å…¶æ˜¯åœ¨ JavaScript è¿™ç§è‡ªåŠ¨ç®¡ç†å†…å­˜çš„è¯­è¨€ä¸­ã€‚æœ¬èŠ‚å°†æ¢è®¨å†…å­˜çš„ç”Ÿå‘½å‘¨æœŸã€åƒåœ¾å›æ”¶çš„åŸºæœ¬åŸç†ã€å¸¸è§çš„å›æ”¶ç®—æ³•ä»¥åŠéœ€è¦è­¦æƒ•çš„å†…å­˜æ³„æ¼åœºæ™¯ã€‚</p>
                    <p class="mt-4 bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md text-sm">ğŸ’¡
                        <strong>æç¤º:</strong> ç‚¹å‡»å·¦ä¾§å¯¼èˆªå¯ä»¥å¿«é€Ÿè·³è½¬åˆ°ç›¸åº”ä¸»é¢˜ã€‚å°†é¼ æ ‡æ‚¬åœåœ¨ <span class="tooltip-term" data-tooltip="ä¾‹å¦‚è¿™ä¸ªè§£é‡Šï¼">å¸¦ä¸‹åˆ’çº¿çš„æœ¯è¯­</span> ä¸Šå¯æŸ¥çœ‹è§£é‡Šã€‚å°è¯•ä¸‹æ–¹çš„äº¤äº’å¼å¯è§†åŒ–æ¥ç†è§£ GC ç®—æ³•ï¼
                    </p>
                </section>

                <section id="lifecycle" class="content-section fade-in-section" style="animation-delay: 0.05s;">
                    <h2 class="flex items-center head2"><span class="material-icons">recycling</span>å†…å­˜ç”Ÿå‘½å‘¨æœŸ</h2>
                    <p class="mb-6">åœ¨ç¼–ç¨‹ä¸­ï¼Œå†…å­˜çš„ç”Ÿå‘½å‘¨æœŸé€šå¸¸éµå¾ªä¸‰ä¸ªä¸»è¦é˜¶æ®µï¼šåˆ†é…ã€ä½¿ç”¨å’Œé‡Šæ”¾ã€‚</p>

                    <div class="mermaid">
                    flowchart TD
                        A[1. åˆ†é… Allocation] --> B(2. ä½¿ç”¨ Usage);
                        B --> C{å†…å­˜ä»éœ€?};
                        C -- Yes --> B;
                        C -- No --> D[3. é‡Šæ”¾ Release];
                        D --> E((ç»“æŸ));
                    </div>

                    <div class="content-card mb-6">
                        <h3 class="head3">1. åˆ†é… (Allocation)</h3>
                        <p class="mb-4">å½“ç¨‹åºéœ€è¦å­˜å‚¨æ•°æ®ï¼ˆå¦‚å˜é‡ã€å¯¹è±¡ã€å‡½æ•°ï¼‰æ—¶ï¼Œå®ƒä¼šå‘æ“ä½œç³»ç»Ÿç”³è¯·å†…å­˜ç©ºé—´ã€‚åœ¨ JavaScript ä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯éšå¼å‘ç”Ÿçš„ã€‚</p>
                        <pre><code class="language-javascript">// Memory Allocation Examples
let message = "Hello"; // Allocate memory for the string
let user = { id: 1, name: "Gemini" }; // Allocate memory for the object
let numbers = [1, 2, 3]; // Allocate memory for the array
function calculate() { /* ... */ } // Allocate memory for the function definition</code></pre>
                        <p class="mt-4 mb-2">å†…å­˜é€šå¸¸åœ¨ä¸¤ä¸ªåœ°æ–¹åˆ†é…ï¼š</p>
                        <ul>
                            <li><strong><span class="tooltip-term" data-tooltip="å­˜å‚¨åŸå§‹ç±»å‹å€¼å’Œå‡½æ•°è°ƒç”¨ä¿¡æ¯ï¼Œåè¿›å…ˆå‡º (LIFO)ï¼Œå¤§å°å›ºå®šï¼Œè®¿é—®å¿«">æ ˆ (Stack)</span>:</strong> ç”¨äºå­˜å‚¨åŸå§‹ç±»å‹å€¼ï¼ˆå¦‚ Number, String, Booleanï¼‰å’Œå‡½æ•°è°ƒç”¨çš„å¼•ç”¨/æŒ‡é’ˆã€‚åˆ†é…é€Ÿåº¦å¿«ï¼Œå¤§å°å›ºå®šã€‚</li>
                            <li><strong><span class="tooltip-term" data-tooltip="å­˜å‚¨å¯¹è±¡ã€æ•°ç»„ç­‰å¤æ‚ç±»å‹ï¼Œå¤§å°ä¸å›ºå®šï¼Œè®¿é—®ç›¸å¯¹è¾ƒæ…¢">å † (Heap)</span>:</strong> ç”¨äºå­˜å‚¨å¤æ‚çš„æ•°æ®ç»“æ„ï¼Œå¦‚å¯¹è±¡å’Œæ•°ç»„ã€‚åˆ†é…é€Ÿåº¦ç›¸å¯¹è¾ƒæ…¢ï¼Œå¤§å°ä¸å›ºå®šã€‚JavaScript çš„å¯¹è±¡ä¸»è¦å­˜å‚¨åœ¨å †ä¸Šã€‚</li>
                        </ul>
                        <div class="mermaid">
                            graph TD
                            subgraph å†…å­˜åŒºåŸŸ
                                A["æ ˆ Stack<br>(åŸå§‹ç±»å‹, å¼•ç”¨åœ°å€)"]
                                B["å † Heap<br>(å¯¹è±¡, æ•°ç»„, å‡½æ•°ä½“)"]
                            end
                            C(ä»£ç æ‰§è¡Œ) --> A;
                            C --> B;
                            A -- å¼•ç”¨ --> B;
                         </div>
                    </div>
                    <div class="content-card mb-6">
                        <h3 class="head3">2. ä½¿ç”¨ (Usage)</h3>
                        <p class="mb-4">è¿™æ˜¯ç¨‹åºå®é™…è¯»å†™å·²åˆ†é…å†…å­˜çš„é˜¶æ®µï¼ŒåŒ…æ‹¬è¯»å–å˜é‡å€¼ã€ä¿®æ”¹å¯¹è±¡å±æ€§ã€è°ƒç”¨å‡½æ•°ç­‰ã€‚</p>
                        <pre><code class="language-javascript">// Memory Usage Examples
console.log(message); // Read the value of 'message'
user.id = 2; // Modify a property of the 'user' object
numbers.push(4); // Modify the 'numbers' array
calculate(); // Execute the function code</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">3. é‡Šæ”¾ (Release)</h3>
                        <p class="mb-4">å½“å†…å­˜ä¸å†è¢«ç¨‹åºéœ€è¦æ—¶ï¼ˆä¾‹å¦‚ï¼Œå˜é‡ç¦»å¼€ä½œç”¨åŸŸï¼Œå¯¹è±¡ä¸å†è¢«å¼•ç”¨ï¼‰ï¼Œå…¶å ç”¨çš„ç©ºé—´åº”è¯¥è¢«é‡Šæ”¾ï¼Œä»¥ä¾¿æ“ä½œç³»ç»Ÿå¯ä»¥é‡ç”¨ã€‚åœ¨ C/C++ ç­‰è¯­è¨€ä¸­ï¼Œè¿™éœ€è¦æ‰‹åŠ¨å®Œæˆã€‚ä½†åœ¨ JavaScript ä¸­ï¼Œè¿™ä¸ªè¿‡ç¨‹ç”±<strong class="text-red-600"><span class="tooltip-term" data-tooltip="è‡ªåŠ¨ç®¡ç†å†…å­˜çš„ç¨‹åºï¼Œè´Ÿè´£è¯†åˆ«å’Œå›æ”¶ä¸å†ä½¿ç”¨çš„å†…å­˜">åƒåœ¾å›æ”¶å™¨ (Garbage Collector, GC)</span></strong> è‡ªåŠ¨å®Œæˆã€‚</p>
                        <p>å¼€å‘è€…ä¸éœ€è¦ï¼ˆä¹Ÿä¸èƒ½ï¼‰æ˜¾å¼é‡Šæ”¾å†…å­˜ã€‚GC ä¼šè‡ªåŠ¨è¯†åˆ«ä¸å†ä½¿ç”¨çš„å†…å­˜å¹¶è¿›è¡Œå›æ”¶ã€‚</p>
                    </div>

                    <div class="quiz-card mt-6" id="quiz-lifecycle"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>ç”Ÿå‘½å‘¨æœŸæµ‹éªŒï¼š åœ¨ JavaScript ä¸­ï¼Œå¼€å‘è€…é€šå¸¸éœ€è¦æ‰‹åŠ¨æ‰§è¡Œå“ªä¸ªå†…å­˜ç”Ÿå‘½å‘¨æœŸé˜¶æ®µï¼Ÿ</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="a">
                                <span>åˆ†é… (Allocation)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="b">
                                <span>ä½¿ç”¨ (Usage)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="c">
                                <span>é‡Šæ”¾ (Release)</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_lifecycle" value="d">
                                <span>ä»¥ä¸Šéƒ½ä¸æ˜¯</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_lifecycle"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_lifecycle', 'd')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">æ£€æŸ¥ç­”æ¡ˆ</span>
                        </button>
                        <div class="quiz-answer" style="display: none;"> <p><strong>ç­”æ¡ˆ:</strong> D. ä»¥ä¸Šéƒ½ä¸æ˜¯</p>
                           <p><strong>è§£æ:</strong> JavaScript å…·æœ‰è‡ªåŠ¨åƒåœ¾å›æ”¶æœºåˆ¶ã€‚å†…å­˜çš„åˆ†é…ï¼ˆå£°æ˜å˜é‡/å¯¹è±¡æ—¶ï¼‰å’Œä½¿ç”¨ï¼ˆè¯»å†™å˜é‡æ—¶ï¼‰æ˜¯å¼€å‘è€…ä»£ç é©±åŠ¨çš„ï¼Œä½†å†…å­˜çš„é‡Šæ”¾æ˜¯ç”±åƒåœ¾å›æ”¶å™¨è‡ªåŠ¨å®Œæˆçš„ï¼Œå¼€å‘è€…é€šå¸¸ä¸éœ€è¦ï¼ˆä¹Ÿä¸èƒ½ï¼‰æ‰‹åŠ¨é‡Šæ”¾å†…å­˜ã€‚</p>
                       </div>
                    </div>
                </section>

                <section id="gc-basics" class="content-section fade-in-section" style="animation-delay: 0.1s;">
                    <h2 class="flex items-center head2"><span class="material-icons">cleaning_services</span>åƒåœ¾å›æ”¶æœºåˆ¶åŸºæœ¬åŸç† (å¯è¾¾æ€§)</h2>
                    <div class="content-card">
                        <h3 class="head3">å¯è¾¾æ€§ (Reachability)</h3>
                        <p class="mb-4">ç°ä»£ JavaScript å¼•æ“ä¸»è¦é‡‡ç”¨åŸºäº<strong class="text-red-600"><span class="tooltip-term" data-tooltip="åˆ¤æ–­ä¸€ä¸ªå€¼æ˜¯å¦èƒ½ä»æ ¹ï¼ˆå¦‚å…¨å±€å˜é‡ã€å½“å‰å‡½æ•°å˜é‡ï¼‰é€šè¿‡å¼•ç”¨é“¾è®¿é—®åˆ°">å¯è¾¾æ€§</span></strong>çš„åƒåœ¾å›æ”¶ç­–ç•¥ã€‚</p>
                        <p class="mb-4">æ ¸å¿ƒæ€æƒ³ï¼šä¸€ä¸ªå€¼è¢«è®¤ä¸ºæ˜¯â€œå¯è¾¾çš„â€ï¼Œå¦‚æœå®ƒå¯ä»¥ä»ä¸€ä¸ªå·²çŸ¥çš„â€œæ ¹â€ (root) é€šè¿‡å¼•ç”¨é“¾è®¿é—®åˆ°ã€‚å¦‚æœä¸€ä¸ªå€¼æ— æ³•ä»ä»»ä½•æ ¹è®¿é—®åˆ°ï¼Œå®ƒå°±è¢«è®¤ä¸ºæ˜¯â€œä¸å¯è¾¾çš„â€æˆ–â€œåƒåœ¾â€ï¼Œå¯ä»¥è¢«å®‰å…¨å›æ”¶ã€‚</p>
                        <p class="mb-2"><strong>æ ¹ (Roots)</strong> é€šå¸¸åŒ…æ‹¬ï¼š</p>
                        <ul class="mb-4">
                            <li>å…¨å±€å¯¹è±¡ï¼ˆå¦‚æµè§ˆå™¨çš„ <code>window</code>ï¼‰åŠå…¶æ‰€æœ‰å±æ€§ã€‚</li>
                            <li>å½“å‰æ­£åœ¨æ‰§è¡Œçš„å‡½æ•°çš„å±€éƒ¨å˜é‡å’Œå‚æ•°ã€‚</li>
                            <li>åµŒå¥—å‡½æ•°è°ƒç”¨é“¾ä¸Šçš„æ‰€æœ‰å˜é‡å’Œå‚æ•°ã€‚</li>
                            <li>å¼•æ“å†…éƒ¨æŒç»­å¼•ç”¨çš„å¯¹è±¡ã€‚</li>
                        </ul>
                        <p class="mb-4">GC ä¼šå®šæœŸä»æ ¹å¼€å§‹éå†æ‰€æœ‰å¯è¾¾çš„å¯¹è±¡ã€‚æ‰€æœ‰åœ¨éå†è¿‡ç¨‹ä¸­æ— æ³•è®¿é—®åˆ°çš„å¯¹è±¡ï¼Œæœ€ç»ˆä¼šè¢«å›æ”¶ã€‚</p>
                         <pre><code class="language-javascript">// Reachability Example
let globalUser = { name: "Global" }; // å¯è¾¾ï¼Œå› ä¸ºæ˜¯å…¨å±€å˜é‡ (Root)

function manageUsers() {
  let localUser = { name: "Local" }; // å¯è¾¾ï¼Œå› ä¸ºæ˜¯å½“å‰å‡½æ•°å±€éƒ¨å˜é‡ (Root during execution)
  let tempUser = { name: "Temporary" }; // å¯è¾¾

  console.log(globalUser.name); // è®¿é—®å¯è¾¾å¯¹è±¡
  console.log(localUser.name);  // è®¿é—®å¯è¾¾å¯¹è±¡

  // å‡è®¾ tempUser åœ¨æŸäº›æ“ä½œåä¸å†éœ€è¦
  tempUser = null; // è§£é™¤å¼•ç”¨ï¼ŒåŸ { name: "Temporary" } å¯¹è±¡å¯èƒ½å˜ä¸ºä¸å¯è¾¾

} // å½“ manageUsers å‡½æ•°æ‰§è¡Œå®Œæ¯•ï¼ŒlocalUser å˜é‡çš„ä½œç”¨åŸŸç»“æŸ

manageUsers();
// manageUsers() æ‰§è¡Œç»“æŸåï¼Œå¦‚æœæ²¡æœ‰å…¶ä»–åœ°æ–¹ï¼ˆå¦‚é—­åŒ…ï¼‰æŒæœ‰ localUser çš„å¼•ç”¨ï¼Œ
// { name: "Local" } å¯¹è±¡å°±å˜ä¸ºä¸å¯è¾¾ã€‚
// { name: "Temporary" } å¯¹è±¡ï¼ˆå¦‚æœ tempUser=null æ‰§è¡Œäº†ï¼‰ä¹Ÿå˜ä¸ºä¸å¯è¾¾ã€‚
// è¿™äº›ä¸å¯è¾¾å¯¹è±¡å¯ä»¥è¢« GC å›æ”¶ã€‚
// globalUser ä»ç„¶å¯è¾¾ã€‚</code></pre>
                    </div>
                     <div class="quiz-card mt-6" id="quiz-gc-basics"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>GC åŸç†æµ‹éªŒï¼š åœ¨åŸºäºå¯è¾¾æ€§çš„åƒåœ¾å›æ”¶ä¸­ï¼Œä»€ä¹ˆå†³å®šäº†ä¸€ä¸ªå¯¹è±¡æ˜¯å¦åº”è¯¥è¢«å›æ”¶ï¼Ÿ</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="a">
                                <span>å¯¹è±¡çš„å¤§å°</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="b">
                                <span>å¯¹è±¡åˆ›å»ºçš„æ—¶é—´</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="c">
                                <span>å¯¹è±¡æ˜¯å¦èƒ½ä»æ ¹é€šè¿‡å¼•ç”¨é“¾è®¿é—®åˆ°</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_gc_basics" value="d">
                                <span>å¯¹è±¡çš„ç±»å‹ (åŸå§‹ç±»å‹ vs å¼•ç”¨ç±»å‹)</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_gc_basics"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_gc_basics', 'c')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">æ£€æŸ¥ç­”æ¡ˆ</span>
                        </button>
                         <div class="quiz-answer" style="display: none;">
                            <p><strong>ç­”æ¡ˆ:</strong> C. å¯¹è±¡æ˜¯å¦èƒ½ä»æ ¹é€šè¿‡å¼•ç”¨é“¾è®¿é—®åˆ°</p>
                            <p><strong>è§£æ:</strong> å¯è¾¾æ€§æ˜¯ç°ä»£åƒåœ¾å›æ”¶çš„æ ¸å¿ƒæ¦‚å¿µã€‚åªæœ‰å½“ä¸€ä¸ªå¯¹è±¡æ— æ³•ä»ä»»ä½•æ ¹ï¼ˆå…¨å±€å˜é‡ã€å½“å‰ä½œç”¨åŸŸå˜é‡ç­‰ï¼‰é€šè¿‡ç›´æ¥æˆ–é—´æ¥çš„å¼•ç”¨è®¿é—®åˆ°æ—¶ï¼Œå®ƒæ‰è¢«è®¤ä¸ºæ˜¯â€œåƒåœ¾â€ï¼Œå¯ä»¥è¢«å›æ”¶ã€‚å¯¹è±¡çš„å¤§å°ã€åˆ›å»ºæ—¶é—´æˆ–ç±»å‹æœ¬èº«ä¸ç›´æ¥å†³å®šå…¶æ˜¯å¦è¢«å›æ”¶ã€‚</p>
                        </div>
                    </div>
                </section>

                <section id="gc-algorithms" class="content-section fade-in-section" style="animation-delay: 0.15s;">
                    <h2 class="flex items-center head2"><span class="material-icons">memory</span>å¸¸è§ GC ç®—æ³•ç®€ä»‹</h2>
                    <div class="content-card mb-6">
                        <h3 class="head3">1. æ ‡è®°-æ¸…é™¤ (Mark-and-Sweep)</h3>
                        <p class="mb-4">è¿™æ˜¯æœ€å¸¸è§çš„åŸºäºå¯è¾¾æ€§çš„ GC ç®—æ³•ï¼Œä¹Ÿæ˜¯ V8 ç­‰ç°ä»£å¼•æ“çš„åŸºç¡€ã€‚</p>
                        <div class="mermaid">
                        flowchart TD
                            subgraph GC è¿‡ç¨‹
                                direction LR
                                A(Start GC) --> B{æ ‡è®°é˜¶æ®µ};
                                B -- ä» Roots å¼€å§‹ --> C(éå†å¯è¾¾å¯¹è±¡);
                                C -- æ ‡è®°å¯¹è±¡ --> C;
                                C -- å®Œæˆéå† --> D{æ¸…é™¤é˜¶æ®µ};
                                D -- éå† Heap --> E{å¯¹è±¡å·²æ ‡è®°?};
                                E -- Yes --> F(ä¿ç•™å¯¹è±¡, å–æ¶ˆæ ‡è®°);
                                E -- No --> G(å›æ”¶å¯¹è±¡å†…å­˜);
                                F --> H(End GC);
                                G --> H;
                            end
                        </div>
                        <ul class="mb-4">
                            <li><strong>æ ‡è®°é˜¶æ®µ (Marking):</strong> ä»æ ¹å¼€å§‹ï¼Œé€’å½’è®¿é—®æ‰€æœ‰å¯è¾¾å¯¹è±¡ï¼Œå¹¶æ‰“ä¸Šæ ‡è®°ã€‚</li>
                            <li><strong>æ¸…é™¤é˜¶æ®µ (Sweeping):</strong> éå†æ•´ä¸ªå †å†…å­˜ï¼Œå›æ”¶æ‰€æœ‰<strong class="text-red-600">æœªè¢«æ ‡è®°</strong>çš„å¯¹è±¡ã€‚</li>
                        </ul>
                        <p class="mb-2"><strong>ä¼˜ç‚¹ï¼š</strong>å¯ä»¥æœ‰æ•ˆå¤„ç†<span class="tooltip-term" data-tooltip="ä¸¤ä¸ªæˆ–å¤šä¸ªå¯¹è±¡ç›¸äº’å¼•ç”¨ï¼Œå¯¼è‡´å®ƒä»¬å³ä½¿ä¸å†è¢«å¤–éƒ¨è®¿é—®ä¹Ÿæ— æ³•è¢«ç®€å•å¼•ç”¨è®¡æ•°å›æ”¶">å¾ªç¯å¼•ç”¨</span>ã€‚</p>
                        <p><strong>ç¼ºç‚¹ï¼š</strong>å¯èƒ½å¯¼è‡´<span class="tooltip-term" data-tooltip="å›æ”¶åå†…å­˜ä¸­å‡ºç°è®¸å¤šä¸è¿ç»­çš„å°å—ç©ºé—²ç©ºé—´">å†…å­˜ç¢ç‰‡åŒ–</span>ï¼›GC è¿è¡Œæ—¶å¯èƒ½æš‚åœåº”ç”¨ï¼ˆç°ä»£å¼•æ“æœ‰ä¼˜åŒ–ç­–ç•¥å¦‚å¢é‡ GCã€å¹¶å‘ GCã€<span class="tooltip-term" data-tooltip="å°†å †å†…å­˜åˆ†ä¸ºæ–°ç”Ÿä»£å’Œè€ç”Ÿä»£åˆ†åˆ«å¤„ç†ï¼Œæé«˜æ•ˆç‡">åˆ†ä»£ GC</span> ç­‰æ¥ç¼“è§£ï¼‰ã€‚</p>

                        <div id="gc-viz-mark-sweep" class="visualization-container">
                            <h4 class="viz-title flex items-center gap-2"><span class="material-icons text-lg">movie</span>æ ‡è®°-æ¸…é™¤ å¯è§†åŒ–</h4>
                            <canvas id="markSweepCanvas" class="visualization-canvas"></canvas>
                            <div class="visualization-controls">
                                <button id="msResetBtn" class="button button-secondary">é‡ç½®åœºæ™¯</button>
                                <button id="msCreateCycleBtn" class="button button-secondary">åˆ›å»ºå¾ªç¯å¼•ç”¨</button>
                                <button id="msMarkBtn" class="button button-primary">æ‰§è¡Œæ ‡è®°é˜¶æ®µ</button>
                                <button id="msSweepBtn" class="button button-danger">æ‰§è¡Œæ¸…é™¤é˜¶æ®µ</button>
                            </div>
                             <div id="msStatus" class="visualization-status">ç‚¹å‡»æŒ‰é’®å¼€å§‹ã€‚</div>
                        </div>
                    </div>

                    <div class="content-card">
                        <h3 class="head3">2. å¼•ç”¨è®¡æ•° (Reference Counting)</h3>
                        <p class="mb-4">ä¸€ç§è¾ƒç®€å•çš„ç®—æ³•ï¼Œç°åœ¨è¾ƒå°‘ä½œä¸ºä¸»è¦çš„ GC ç­–ç•¥ã€‚</p>
                        <div class="mermaid">
                         graph TD
                             subgraph æ­£å¸¸æƒ…å†µ
                                 R1(Root 1) --> O1(Object A<br/>Count: 1);
                                 R2(Root 2) --> O1;
                                 %% O1 Count becomes 2
                             end
                             subgraph å¾ªç¯å¼•ç”¨é—®é¢˜
                                 O2(Object X<br/>Count: 1);
                                 O3(Object Y<br/>Count: 1);
                                 O2 -- linkToY --> O3;
                                 O3 -- linkToX --> O2;
                                 %% Root -> O2 (å‡è®¾æ–­å¼€)
                                 %% Root -> O3 (å‡è®¾æ–­å¼€)
                                 %% å³ä½¿ O2, O3 ä¸å¯è¾¾, å®ƒä»¬çš„ Count ä»ä¸º 1
                             end
                             style O2 fill:#f9f,stroke:#333,stroke-width:2px;
                             style O3 fill:#f9f,stroke:#333,stroke-width:2px;
                         </div>
                        <ul class="mb-4">
                            <li><strong>åŸç†ï¼š</strong>æ¯ä¸ªå¯¹è±¡ç»´æŠ¤ä¸€ä¸ªè®¡æ•°å™¨ï¼Œè®°å½•æœ‰å¤šå°‘å¼•ç”¨æŒ‡å‘å®ƒã€‚</li>
                            <li>å½“å¼•ç”¨å¢åŠ æ—¶ï¼Œè®¡æ•°å™¨ +1ï¼›å¼•ç”¨ç§»é™¤æ—¶ï¼Œè®¡æ•°å™¨ -1ã€‚</li>
                            <li>å½“è®¡æ•°å™¨ä¸º 0 æ—¶ï¼Œå¯¹è±¡è¢«å›æ”¶ã€‚</li>
                        </ul>
                        <p class="mb-2"><strong>ä¼˜ç‚¹ï¼š</strong>åƒåœ¾å¯ä»¥è¢«å³æ—¶å›æ”¶ã€‚</p>
                        <p class="mb-4"><strong>ç¼ºç‚¹ï¼š</strong><strong class="text-red-600">æ— æ³•å¤„ç†å¾ªç¯å¼•ç”¨</strong>ã€‚å¦‚æœä¸¤ä¸ªå¯¹è±¡ç›¸äº’å¼•ç”¨ï¼Œå³ä½¿å®ƒä»¬æ•´ä½“ä¸å¯è¾¾ï¼Œå¼•ç”¨è®¡æ•°ä¹Ÿæ°¸è¿œä¸ä¸º 0ï¼Œå¯¼è‡´å†…å­˜æ³„æ¼ã€‚</p>
                        <pre><code class="language-javascript">// Circular Reference Example (Problem for naive Reference Counting)
function createCycle() {
    let objA = {}; // objA count: 0
    let objB = {}; // objB count: 0

    // objA å’Œ objB åˆå§‹å¯è¾¾ (æ¥è‡ª createCycle ä½œç”¨åŸŸ)

    objA.linkToB = objB; // objB è¢« objA å¼•ç”¨, objB count: 1
    objB.linkToA = objA; // objA è¢« objB å¼•ç”¨, objA count: 1

    // å½“ createCycle æ‰§è¡Œå®Œæ¯•ï¼Œæ¥è‡ªä½œç”¨åŸŸçš„å¼•ç”¨æ¶ˆå¤±
    // ä½† objA å’Œ objB äº’ç›¸å¼•ç”¨ï¼Œå®ƒä»¬çš„ count ä»ç„¶æ˜¯ 1
    // ç®€å•çš„å¼•ç”¨è®¡æ•°æ— æ³•å›æ”¶å®ƒä»¬
}

createCycle();</code></pre>
                        <p>ç”±äºå¾ªç¯å¼•ç”¨çš„é—®é¢˜ï¼Œç°ä»£ä¸»æµ JS å¼•æ“ä¸å•ç‹¬ä½¿ç”¨å¼•ç”¨è®¡æ•°ä½œä¸ºä¸»è¦ GC ç­–ç•¥ï¼Œä½†æ ‡è®°-æ¸…é™¤å¯ä»¥å¾ˆå¥½åœ°å¤„ç†è¿™ç§æƒ…å†µã€‚</p>

                         <div id="gc-viz-ref-count" class="visualization-container">
                            <h4 class="viz-title flex items-center gap-2"><span class="material-icons text-lg">movie</span>å¼•ç”¨è®¡æ•° å¯è§†åŒ–</h4>
                            <canvas id="refCountCanvas" class="visualization-canvas"></canvas>
                            <div class="visualization-controls">
                                <button id="rcResetBtn" class="button button-secondary">é‡ç½®åœºæ™¯</button>
                                <button id="rcCreateObjBtn" class="button button-secondary">åˆ›å»ºå¯¹è±¡</button>
                                <button id="rcAddRefBtn" class="button button-secondary">æ·»åŠ å¼•ç”¨</button>
                                <button id="rcRemoveRefBtn" class="button button-secondary">ç§»é™¤å¼•ç”¨</button>
                                <button id="rcCreateCycleBtn" class="button button-secondary">åˆ›å»ºå¾ªç¯å¼•ç”¨</button>
                                <button id="rcCollectBtn" class="button button-danger">å°è¯•å›æ”¶ (Count=0)</button>
                            </div>
                            <div id="rcStatus" class="visualization-status">ç‚¹å‡»æŒ‰é’®å¼€å§‹ã€‚</div>
                        </div>
                    </div>
                     <div class="quiz-card mt-6" id="quiz-gc-algo"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>GC ç®—æ³•æµ‹éªŒï¼š å“ªä¸ªå¸¸è§çš„åƒåœ¾å›æ”¶ç®—æ³•çš„ä¸»è¦ç¼ºç‚¹æ˜¯æ— æ³•å¤„ç†å¾ªç¯å¼•ç”¨ï¼Ÿ</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="a">
                                <span>æ ‡è®°-æ¸…é™¤ (Mark-and-Sweep)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="b">
                                <span>å¼•ç”¨è®¡æ•° (Reference Counting)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="c">
                                <span>åˆ†ä»£å›æ”¶ (Generational Collection)</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_gc_algo" value="d">
                                <span>å¢é‡å›æ”¶ (Incremental Collection)</span>
                            </label>
                        </div>
                         <div class="quiz-feedback mt-4" id="feedback-q_gc_algo"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_gc_algo', 'b')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">æ£€æŸ¥ç­”æ¡ˆ</span>
                        </button>
                         <div class="quiz-answer" style="display: none;">
                            <p><strong>ç­”æ¡ˆ:</strong> B. å¼•ç”¨è®¡æ•° (Reference Counting)</p>
                            <p><strong>è§£æ:</strong> å¼•ç”¨è®¡æ•°ç®—æ³•é€šè¿‡è·Ÿè¸ªæŒ‡å‘æ¯ä¸ªå¯¹è±¡çš„å¼•ç”¨æ•°é‡æ¥å·¥ä½œã€‚å½“è®¡æ•°å½’é›¶æ—¶ï¼Œå¯¹è±¡è¢«å›æ”¶ã€‚ç„¶è€Œï¼Œå¦‚æœä¸¤ä¸ªæˆ–å¤šä¸ªå¯¹è±¡ç›¸äº’å¼•ç”¨ï¼ˆå½¢æˆå¾ªç¯ï¼‰ï¼Œå³ä½¿å®ƒä»¬ä¸å†è¢«ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†è®¿é—®ï¼ˆå³ä»æ ¹ä¸å¯è¾¾ï¼‰ï¼Œå®ƒä»¬çš„å¼•ç”¨è®¡æ•°ä¹Ÿæ°¸è¿œä¸ä¼šå˜ä¸ºé›¶ï¼Œå¯¼è‡´å®ƒä»¬æ— æ³•è¢«å›æ”¶ï¼Œè¿™å°±æ˜¯å¼•ç”¨è®¡æ•°çš„ä¸»è¦å±€é™æ€§ã€‚æ ‡è®°-æ¸…é™¤ç®—æ³•åˆ™å¯ä»¥æ­£ç¡®å¤„ç†å¾ªç¯å¼•ç”¨ã€‚</p>
                        </div>
                    </div>
                </section>

                <section id="memory-leaks" class="content-section fade-in-section" style="animation-delay: 0.2s;">
                    <h2 class="flex items-center head2"><span class="material-icons">warning</span>å¸¸è§çš„å†…å­˜æ³„æ¼åœºæ™¯</h2>
                    <p class="mb-6"><span class="tooltip-term" data-tooltip="ç¨‹åºä¸­ä¸å†éœ€è¦çš„å†…å­˜ç”±äºæŒç»­è¢«å¼•ç”¨è€Œæ— æ³•è¢«GCå›æ”¶çš„ç°è±¡">å†…å­˜æ³„æ¼</span>æ˜¯æŒ‡ç¨‹åºä¸­ä¸å†éœ€è¦çš„å†…å­˜ï¼Œç”±äºæŸç§åŸå› ï¼ˆé€šå¸¸æ˜¯æ„å¤–çš„å¼•ç”¨ï¼‰æœªèƒ½è¢« GC é‡Šæ”¾ï¼Œå¯¼è‡´å¯ç”¨å†…å­˜é€æ¸å‡å°‘ã€‚</p>
                    <div class="content-card mb-6">
                        <h3 class="head3">1. æ„å¤–çš„å…¨å±€å˜é‡</h3>
                        <p class="mb-4">åœ¨éä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œç»™æœªå£°æ˜çš„å˜é‡èµ‹å€¼ä¼šåˆ›å»ºå…¨å±€å˜é‡ï¼Œé™¤éæ‰‹åŠ¨æ¸…é™¤ï¼Œå¦åˆ™ä¸ä¼šè¢«å›æ”¶ã€‚</p>
                        <pre><code class="language-javascript">// Accidental Global Variable Leak
function createLeak() {
    // å¿˜è®°ä½¿ç”¨ 'let', 'const', æˆ– 'var'
    leakyData = new Array(1000).fill("leak"); // åœ¨éä¸¥æ ¼æ¨¡å¼ä¸‹ä¼šåˆ›å»º window.leakyData
}
// createLeak(); // å¦‚æœè°ƒç”¨, leakyData ä¼šä¸€ç›´å­˜åœ¨äºå…¨å±€ä½œç”¨åŸŸ
// è§£å†³æ–¹æ³•: å§‹ç»ˆä½¿ç”¨ 'use strict'; æˆ–ç¡®ä¿ç”¨ let/const/var å£°æ˜å˜é‡</code></pre>
                    </div>
                    <div class="content-card mb-6">
                        <h3 class="head3">2. è¢«é—å¿˜çš„å®šæ—¶å™¨ (Timers)</h3>
                        <p class="mb-4"><code>setInterval</code> æˆ– <code>setTimeout</code> çš„å›è°ƒå‡½æ•°å¦‚æœæŒæœ‰å¤–éƒ¨å˜é‡çš„å¼•ç”¨ï¼ˆé—­åŒ…ï¼‰ï¼Œå¹¶ä¸”å®šæ—¶å™¨æœªè¢«æ¸…é™¤ (<code>clearInterval</code>, <code>clearTimeout</code>)ï¼Œä¼šå¯¼è‡´è¿™äº›å¤–éƒ¨å˜é‡æ— æ³•è¢«å›æ”¶ã€‚</p>
                        <pre><code class="language-javascript">// Forgotten Timer Leak
function startTimerLeak() {
    let largeObject = { data: new Array(10000).join('x') };
    // å®šæ—¶å™¨å›è°ƒå‡½æ•°æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œå®ƒæ•è·äº† largeObject
    let intervalId = setInterval(() => {
        // åªè¦å®šæ—¶å™¨åœ¨è¿è¡Œï¼ŒlargeObject å°±ä¸ä¼šè¢«å›æ”¶ï¼Œå³ä½¿å¤–éƒ¨ä¸å†éœ€è¦å®ƒ
        console.log("Timer tick referencing data length:", largeObject.data.length);
    }, 5000);

    // è§£å†³æ–¹æ³•: åœ¨ä¸å†éœ€è¦å®šæ—¶å™¨æ—¶ï¼Œå¿…é¡»è°ƒç”¨ clearInterval(intervalId)
    // ä¾‹å¦‚: setTimeout(() => clearInterval(intervalId), 20000); // 20ç§’ååœæ­¢
}
// startTimerLeak();</code></pre>
                    </div>
                     <div class="content-card mb-6">
                        <h3 class="head3">3. é—­åŒ… (Closures)</h3>
                        <p class="mb-4">é—­åŒ…æœ¬èº«ä¸æ˜¯æ³„æ¼ï¼Œä½†ä¸å½“ä½¿ç”¨æ—¶å¯èƒ½å¯¼è‡´ã€‚å¦‚æœä¸€ä¸ª<strong class="text-red-600">é•¿æœŸå­˜åœ¨</strong>çš„é—­åŒ…ï¼ˆå¦‚äº‹ä»¶ç›‘å¬å™¨ã€å…¨å±€å‡½æ•°ï¼‰å¼•ç”¨äº†ä¸å†éœ€è¦çš„å¤–éƒ¨å¤§å¯¹è±¡ï¼Œå°±ä¼šé˜»æ­¢è¯¥å¯¹è±¡è¢«å›æ”¶ã€‚</p>
                         <pre><code class="language-javascript">// Closure Leak Example
function setupListener() {
    let potentiallyLargeData = { details: "Very large data..." };
    let button = document.getElementById('myButton'); // å‡è®¾æŒ‰é’®å­˜åœ¨

    if (button) {
        // äº‹ä»¶ç›‘å¬å™¨çš„å›è°ƒå‡½æ•°æ˜¯ä¸€ä¸ªé—­åŒ…ï¼Œå®ƒæ•è·äº† potentiallyLargeData
        button.addEventListener('click', function handleClick() {
            // å³ä½¿ handleClick å‡½æ•°ä½“å†…éƒ¨æ²¡æœ‰ç›´æ¥ä½¿ç”¨ potentiallyLargeData,
            // ç”±äºé—­åŒ…æœºåˆ¶ï¼ŒpotentiallyLargeData ä»ç„¶è¢«ä¿æŒåœ¨å†…å­˜ä¸­ã€‚
            alert('Button clicked!');
        });
        // å¦‚æœæŒ‰é’®å’Œç›‘å¬å™¨ä¸€ç›´å­˜åœ¨ï¼ŒpotentiallyLargeData å°±ä¸ä¼šè¢«å›æ”¶ã€‚
    }
    // è§£å†³æ–¹æ³•:
    // 1. åœ¨æŒ‰é’®ç§»é™¤æˆ–ä¸å†éœ€è¦ç›‘å¬æ—¶ï¼Œæ˜ç¡®ç§»é™¤ç›‘å¬å™¨:
    //    button.removeEventListener('click', handleClick);
    // 2. å¦‚æœ handleClick ç¡®å®ä¸éœ€è¦ potentiallyLargeDataï¼Œ
    //    åœ¨ç›‘å¬å™¨è®¾ç½®åå°†å…¶è®¾ç½®ä¸º null: potentiallyLargeData = null;
}
// setupListener();</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">4. DOM å¼•ç”¨ (Detached DOM Nodes)</h3>
                        <p class="mb-4">å¦‚æœåœ¨ JavaScript ä¸­ä¿ç•™äº†å¯¹ DOM å…ƒç´ çš„å¼•ç”¨ï¼Œä½†è¯¥å…ƒç´ éšåä» DOM æ ‘ä¸­ç§»é™¤ï¼Œåªè¦ JS å¼•ç”¨å­˜åœ¨ï¼Œè¯¥ DOM å…ƒç´ åŠå…¶å…³è”å†…å­˜ï¼ˆåŒ…æ‹¬å­å…ƒç´ ã€äº‹ä»¶ç›‘å¬å™¨ï¼‰å°±æ— æ³•è¢«å›æ”¶ã€‚</p>
                        <pre><code class="language-javascript">// Detached DOM Leak Example
let detachedElements = []; // ç”¨ä¸€ä¸ªæ•°ç»„æŒæœ‰å¯¹ DOM å…ƒç´ çš„å¼•ç”¨

function removeAndLeak() {
    let parent = document.getElementById('container'); // å‡è®¾å®¹å™¨å­˜åœ¨
    let elementToRemove = document.getElementById('leakyElement'); // å‡è®¾è¦ç§»é™¤çš„å…ƒç´ å­˜åœ¨

    if (parent && elementToRemove) {
         // åœ¨ JavaScript ä¸­ä¿ç•™å¯¹è¯¥å…ƒç´ çš„å¼•ç”¨
        detachedElements.push(elementToRemove);

        // ä»çœŸå®çš„ DOM æ ‘ä¸­ç§»é™¤è¯¥å…ƒç´ 
        parent.removeChild(elementToRemove);

        // æ­¤æ—¶ï¼ŒelementToRemove å·²ç»ä¸åœ¨é¡µé¢ä¸Šäº†ï¼Œ
        // ä½†æ˜¯ detachedElements æ•°ç»„ä»ç„¶æŒæœ‰å¯¹å®ƒçš„å¼•ç”¨ã€‚
        // è¿™ä¼šé˜»æ­¢è¯¥ DOM èŠ‚ç‚¹åŠå…¶ç›¸å…³èµ„æºï¼ˆå¦‚äº‹ä»¶ç›‘å¬å™¨ï¼‰è¢«åƒåœ¾å›æ”¶ã€‚
        console.log("Element removed, but reference kept. Potential leak.");
    }
}
// removeAndLeak();
// è§£å†³æ–¹æ³•: å½“ç¡®å®šä¸å†éœ€è¦è¿™äº›åˆ†ç¦»çš„ DOM èŠ‚ç‚¹æ—¶ï¼Œ
// éœ€è¦æ¸…ç©º detachedElements æ•°ç»„æˆ–ç§»é™¤å…¶ä¸­çš„ç‰¹å®šå¼•ç”¨ã€‚
// ä¾‹å¦‚: detachedElements = [];</code></pre>
                         <p class="mt-4"><strong>å…³é”®ï¼š</strong>è¦ç‰¹åˆ«æ³¨æ„é‚£äº›<strong class="text-red-600">ç”Ÿå‘½å‘¨æœŸè¾ƒé•¿</strong>çš„å¯¹è±¡ï¼ˆå…¨å±€å˜é‡ã€äº‹ä»¶ç›‘å¬å™¨ã€ç¼“å­˜ã€å®šæ—¶å™¨ï¼‰æ‰€æŒæœ‰çš„å¼•ç”¨ï¼Œç¡®ä¿åœ¨ä¸å†éœ€è¦æ—¶åŠæ—¶<strong class="text-red-600">æ–­å¼€è¿™äº›å¼•ç”¨</strong>ï¼ˆä¾‹å¦‚ï¼Œè®¾ç½®ä¸º <code>null</code>ï¼Œç§»é™¤ç›‘å¬å™¨ï¼‰ã€‚</p>
                    </div>
                     <div class="quiz-card mt-6" id="quiz-leaks"> <div class="quiz-question"><span class="material-icons mr-1">quiz</span>å†…å­˜æ³„æ¼æµ‹éªŒï¼š ä»¥ä¸‹å“ªä¸ªæ“ä½œæœ€**ä¸å¯èƒ½**ç›´æ¥å¯¼è‡´å†…å­˜æ³„æ¼ï¼Ÿ</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="a">
                                <span>åœ¨å‡½æ•°å†…ä½¿ç”¨ <code>setInterval</code> ä½†å¿˜è®°è°ƒç”¨ <code>clearInterval</code>ã€‚</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="b">
                                <span>å°† DOM å…ƒç´ ä»é¡µé¢ç§»é™¤ï¼Œä½† JS ä¸­ä»æœ‰å˜é‡å¼•ç”¨å®ƒã€‚</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="c">
                                <span>åœ¨å‡½æ•°å†…éƒ¨å£°æ˜ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œå‡½æ•°æ‰§è¡Œå®Œæ¯•åè¯¥å˜é‡ä¸å†è¢«è®¿é—®ã€‚</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_leaks" value="d">
                                <span>åœ¨éä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œç»™ä¸€ä¸ªæœªå£°æ˜çš„å˜é‡èµ‹å€¼ã€‚</span>
                            </label>
                        </div>
                         <div class="quiz-feedback mt-4" id="feedback-q_leaks"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_leaks', 'c')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">æ£€æŸ¥ç­”æ¡ˆ</span>
                        </button>
                         <div class="quiz-answer" style="display: none;">
                            <p><strong>ç­”æ¡ˆ:</strong> C. åœ¨å‡½æ•°å†…éƒ¨å£°æ˜ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œå‡½æ•°æ‰§è¡Œå®Œæ¯•åè¯¥å˜é‡ä¸å†è¢«è®¿é—®ã€‚</p>
                            <p><strong>è§£æ:</strong></p>
                            <ul>
                                <li>A: è¢«é—å¿˜çš„å®šæ—¶å™¨æ˜¯å¸¸è§çš„æ³„æ¼æºï¼Œå›è°ƒé—­åŒ…å¯èƒ½æŒæœ‰å¤–éƒ¨å¼•ç”¨ã€‚</li>
                                <li>B: åˆ†ç¦»çš„ DOM èŠ‚ç‚¹å¦‚æœä»è¢« JS å¼•ç”¨ï¼Œåˆ™æ— æ³•è¢«å›æ”¶ã€‚</li>
                                <li>C: å‡½æ•°æ‰§è¡Œå®Œæ¯•åï¼Œå…¶å±€éƒ¨å˜é‡é€šå¸¸ä¼šéšç€å‡½æ•°æ‰§è¡Œä¸Šä¸‹æ–‡çš„å‡ºæ ˆè€Œå˜å¾—ä¸å¯è¾¾ï¼ˆé™¤éè¢«é—­åŒ…æ•è·ï¼‰ï¼Œè¿™æ˜¯æ­£å¸¸çš„å†…å­˜ç®¡ç†ï¼Œä¸æ˜¯æ³„æ¼ã€‚</li>
                                <li>D: æ„å¤–çš„å…¨å±€å˜é‡ä¼šä¸€ç›´å­˜åœ¨ï¼Œé™¤éæ‰‹åŠ¨æ¸…é™¤ï¼Œæ˜¯å…¸å‹çš„æ³„æ¼åœºæ™¯ã€‚</li>
                            </ul>
                        </div>
                    </div>
                </section>

            </article>
        </main>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' }); // Using neutral theme

        // --- Color Constants for Visualizations ---
        const NODE_COLOR = '#60a5fa'; // blue-400
        const ROOT_COLOR = '#f87171'; // red-400
        const MARKED_COLOR = '#34d399'; // emerald-400
        const UNREACHABLE_COLOR = '#9ca3af'; // gray-400
        const CYCLIC_COLOR = '#facc15'; // yellow-400
        const LINE_COLOR = '#6b7280'; // gray-500
        const TEXT_COLOR = '#1f2937'; // gray-800
        const COUNT_COLOR = '#dc2626'; // red-600

        // --- Base Node Class for Visualizations ---
        class VizNode {
            constructor(id, x, y, radius = 20) {
                this.id = id;
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = NODE_COLOR;
                this.references = []; // Nodes this node points to
                this.isRoot = false;
                this.isMarked = false;
                this.isCyclic = false; // Specific flag for cycles
                this.refCount = 0; // For Reference Counting
                this.isCollected = false; // Flag for collected state
            }

            draw(ctx) {
                if (this.isCollected) return; // Don't draw collected nodes

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);

                // Determine fill color based on state
                let fillColor = this.color;
                if (this.isRoot) fillColor = ROOT_COLOR;
                else if (this.isMarked) fillColor = MARKED_COLOR;
                else if (this.isCyclic) fillColor = CYCLIC_COLOR; // Highlight cyclic nodes

                ctx.fillStyle = fillColor;
                ctx.fill();
                ctx.strokeStyle = LINE_COLOR;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.closePath();

                // Draw Node ID
                ctx.fillStyle = TEXT_COLOR;
                ctx.font = '12px Inter';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.id, this.x, this.y);

                // Draw Reference Count (for RC viz)
                 if (this.refCount !== undefined && typeof this.refCount === 'number') {
                     ctx.fillStyle = COUNT_COLOR;
                     ctx.font = 'bold 10px Inter';
                     ctx.fillText(this.refCount, this.x + this.radius * 0.7, this.y - this.radius * 0.7);
                 }
            }

             drawReferences(ctx, nodes) {
                if (this.isCollected) return;
                ctx.strokeStyle = LINE_COLOR;
                ctx.lineWidth = 1.5;

                this.references.forEach(targetId => {
                    const targetNode = nodes.find(n => n.id === targetId);
                    if (targetNode && !targetNode.isCollected) {
                        ctx.beginPath();
                        // Calculate arrow position slightly outside the circles
                        const angle = Math.atan2(targetNode.y - this.y, targetNode.x - this.x);
                        const startX = this.x + this.radius * Math.cos(angle);
                        const startY = this.y + this.radius * Math.sin(angle);
                        const endX = targetNode.x - targetNode.radius * Math.cos(angle);
                        const endY = targetNode.y - targetNode.radius * Math.sin(angle);

                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw arrowhead
                        const arrowSize = 6;
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fillStyle = LINE_COLOR;
                        ctx.fill();
                    }
                });
            }
        }

        // --- Mark-and-Sweep Visualization Logic ---
        class MarkSweepVisualizer {
            constructor(canvasId, statusId) {
                this.canvas = document.getElementById(canvasId);
                this.statusElement = document.getElementById(statusId);
                if (!this.canvas) {
                    console.error(`Canvas element with ID ${canvasId} not found.`);
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.roots = [];
                this.animationFrameId = null;
                this.initialize();
            }

            initialize() {
                this.nodes = [];
                this.roots = [];
                // Create initial scene
                const root1 = new VizNode('R1', 50, this.canvas.height / 2);
                root1.isRoot = true;
                const nodeA = new VizNode('A', 150, this.canvas.height / 2 - 50);
                const nodeB = new VizNode('B', 150, this.canvas.height / 2 + 50);
                const nodeC = new VizNode('C', 250, this.canvas.height / 2); // Initially unreachable

                root1.references.push('A');
                root1.references.push('B');
                nodeA.references.push('C'); // A -> C

                this.nodes.push(root1, nodeA, nodeB, nodeC);
                this.roots.push(root1);

                this.draw();
                this.updateStatus("åœºæ™¯å·²é‡ç½®ã€‚");
            }

            reset() {
                cancelAnimationFrame(this.animationFrameId);
                this.initialize();
            }

            createCycle() {
                 // Reset marks before creating cycle for clarity
                this.nodes.forEach(node => { node.isMarked = false; node.color = NODE_COLOR; node.isCyclic = false; node.isCollected = false; });

                const nodeD = new VizNode('D', 350, this.canvas.height / 2 - 50);
                const nodeE = new VizNode('E', 350, this.canvas.height / 2 + 50);
                nodeD.references.push('E');
                nodeE.references.push('D');
                nodeD.isCyclic = true; // Mark for visual distinction
                nodeE.isCyclic = true;
                this.nodes.push(nodeD, nodeE);
                this.draw();
                 this.updateStatus("åˆ›å»ºäº†å¾ªç¯å¼•ç”¨ D <-> E (ç›®å‰ä¸å¯è¾¾)ã€‚");
            }

             markPhase() {
                this.updateStatus("æ‰§è¡Œæ ‡è®°é˜¶æ®µ...");
                // Reset previous marks but keep roots and cycles visually distinct if needed
                this.nodes.forEach(node => {
                    node.isMarked = false;
                    node.isCollected = false; // Ensure nodes are drawable
                    if (!node.isRoot && !node.isCyclic) node.color = NODE_COLOR;
                    else if (node.isCyclic) node.color = CYCLIC_COLOR;
                });
                this.draw(); // Redraw with reset marks

                const queue = [...this.roots];
                const markedSet = new Set(this.roots.map(r => r.id));
                this.roots.forEach(r => r.isMarked = true);

                let delay = 0;
                const markDelay = 500; // ms delay between marking steps

                const processQueue = () => {
                    if (queue.length === 0) {
                         this.updateStatus("æ ‡è®°é˜¶æ®µå®Œæˆã€‚");
                         this.draw(); // Final draw after marking
                        return;
                    }

                    const currentNode = queue.shift();
                    currentNode.isMarked = true; // Ensure marked
                    currentNode.color = MARKED_COLOR; // Visually mark

                    // Schedule redraw after a delay
                    setTimeout(() => {
                         this.draw(); // Draw current state
                         // Add reachable, unmarked neighbors to queue
                        currentNode.references.forEach(targetId => {
                            if (!markedSet.has(targetId)) {
                                const targetNode = this.nodes.find(n => n.id === targetId);
                                if (targetNode) {
                                    markedSet.add(targetId);
                                    queue.push(targetNode);
                                }
                            }
                        });
                         processQueue(); // Process next item in queue
                    }, delay);
                    delay += markDelay; // Increment delay for next step
                };

                processQueue(); // Start the marking process
            }


            sweepPhase() {
                this.updateStatus("æ‰§è¡Œæ¸…é™¤é˜¶æ®µ...");
                let delay = 0;
                const sweepDelay = 300;

                this.nodes.forEach((node, index) => {
                    if (!node.isMarked && !node.isRoot) { // Don't sweep roots
                        setTimeout(() => {
                            node.isCollected = true; // Mark as collected
                            this.draw(); // Redraw to show node removed
                            if (index === this.nodes.length - 1) {
                                this.updateStatus("æ¸…é™¤é˜¶æ®µå®Œæˆã€‚ä¸å¯è¾¾å¯¹è±¡å·²è¢«å›æ”¶ã€‚");
                            }
                        }, delay);
                        delay += sweepDelay;
                    }
                });
                 // If no nodes to sweep, update status immediately
                if (delay === 0) {
                    this.updateStatus("æ¸…é™¤é˜¶æ®µå®Œæˆã€‚æ²¡æœ‰éœ€è¦å›æ”¶çš„å¯¹è±¡ã€‚");
                }
            }


            draw() {
                 // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw all references first (lines behind nodes)
                this.nodes.forEach(node => node.drawReferences(this.ctx, this.nodes));

                // Draw all nodes
                this.nodes.forEach(node => node.draw(this.ctx));
            }

             updateStatus(message) {
                if (this.statusElement) {
                    this.statusElement.textContent = message;
                }
            }
        }


        // --- Reference Counting Visualization Logic ---
        class RefCountVisualizer {
            constructor(canvasId, statusId) {
                this.canvas = document.getElementById(canvasId);
                 this.statusElement = document.getElementById(statusId);
                if (!this.canvas) {
                    console.error(`Canvas element with ID ${canvasId} not found.`);
                    return;
                }
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.references = []; // Store refs as { sourceId, targetId }
                this.objCounter = 0;
                this.initialize();
            }

            initialize() {
                this.nodes = [];
                this.references = [];
                this.objCounter = 0;
                // Create a root node representation (doesn't have count itself)
                const root = new VizNode('Root', 50, this.canvas.height / 2);
                root.isRoot = true;
                root.refCount = undefined; // Roots don't have counts in this model
                this.nodes.push(root);
                this.draw();
                this.updateStatus("åœºæ™¯å·²é‡ç½®ã€‚");
            }

            reset() {
                this.initialize();
            }

            createObject() {
                this.objCounter++;
                const newNodeId = `Obj${this.objCounter}`;
                // Try to place new nodes without overlapping too much
                const x = 150 + (this.nodes.length -1) % 4 * 100;
                const y = 100 + Math.floor((this.nodes.length -1) / 4) * 100;
                const newNode = new VizNode(newNodeId, x, y);
                newNode.refCount = 0; // Initial count is 0
                this.nodes.push(newNode);
                this.draw();
                this.updateStatus(`åˆ›å»ºäº†å¯¹è±¡ ${newNodeId} (Count: 0)ã€‚`);
            }

            addReference() {
                // Simple logic: Add ref from Root to the last created object if possible
                const root = this.nodes.find(n => n.isRoot);
                const targetNode = this.nodes[this.nodes.length - 1]; // Last added node

                if (root && targetNode && targetNode !== root) {
                     // Check if reference already exists to avoid duplicates visually
                    const exists = this.references.some(ref => ref.sourceId === root.id && ref.targetId === targetNode.id);
                    if (!exists) {
                        this.references.push({ sourceId: root.id, targetId: targetNode.id });
                        targetNode.refCount++;
                        this.draw();
                        this.updateStatus(`æ·»åŠ å¼•ç”¨ Root -> ${targetNode.id} (Count: ${targetNode.refCount})ã€‚`);
                    } else {
                         this.updateStatus(`å¼•ç”¨ Root -> ${targetNode.id} å·²å­˜åœ¨ã€‚`);
                    }
                } else {
                    this.updateStatus("æ— æ³•æ·»åŠ å¼•ç”¨ï¼ˆéœ€è¦å…ˆåˆ›å»ºå¯¹è±¡ï¼‰ã€‚");
                }
            }

            removeReference() {
                 // Simple logic: Remove the last added reference from Root if possible
                const root = this.nodes.find(n => n.isRoot);
                if (this.references.length > 0) {
                    const lastRefIndex = this.references.findIndex(ref => ref.sourceId === root.id); // Find last ref FROM ROOT
                    if (lastRefIndex !== -1) {
                        const removedRef = this.references.splice(lastRefIndex, 1)[0];
                        const targetNode = this.nodes.find(n => n.id === removedRef.targetId);
                        if (targetNode) {
                            targetNode.refCount--;
                            this.draw();
                            this.updateStatus(`ç§»é™¤å¼•ç”¨ Root -> ${targetNode.id} (Count: ${targetNode.refCount})ã€‚`);
                        }
                    } else {
                         this.updateStatus("æ²¡æœ‰ä» Root å‘å‡ºçš„å¼•ç”¨å¯ç§»é™¤ã€‚");
                    }

                } else {
                    this.updateStatus("æ²¡æœ‰å¼•ç”¨å¯ç§»é™¤ã€‚");
                }
            }

             createCycle() {
                // Create two new objects and make them reference each other
                if (this.nodes.filter(n => !n.isRoot).length >= 2) {
                     this.updateStatus("åœºæ™¯ä¸­å·²æœ‰å¯¹è±¡ï¼Œè¯·é‡ç½®åå†åˆ›å»ºå¾ªç¯ã€‚");
                     return;
                }
                 this.createObject(); // Obj1
                 const node1 = this.nodes[this.nodes.length - 1];
                 this.createObject(); // Obj2
                 const node2 = this.nodes[this.nodes.length - 1];

                 if (node1 && node2) {
                     // Add references Obj1 -> Obj2 and Obj2 -> Obj1
                     this.references.push({ sourceId: node1.id, targetId: node2.id });
                     node2.refCount++;
                     this.references.push({ sourceId: node2.id, targetId: node1.id });
                     node1.refCount++;
                     node1.isCyclic = true; // Mark for visual distinction
                     node2.isCyclic = true;
                     node1.color = CYCLIC_COLOR;
                     node2.color = CYCLIC_COLOR;

                     this.draw();
                     this.updateStatus(`åˆ›å»ºäº†å¾ªç¯å¼•ç”¨ ${node1.id} (Count: ${node1.refCount}) <-> ${node2.id} (Count: ${node2.refCount})ã€‚å°è¯•ç§»é™¤ Root çš„å¼•ç”¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰å¹¶å›æ”¶ã€‚`);
                 }
            }

            collectGarbage() {
                this.updateStatus("å°è¯•å›æ”¶ Count ä¸º 0 çš„å¯¹è±¡...");
                let collected = false;
                const nodesToRemove = [];

                this.nodes.forEach(node => {
                    if (!node.isRoot && node.refCount === 0) {
                        nodesToRemove.push(node.id);
                        collected = true;
                         // Also remove references *originating* from the collected node
                        this.references = this.references.filter(ref => {
                            if (ref.sourceId === node.id) {
                                const target = this.nodes.find(n => n.id === ref.targetId);
                                if (target) target.refCount--; // Decrement target count
                                return false; // Remove this reference
                            }
                            return true;
                        });
                    }
                });

                 // Remove collected nodes from the main list
                 this.nodes = this.nodes.filter(node => !nodesToRemove.includes(node.id));
                 // Remove references *pointing to* collected nodes
                 this.references = this.references.filter(ref => !nodesToRemove.includes(ref.targetId));


                if (collected) {
                     this.updateStatus(`å›æ”¶äº† Count ä¸º 0 çš„å¯¹è±¡ã€‚${nodesToRemove.length > 1 ? 'å®ƒä»¬' : 'å®ƒ'}ä»¥åŠæŒ‡å‘å®ƒä»¬çš„å¼•ç”¨å·²è¢«ç§»é™¤ã€‚`);
                     // Recursively collect if removing references caused other counts to drop to 0
                     // Simple immediate check:
                     if (this.nodes.some(n => !n.isRoot && n.refCount === 0)) {
                         this.collectGarbage(); // Trigger another collection cycle if needed
                     } else {
                          this.draw(); // Redraw after collection
                     }
                } else {
                    this.updateStatus("æ²¡æœ‰ Count ä¸º 0 çš„å¯¹è±¡å¯å›æ”¶ã€‚æ³¨æ„å¾ªç¯å¼•ç”¨ï¼");
                    this.draw();
                }
            }

             draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw references
                this.ctx.strokeStyle = LINE_COLOR;
                this.ctx.lineWidth = 1.5;
                this.references.forEach(ref => {
                    const sourceNode = this.nodes.find(n => n.id === ref.sourceId);
                    const targetNode = this.nodes.find(n => n.id === ref.targetId);
                    if (sourceNode && targetNode) {
                         // Draw line with arrow
                        const angle = Math.atan2(targetNode.y - sourceNode.y, targetNode.x - sourceNode.x);
                        const startRadius = sourceNode.isRoot ? sourceNode.radius * 0.6 : sourceNode.radius; // Smaller start for root
                        const startX = sourceNode.x + startRadius * Math.cos(angle);
                        const startY = sourceNode.y + startRadius * Math.sin(angle);
                        const endX = targetNode.x - targetNode.radius * Math.cos(angle);
                        const endY = targetNode.y - targetNode.radius * Math.sin(angle);

                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();

                        // Draw arrowhead
                        const arrowSize = 6;
                        ctx.beginPath();
                        ctx.moveTo(endX, endY);
                        ctx.lineTo(endX - arrowSize * Math.cos(angle - Math.PI / 6), endY - arrowSize * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(endX - arrowSize * Math.cos(angle + Math.PI / 6), endY - arrowSize * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fillStyle = LINE_COLOR;
                        ctx.fill();
                    }
                });

                // Draw nodes
                this.nodes.forEach(node => node.draw(this.ctx));
            }

             updateStatus(message) {
                if (this.statusElement) {
                    this.statusElement.textContent = message;
                }
            }
        }


        // --- Ripple Effect Logic ---
        function createRipple(event) {
            const button = event.currentTarget;
            if (!button || typeof button.getBoundingClientRect !== 'function') return;
            const circle = document.createElement("span");
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;
            const primaryColorRgb = getComputedStyle(document.documentElement).getPropertyValue('--primary-color-rgb') || '59, 130, 246';
            circle.style.width = circle.style.height = `${diameter}px`;
            const rect = button.getBoundingClientRect();
            circle.style.left = `${event.clientX - rect.left - radius}px`;
            circle.style.top = `${event.clientY - rect.top - radius}px`;
            circle.style.backgroundColor = `rgba(${primaryColorRgb}, 0.4)`;
            circle.classList.add("ripple");
            const existingRipple = button.querySelector(".ripple");
            if (existingRipple) existingRipple.remove();
            button.appendChild(circle);
            setTimeout(() => circle.remove(), 600);
        }

        // --- Quiz Toggle Logic ---
        function toggleAnswer(quizId, buttonElement) {
            const quizCard = document.getElementById(quizId);
            if (!quizCard) return;
            const answer = quizCard.querySelector('.quiz-answer');
            const icon = buttonElement.querySelector('.icon-arrow');
            const buttonTextSpan = buttonElement.querySelector('.button-text');
            if (!answer || !icon || !buttonTextSpan) return;
            const isVisible = answer.classList.contains('visible');
            if (isVisible) {
                answer.style.maxHeight = '0';
                answer.style.opacity = '0';
                answer.style.marginTop = '0';
                answer.style.paddingTop = '0';
                answer.style.paddingBottom = '0';
                answer.classList.remove('visible');
                icon.classList.remove('rotated');
                buttonTextSpan.textContent = ' æŸ¥çœ‹ç­”æ¡ˆ';
                setTimeout(() => {
                    if (!answer.classList.contains('visible')) {
                         answer.style.removeProperty('max-height');
                         answer.style.removeProperty('opacity');
                         answer.style.removeProperty('margin-top');
                         answer.style.removeProperty('padding-top');
                         answer.style.removeProperty('padding-bottom');
                         answer.style.display = 'none'; // Explicitly hide after transition
                    }
                }, 500);
            } else {
                answer.style.display = 'block'; // Make it visible to measure
                answer.style.paddingTop = '1rem';
                answer.style.paddingBottom = '1rem';
                answer.style.marginTop = '1rem';
                requestAnimationFrame(() => {
                    answer.style.maxHeight = answer.scrollHeight + 'px';
                    answer.style.opacity = '1';
                    answer.classList.add('visible');
                    icon.classList.add('rotated');
                    buttonTextSpan.textContent = ' éšè—ç­”æ¡ˆ';
                });
            }
        }

        // --- Quiz Check Answer Logic ---
        function checkAnswer(questionName, correctAnswerValue) {
            const options = document.querySelectorAll(`input[name="${questionName}"]`);
            const feedbackElement = document.getElementById(`feedback-${questionName}`);
            const quizCard = feedbackElement ? feedbackElement.closest('.quiz-card') : null;
            let selectedValue = null;
            let selectedLabel = null;
            if (!feedbackElement || !quizCard) return;

            quizCard.querySelectorAll('.quiz-option').forEach(opt => opt.classList.remove('selected', 'correct', 'incorrect'));
            options.forEach(option => {
                if (option.checked) {
                    selectedValue = option.value;
                    selectedLabel = option.closest('.quiz-option');
                    if (selectedLabel) selectedLabel.classList.add('selected');
                }
            });

            if (!selectedValue) {
                feedbackElement.textContent = "è¯·é€‰æ‹©ä¸€ä¸ªé€‰é¡¹ï¼";
                feedbackElement.className = 'quiz-feedback warning';
                feedbackElement.style.display = 'block';
                return;
            }

            let correctAnswerLabel = null;
            options.forEach(opt => { if (opt.value === correctAnswerValue) correctAnswerLabel = opt.closest('.quiz-option'); });

            if (selectedValue === correctAnswerValue) {
                feedbackElement.textContent = "å›ç­”æ­£ç¡®ï¼";
                feedbackElement.className = 'quiz-feedback correct';
                if(selectedLabel) selectedLabel.classList.add('correct');
            } else {
                let correctAnswerText = '';
                if (correctAnswerLabel) {
                    correctAnswerText = correctAnswerLabel.querySelector('span')?.textContent || `é€‰é¡¹ ${correctAnswerValue}`;
                    correctAnswerLabel.classList.add('correct');
                }
                feedbackElement.textContent = `å›ç­”é”™è¯¯ã€‚æ­£ç¡®ç­”æ¡ˆæ˜¯: "${correctAnswerText}"`;
                feedbackElement.className = 'quiz-feedback incorrect';
                if(selectedLabel) selectedLabel.classList.add('incorrect');
            }
            feedbackElement.style.display = 'block';

            // Show answer section when checking
            const answerSection = quizCard.querySelector('.quiz-answer');
            const toggleButton = quizCard.querySelector('.quiz-toggle'); // Find the toggle button for this quiz
             if (answerSection && !answerSection.classList.contains('visible') && toggleButton) {
                 // Find the associated toggle button and click it programmatically OR call toggleAnswer directly
                 // Calling toggleAnswer is safer if the button itself handles checking
                 // toggleAnswer(quizCard.id, toggleButton); // Uncomment if toggle button should reveal answer
            } else if (answerSection && answerSection.classList.contains('visible') && toggleButton) {
                 // If answer is already visible, maybe just ensure feedback is scrolled into view
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            // --- TOC Highlighting Logic ---
            const sections = document.querySelectorAll('main section[id]');
            const tocLinks = document.querySelectorAll('#local-toc a');
            let lastActiveTocLink = null;
            const tocObserverOptions = { root: null, rootMargin: '-20% 0px -60% 0px', threshold: 0 };
            const tocObserverCallback = (entries) => {
                let bestVisibleEntry = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (!bestVisibleEntry || entry.boundingClientRect.top < bestVisibleEntry.boundingClientRect.top) bestVisibleEntry = entry;
                    }
                });
                if (bestVisibleEntry) {
                    const id = bestVisibleEntry.target.getAttribute('id');
                    const activeLink = document.querySelector(`#local-toc a[href="#${id}"], #local-toc a[href="#gc-viz-${id.split('-').pop()}"]`); // Match section or viz ID
                    if (activeLink && activeLink !== lastActiveTocLink) {
                        if (lastActiveTocLink) lastActiveTocLink.classList.remove('active');
                        activeLink.classList.add('active');
                        lastActiveTocLink = activeLink;
                    }
                }
            };
            const tocObserver = new IntersectionObserver(tocObserverCallback, tocObserverOptions);
            sections.forEach(section => tocObserver.observe(section));
            // Also observe visualization containers for TOC highlighting
            document.querySelectorAll('.visualization-container[id]').forEach(viz => tocObserver.observe(viz));


            // Initial active link check
            const currentHash = window.location.hash;
            if (currentHash) {
                const initialActiveLink = document.querySelector(`#local-toc a[href="${currentHash}"]`);
                if (initialActiveLink) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    initialActiveLink.classList.add('active');
                    lastActiveTocLink = initialActiveLink;
                }
            } else if (tocLinks.length > 0 && !lastActiveTocLink) {
                 tocLinks.forEach(link => link.classList.remove('active'));
                 tocLinks[0].classList.add('active');
                 lastActiveTocLink = tocLinks[0];
            }

            // --- Fade-in Animation Logic ---
            const mainContentSections = document.querySelectorAll('main > article > section.content-section');
            const fadeObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
            const fadeObserverCallback = (entries, observer) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const delayIndex = Array.from(mainContentSections).indexOf(entry.target);
                        entry.target.style.animationDelay = `${delayIndex * 0.05}s`;
                        entry.target.classList.add('fade-in-section');
                        observer.unobserve(entry.target);
                    }
                });
            };
            const fadeObserver = new IntersectionObserver(fadeObserverCallback, fadeObserverOptions);
            mainContentSections.forEach(section => fadeObserver.observe(section));

            // --- Initialize Visualizations ---
            let msViz = null;
            let rcViz = null;
            try {
                 msViz = new MarkSweepVisualizer('markSweepCanvas', 'msStatus');
                 rcViz = new RefCountVisualizer('refCountCanvas', 'rcStatus');
            } catch (e) {
                console.error("Error initializing visualizations:", e);
            }


            // --- Attach Event Listeners ---
            // Mark-Sweep Controls
            document.getElementById('msResetBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.reset(); });
            document.getElementById('msCreateCycleBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.createCycle(); });
            document.getElementById('msMarkBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.markPhase(); });
            document.getElementById('msSweepBtn')?.addEventListener('click', (e) => { createRipple(e); msViz?.sweepPhase(); });

            // Reference Counting Controls
            document.getElementById('rcResetBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.reset(); });
            document.getElementById('rcCreateObjBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.createObject(); });
            document.getElementById('rcAddRefBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.addReference(); });
            document.getElementById('rcRemoveRefBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.removeReference(); });
            document.getElementById('rcCreateCycleBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.createCycle(); });
            document.getElementById('rcCollectBtn')?.addEventListener('click', (e) => { createRipple(e); rcViz?.collectGarbage(); });


            // Quiz Toggle Buttons (using onclick in HTML for checkAnswer, need separate toggle logic)
             document.querySelectorAll('.quiz-card .quiz-toggle').forEach(button => {
                 // Find the quiz card ID to associate toggle with answer section
                 const quizCard = button.closest('.quiz-card');
                 const quizId = quizCard?.id;
                 const answerSection = quizCard?.querySelector('.quiz-answer');
                 const checkButton = quizCard?.querySelector('button[onclick^="checkAnswer"]'); // Find the check button

                 if (quizId && answerSection) {
                     // If the toggle button itself IS NOT the check button
                     if (button !== checkButton) {
                         button.addEventListener('click', (event) => {
                             createRipple(event);
                             toggleAnswer(quizId, button);
                         });
                     } else {
                        // If the toggle button IS the check button, add ripple but let onclick handle check/toggle
                         button.addEventListener('click', createRipple);
                         // Modify checkAnswer to call toggleAnswer if needed
                         // OR adjust HTML to have separate check and toggle buttons
                     }
                 }
             });

             // Adjust checkAnswer to toggle visibility
             const originalCheckAnswer = window.checkAnswer;
             window.checkAnswer = function(questionName, correctAnswerValue) {
                 originalCheckAnswer(questionName, correctAnswerValue); // Call original logic
                 const feedbackElement = document.getElementById(`feedback-${questionName}`);
                 const quizCard = feedbackElement?.closest('.quiz-card');
                 const toggleButton = quizCard?.querySelector('.quiz-toggle'); // Assuming one toggle button per card
                 const answerSection = quizCard?.querySelector('.quiz-answer');

                 // If feedback is shown, ensure the answer section is visible
                 if (quizCard && toggleButton && answerSection && !answerSection.classList.contains('visible')) {
                    toggleAnswer(quizCard.id, toggleButton);
                 }
             }

        });
    </script>

</body>

</html>
