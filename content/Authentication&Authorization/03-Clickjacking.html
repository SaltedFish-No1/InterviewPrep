<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clickjacking (点击劫持) 与防御</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="../../global.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <style>
        /* Minimal inline styles - Rely on global.css and Tailwind */
        /* Ensure styles from global.css like .page-container, .local-side-nav, .content-main, .content-card etc. are loaded */

        /* --- Base & Layout Adjustments --- */
        html {
            scroll-padding-top: 6rem;
            /* Adjust based on potential sticky nav height */
        }

        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
            background-color: var(--bg-color-lighter);
            /* From global.css */
            color: var(--text-color-default);
            /* From global.css */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* --- Typography --- */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            scroll-margin-top: 6rem;
            /* Offset for sticky nav */
        }

        /* Use heading styles from global.css if defined (e.g., .head1, .head2) */
        /* Otherwise, define basic styles */
        h1.head1 {
            /* Assumes .head1 is defined in global.css */
        }

        h2.head2 {
            /* Assumes .head2 is defined in global.css */
        }

        h3.head3 {
            /* Assumes .head3 is defined in global.css */
        }

        /* Add margin to paragraphs within content cards for better readability */
        .content-card>p {
            margin-bottom: 1rem;
            /* Equivalent to mb-4 */
        }

        .content-card>p:last-child {
            margin-bottom: 0;
            /* Remove margin from last paragraph in a card */
        }

        .content-card>ul,
        .content-card>ol {
            margin-bottom: 1rem;
            /* Add margin to lists as well */
        }

        .content-card>ul:last-child,
        .content-card>ol:last-child {
            margin-bottom: 0;
        }

        .content-card>pre:last-child {
            margin-bottom: 0;
        }

        .content-card>div:last-child {
            /* Target last div like mermaid or notes */
            margin-bottom: 0;
        }


        /* Ensure code blocks are styled correctly */
        article pre {
            font-family: var(--font-family-mono);
            border-radius: 0.375rem;
            margin: 1rem 0;
            padding: 1em;
            overflow: auto;
            background-color: var(--bg-color-light);
            /* From global.css */
            border: 1px solid var(--border-color-light);
            /* From global.css */
        }

        article pre code[class*="language-"] {
            background: none;
            color: inherit;
            padding: 0;
            font-size: inherit;
            font-family: inherit;
            line-height: inherit;
            white-space: pre;
            display: block;
        }

        *:not(pre)>code {
            /* Inline code style */
            background-color: var(--primary-color-light);
            color: var(--primary-color-dark);
            padding: 0.1rem 0.4rem;
            border-radius: 0.25rem;
        }

        /* --- Fade-in Animation --- */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-section {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* --- Tooltip Styling (if needed, copy from example.html or global.css) --- */
        .tooltip-term {
            border-bottom: 1px dotted var(--primary-color);
            cursor: help;
            position: relative;
            color: var(--primary-color);
            font-weight: 500;
        }

        .tooltip-term::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 0.4rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }

        .tooltip-term::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(0px);
            border-width: 5px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.85) transparent transparent transparent;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }

        .tooltip-term:hover::before,
        .tooltip-term:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* Mermaid styling from global.css or example.html */
        .mermaid {
            margin: 1.5rem 0;
            text-align: center;
            background-color: var(--bg-color-light);
            padding: 1rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color-light);
        }

        .mermaid svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: auto;
        }

        /* --- Card Hover Effect --- */
        .content-card {
            transition: box-shadow 0.2s ease-in-out;
            /* Add transition for smooth effect */
        }

        .content-card:hover {
            /* Slightly increase shadow - Tailwind shadow-lg equivalent */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        /* --- Quiz Card Styling (Ensure styles from global.css are sufficient) --- */
        /* Add ripple effect if desired and implemented in JS */
        .quiz-toggle {
            /* Apply to the button that toggles the answer */
            position: relative;
            overflow: hidden;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(var(--primary-color-rgb, 59, 130, 246), 0.4);
            /* Use RGB for opacity */
            transform: scale(0);
            animation: ripple-animation 0.6s linear;
            pointer-events: none;
        }

        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        .quiz-toggle .material-icons {
            font-size: 1.1rem;
            transition: transform 0.3s ease-in-out;
            vertical-align: middle;
            /* Align icon better */
        }

        .quiz-toggle .icon-arrow.rotated {
            transform: rotate(180deg);
        }

        .quiz-answer {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out, padding-bottom 0.5s ease-in-out, margin-top 0.5s ease-in-out;
            overflow: hidden;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            border-top: 1px solid var(--border-color-default);
            /* Add border top */
            background-color: var(--bg-color-lighter);
            border-radius: 0 0 0.375rem 0.375rem;
            /* Round bottom corners */
            color: var(--text-color-default);
        }

        .quiz-answer.visible {
            max-height: 1000px;
            /* Adjust if needed for very long answers */
            opacity: 1;
            padding-top: 1rem;
            padding-bottom: 1rem;
            margin-top: 1rem;
            /* Add margin when visible */
            overflow: auto;
        }

        /* Ensure quiz options have appropriate styling from global.css */
        /* Add specific styles if global.css is missing them */
        .quiz-option {
            display: flex;
            /* Use flex for alignment */
            align-items: center;
            /* Center items vertically */
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color-default);
            border-radius: 0.375rem;
            background-color: white;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .quiz-option:hover {
            background-color: var(--quiz-option-hover-bg, rgba(59, 130, 246, 0.1));
            border-color: var(--primary-color);
        }

        .quiz-option input[type="radio"] {
            margin-right: 0.75rem;
            /* space between radio and text */
            flex-shrink: 0;
            /* Prevent radio button from shrinking */
            accent-color: var(--primary-color);
            /* Style the radio button itself */
        }

        .quiz-option span {
            /* The text label */
            flex-grow: 1;
        }

        .quiz-option.selected {
            border-color: var(--primary-color);
            background-color: rgba(59, 130, 246, 0.15);
        }

        .quiz-option.correct {
            border-color: var(--success-color, #10b981);
            background-color: var(--success-color-light, #ecfdf5);
        }

        .quiz-option.incorrect {
            border-color: var(--danger-color, #ef4444);
            background-color: var(--danger-color-light, #fee2e2);
        }

        .quiz-feedback {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            display: none;
            /* Initially hidden */
            border: 1px solid transparent;
        }

        .quiz-feedback.correct {
            background-color: var(--quiz-feedback-correct-bg, #ecfdf5);
            color: var(--quiz-feedback-correct-text, #10b981);
            border-color: var(--success-color, #10b981);
            display: block;
        }

        .quiz-feedback.incorrect {
            background-color: var(--quiz-feedback-incorrect-bg, #fee2e2);
            color: var(--quiz-feedback-incorrect-text, #ef4444);
            border-color: var(--danger-color, #ef4444);
            display: block;
        }

        .quiz-feedback.warning {
            background-color: var(--warning-color-light, #fff7ed);
            color: var(--warning-color, #f97316);
            border-color: var(--warning-color, #f97316);
            display: block;
        }
    </style>
</head>

<body class="bg-gray-100">
    <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">Clickjacking 防御</h4>
            <ul id="local-toc">
                <li><a href="#introduction" class="active"><span class="material-icons nav-icon">security</span>简介</a>
                </li>
                <li><a href="#what-is-clickjacking"><span class="material-icons nav-icon">ads_click</span>什么是点击劫持</a>
                </li>
                <li><a href="#how-it-works"><span class="material-icons nav-icon">visibility_off</span>攻击原理</a></li>
                <li><a href="#defense-overview"><span class="material-icons nav-icon">shield</span>防御机制概述</a></li>
                <li><a href="#x-frame-options"><span
                            class="material-icons nav-icon">web_asset_off</span>X-Frame-Options</a></li>
                <li><a href="#csp-frame-ancestors"><span class="material-icons nav-icon">policy</span>CSP
                        frame-ancestors</a></li>
                <li><a href="#implementation"><span class="material-icons nav-icon">code</span>实现示例</a></li>
                <li><a href="#summary"><span class="material-icons nav-icon">summarize</span>总结</a></li>
            </ul>
            <a href="../../index.html" class="back-link">
                &larr; 返回大纲目录
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="introduction" class="content-section fade-in-section" style="animation-delay: 0s;">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-icons text-3xl text-blue-600">security</span>Clickjacking (点击劫持) 与防御
                    </h1>
                    <p class="mb-4">点击劫持是一种常见的 Web 安全漏洞，攻击者通过诱骗用户点击不可见的元素来执行非预期的操作。理解其原理和防御方法对于前端和全栈开发者至关重要。</p>
                    <p class="mt-4 bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md text-sm">💡
                        <strong>提示:</strong> 本页将详细介绍点击劫持的概念、攻击方式以及主要的防御手段 <code>X-Frame-Options</code> 和
                        <code>Content-Security-Policy</code>。
                    </p>
                </section>

                <section id="what-is-clickjacking" class="content-section fade-in-section"
                    style="animation-delay: 0.05s;">
                    <h2 class="head2 flex items-center"><span class="material-icons">ads_click</span>什么是点击劫持
                        (Clickjacking)</h2>
                    <div class="content-card">
                        <h3 class="head3">概念定义</h3>
                        <p class="mb-4">点击劫持 (Clickjacking)，也称为“<strong class="text-red-600"><span class="tooltip-term"
                                    data-tooltip="User Interface Redress Attack，用户界面伪装攻击">UI
                                    伪装攻击</span></strong>”，是一种视觉欺骗技术。</p>
                        <p class="mb-4">攻击者创建一个恶意网站，并使用透明或半透明的 <code>&lt;iframe&gt;</code>
                            或类似元素覆盖在目标网站（受害者网站）之上。然后，攻击者设计诱导性的内容（如按钮、链接、游戏），让用户以为在与恶意网站交互，但实际上用户的点击事件被“劫持”，作用在了隐藏的目标网站页面上。
                        </p>
                        <p class="mt-2 mb-4">这可能导致用户在不知情的情况下执行敏感操作，例如：</p>
                        <ul>
                            <li>在社交媒体上点赞、分享或关注。</li>
                            <li>更改账户设置或密码。</li>
                            <li>进行购买或转账。</li>
                            <li>授权恶意应用访问权限。</li>
                        </ul>
                    </div>
                </section>

                <section id="how-it-works" class="content-section fade-in-section" style="animation-delay: 0.1s;">
                    <h2 class="head2 flex items-center"><span class="material-icons">visibility_off</span>攻击原理</h2>
                    <div class="content-card">
                        <h3 class="head3">利用 Iframe 进行覆盖</h3>
                        <p class="mb-4">核心在于利用 <code>&lt;iframe&gt;</code> 将目标网站嵌入到攻击者控制的页面中，并通过 CSS 设置
                            <code>iframe</code> 的样式，使其：</p>
                        <ul>
                            <li><strong>透明度 (Opacity):</strong> 设置为 0 或接近 0，使其完全不可见。</li>
                            <li><strong>定位 (Positioning):</strong> 使用绝对定位 (<code>position: absolute</code>) 和
                                <code>z-index</code> 将透明 <code>iframe</code> 精确地覆盖在攻击者页面上可见的诱导元素（如按钮）之上。</li>
                            <li><strong>尺寸和滚动 (Size & Scrolling):</strong> 可能调整 <code>iframe</code>
                                的大小和滚动位置，使得目标网站上的关键按钮（如“确认”、“购买”）正好位于用户将要点击的位置。</li>
                        </ul>
                        <div class="mermaid">
                            graph LR
                            subgraph "用户视角 (Attacker's Site)"
                            direction TB
                            A["看似无害的按钮<br>(例如 '领取奖励')"]
                            end
                            subgraph "实际结构 (HTML)"
                            direction TB
                            B["攻击者页面内容<br><button>领取奖励</button>"] -- Z轴覆盖 --> C["透明 Iframe<br><iframe src='目标网站页面'
                                style='opacity:0; position:absolute; ...'></iframe>"];
                            C -- 包含 --> D["目标网站的关键按钮<br>(例如 '确认转账')"];
                            end
                            A -- 用户点击 --> B;
                            B -- 点击穿透 --> D;

                            style A fill:#ccf,stroke:#333
                            style B fill:#eee,stroke:#333
                            style C fill:#f99,stroke:#f00,stroke-dasharray: 5 5
                            style D fill:#fcc,stroke:#f00
                        </div>
                        <p class="mt-4 mb-0">当用户点击“领取奖励”按钮时，他们的点击事件实际上落在了透明 <code>iframe</code>
                            中相同位置的“确认转账”按钮上，从而在用户不知情的情况下完成了转账操作。</p>
                    </div>
                </section>

                <section id="defense-overview" class="content-section fade-in-section" style="animation-delay: 0.15s;">
                    <h2 class="head2 flex items-center"><span class="material-icons">shield</span>防御机制概述</h2>
                    <div class="content-card">
                        <p class="mb-4">防御点击劫持的核心思想是：<strong>控制你的网页是否允许被其他网页通过 <code>&lt;iframe&gt;</code>
                                等方式嵌入</strong>。</p>
                        <p class="mb-4">主要的防御手段是通过设置 HTTP 响应头来实现：</p>
                        <ol class="mb-4">
                            <li><strong>X-Frame-Options:</strong> 较早的、广泛支持的响应头。</li>
                            <li><strong>Content-Security-Policy (CSP) 的 <code>frame-ancestors</code> 指令:</strong>
                                更现代、更灵活的替代方案，是 CSP 标准的一部分。</li>
                        </ol>
                        <p class="mb-4">推荐优先使用 CSP 的 <code>frame-ancestors</code> 指令，因为它提供了更精细的控制，并且是 W3C
                            的标准。但为了兼容性，可以同时设置 <code>X-Frame-Options</code>。</p>
                        <p class="text-sm text-gray-600 mb-0">此外，历史上也存在使用 JavaScript 进行防御的尝试（称为 <strong
                                class="text-gray-500">Frame Busting</strong>），例如检查
                            <code>top === self</code>，如果不在顶层窗口就尝试跳转。但这种方法容易被攻击者绕过，<strong
                                class="text-red-600">不应作为主要的防御手段</strong>。</p>
                    </div>
                </section>

                <section id="x-frame-options" class="content-section fade-in-section" style="animation-delay: 0.2s;">
                    <h2 class="head2 flex items-center"><span class="material-icons">web_asset_off</span>X-Frame-Options
                        响应头</h2>
                    <div class="content-card mb-6">
                        <h3 class="head3">作用与目的</h3>
                        <p class="mb-4"><code>X-Frame-Options</code> 是一个 HTTP 响应头，用于指示浏览器是否允许一个页面在
                            <code>&lt;frame&gt;</code>, <code>&lt;iframe&gt;</code>, <code>&lt;embed&gt;</code>, 或
                            <code>&lt;object&gt;</code> 中展示。</p>
                        <p class="mb-0">通过正确设置此响应头，网站可以有效防止自己的页面被恶意网站嵌入，从而防御点击劫持攻击。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">有效值</h3>
                        <ul>
                            <li>
                                <strong><code>DENY</code></strong>
                                <p class="text-sm text-gray-600 ml-4 mb-2">表示该页面不允许在任何 <code>frame</code>
                                    中展示，即使是在相同域名的页面中也不行。这是最严格的设置。</p>
                                <pre><code class="language-http">X-Frame-Options: DENY</code></pre>
                            </li>
                            <li class="mt-4">
                                <strong><code>SAMEORIGIN</code></strong>
                                <p class="text-sm text-gray-600 ml-4 mb-2">表示该页面可以在<strong class="text-red-600"><span
                                            class="tooltip-term" data-tooltip="协议、域名和端口都相同">同源</span></strong>域名下的
                                    <code>frame</code> 中展示。这是最常用和推荐的设置，允许自身网站内部的嵌入，但阻止外部网站嵌入。</p>
                                <pre><code class="language-http">X-Frame-Options: SAMEORIGIN</code></pre>
                            </li>
                            <li class="mt-4">
                                <strong><code>ALLOW-FROM uri</code></strong> (⚠️ <strong
                                    class="text-orange-600">已过时，不推荐使用</strong>)
                                <p class="text-sm text-gray-600 ml-4 mb-2">表示该页面只允许在指定的来源 (uri) 的 <code>frame</code>
                                    中展示。例如
                                    <code>ALLOW-FROM https://example.com/</code>。然而，这个指令的支持性并不好，尤其在现代浏览器中，且不能指定多个来源。<strong>应优先使用
                                        CSP 的 <code>frame-ancestors</code></strong>。</p>
                                <pre><code class="language-http">X-Frame-Options: ALLOW-FROM https://trusted.example.com/</code></pre>
                            </li>
                        </ul>
                    </div>
                    <div class="quiz-card mt-6" id="quiz-xfo">
                        <div class="quiz-question"><span class="material-icons mr-1">quiz</span>X-Frame-Options 测验：哪个
                            <code>X-Frame-Options</code> 值可以阻止页面被任何来源（包括同源）嵌入？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_xfo" value="a">
                                <span>SAMEORIGIN</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_xfo" value="b">
                                <span>DENY</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_xfo" value="c">
                                <span>ALLOW-FROM *</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_xfo" value="d">
                                <span>NONE</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_xfo"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_xfo', 'b')">
                            <span class="material-icons icon-arrow">expand_more</span><span
                                class="button-text">检查答案</span>
                        </button>
                        <div class="quiz-answer" style="display: none;">
                            <p><strong>答案:</strong> B. DENY</p>
                            <p><strong>解析:</strong> <code>DENY</code> 指令完全禁止页面在任何 frame
                                中显示，提供了最强的保护。<code>SAMEORIGIN</code> 只允许同源嵌入。<code>ALLOW-FROM</code>
                                已过时且不接受通配符。<code>NONE</code> 不是 <code>X-Frame-Options</code> 的有效值（它是 CSP
                                <code>frame-ancestors</code> 的值）。</p>
                        </div>
                    </div>
                </section>

                <section id="csp-frame-ancestors" class="content-section fade-in-section"
                    style="animation-delay: 0.25s;">
                    <h2 class="head2 flex items-center"><span class="material-icons">policy</span>CSP frame-ancestors 指令
                    </h2>
                    <div class="content-card mb-6">
                        <h3 class="head3">现代替代方案</h3>
                        <p class="mb-4">内容安全策略 (Content Security Policy, CSP) 是一套更全面的安全机制，通过 HTTP 响应头来声明浏览器允许加载的资源来源等策略。
                        </p>
                        <p class="mb-0">其中的 <code>frame-ancestors</code> 指令专门用于替代
                            <code>X-Frame-Options</code>，控制哪些来源可以嵌入当前页面。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">优势与语法</h3>
                        <ul class="mb-4">
                            <li><strong>更灵活：</strong>可以指定多个允许的来源（包括通配符、协议等）。</li>
                            <li><strong>标准化：</strong>是 W3C 的 CSP 标准的一部分，未来支持性更好。</li>
                        </ul>
                        <p class="mt-2 mb-4"><strong>常用值：</strong></p>
                        <ul>
                            <li>
                                <strong><code>'none'</code></strong>
                                <p class="text-sm text-gray-600 ml-4 mb-2">等同于
                                    <code>X-Frame-Options: DENY</code>。不允许任何来源嵌入。</p>
                                <pre><code class="language-http">Content-Security-Policy: frame-ancestors 'none';</code></pre>
                            </li>
                            <li class="mt-4">
                                <strong><code>'self'</code></strong>
                                <p class="text-sm text-gray-600 ml-4 mb-2">等同于
                                    <code>X-Frame-Options: SAMEORIGIN</code>。只允许同源嵌入。</p>
                                <pre><code class="language-http">Content-Security-Policy: frame-ancestors 'self';</code></pre>
                            </li>
                            <li class="mt-4">
                                <strong><code>&lt;source&gt;</code></strong>
                                <p class="text-sm text-gray-600 ml-4 mb-2">指定一个或多个允许的来源 (URL 或域名)，用空格分隔。可以使用通配符
                                    <code>*</code>。</p>
                                <pre><code class="language-http">Content-Security-Policy: frame-ancestors 'self' https://trusted.example.com https://*.partner.com;</code></pre>
                                <p class="text-xs text-gray-500 ml-4 mb-0">上述示例允许同源嵌入，以及来自
                                    <code>https://trusted.example.com</code> 和所有 <code>partner.com</code> 的 HTTPS
                                    子域名的嵌入。</p>
                            </li>
                        </ul>
                        <p
                            class="mt-4 bg-yellow-50 border-l-4 border-yellow-500 text-yellow-700 p-3 rounded-md text-sm mb-0">
                            ⚠️ <strong>注意:</strong> 如果同时设置了 <code>X-Frame-Options</code> 和 CSP
                            <code>frame-ancestors</code>，<code>frame-ancestors</code> 指令通常会覆盖
                            <code>X-Frame-Options</code> (具体行为可能因浏览器而异，但现代浏览器倾向于 CSP)。建议优先使用 CSP。</p>
                    </div>
                    <div class="quiz-card mt-6" id="quiz-csp">
                        <div class="quiz-question"><span class="material-icons mr-1">quiz</span>CSP 测验：哪个 CSP
                            <code>frame-ancestors</code> 设置允许页面被自身域名和 `https://partner.site` 嵌入？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_csp" value="a">
                                <span><code>frame-ancestors 'self';</code></span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_csp" value="b">
                                <span><code>frame-ancestors https://partner.site;</code></span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_csp" value="c">
                                <span><code>frame-ancestors 'self' https://partner.site;</code></span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_csp" value="d">
                                <span><code>frame-ancestors 'none';</code></span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_csp"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_csp', 'c')">
                            <span class="material-icons icon-arrow">expand_more</span><span
                                class="button-text">检查答案</span>
                        </button>
                        <div class="quiz-answer" style="display: none;">
                            <p><strong>答案:</strong> C. <code>frame-ancestors 'self' https://partner.site;</code></p>
                            <p><strong>解析:</strong> CSP <code>frame-ancestors</code>
                                指令允许指定多个来源，用空格分隔。<code>'self'</code> 关键字代表同源，后面可以跟其他允许的 URL
                                或域名。因此，<code>'self' https://partner.site;</code> 同时允许了同源和来自
                                <code>https://partner.site</code> 的嵌入。</p>
                        </div>
                    </div>
                </section>

                <section id="implementation" class="content-section fade-in-section" style="animation-delay: 0.3s;">
                    <h2 class="head2 flex items-center"><span class="material-icons">code</span>实现示例</h2>
                    <p class="mb-4">设置这些 HTTP 响应头通常在 Web 服务器或应用程序层面完成。</p>
                    <div class="content-card mb-6">
                        <h3 class="head3">Nginx 配置</h3>
                        <pre><code class="language-nginx"># 推荐使用 CSP frame-ancestors
add_header Content-Security-Policy "frame-ancestors 'self' https://trusted.example.com;" always;

# 或者使用 X-Frame-Options (如果需要兼容旧浏览器或作为备选)
# add_header X-Frame-Options "SAMEORIGIN" always;</code></pre>
                        <p class="text-xs text-gray-500 mt-1 mb-0"><code>always</code> 参数确保 Nginx 在所有响应码（包括错误页面）中都添加该头。
                        </p>
                    </div>
                    <div class="content-card mb-6">
                        <h3 class="head3">Apache 配置 (.htaccess 或 httpd.conf)</h3>
                        <pre><code class="language-apacheconf"># 推荐使用 CSP frame-ancestors
Header always set Content-Security-Policy "frame-ancestors 'self'"

# 或者使用 X-Frame-Options
# Header always set X-Frame-Options "SAMEORIGIN"</code></pre>
                        <p class="text-xs text-gray-500 mt-1 mb-0">需要确保 <code>mod_headers</code> 模块已启用。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">Node.js (Express 示例)</h3>
                        <p class="text-sm text-gray-600 mb-2">可以使用 <code>helmet</code> 中间件简化设置。</p>
                        <pre><code class="language-javascript">const express = require('express');
const helmet = require('helmet');

const app = express();

// 使用 helmet 设置 CSP frame-ancestors (推荐)
app.use(
  helmet.contentSecurityPolicy({
    directives: {
      ...helmet.contentSecurityPolicy.getDefaultDirectives(), // 保留其他默认指令
      "frame-ancestors": ["'self'", "https://trusted.example.com"], // 设置允许的来源
      // 或者不允许任何嵌入:
      // "frame-ancestors": ["'none'"],
    },
  })
);

// 或者单独设置 X-Frame-Options (如果不用 helmet 的 CSP)
// app.use(helmet.frameguard({ action: 'sameorigin' })); // 设置 X-Frame-Options: SAMEORIGIN
// app.use(helmet.frameguard({ action: 'deny' }));      // 设置 X-Frame-Options: DENY

// ... 其他路由和中间件 ...

app.listen(3000, () => console.log('Server running on port 3000'));</code></pre>
                    </div>
                </section>

                <section id="summary" class="content-section fade-in-section" style="animation-delay: 0.35s;">
                    <h2 class="head2 flex items-center"><span class="material-icons">summarize</span>总结</h2>
                    <div class="content-card">
                        <ul>
                            <li>点击劫持是一种 UI 伪装攻击，通过透明 <code>iframe</code> 覆盖目标网站，诱导用户点击。</li>
                            <li>防御核心是阻止恶意网站嵌入你的页面。</li>
                            <li>使用 HTTP 响应头 <code>X-Frame-Options</code> 或 CSP 的 <code>frame-ancestors</code> 指令进行控制。
                            </li>
                            <li><strong>推荐使用 <code>Content-Security-Policy: frame-ancestors 'self';</code> 或
                                    <code>'none';</code></strong> 作为现代、灵活且标准的防御方法。</li>
                            <li>根据需求，可以允许特定的可信来源嵌入。</li>
                            <li>确保在 Web 服务器或应用层正确配置这些响应头。</li>
                            <li>JavaScript Frame Busting 是一种过时且不可靠的辅助手段。</li>
                        </ul>
                    </div>
                </section>

            </article>
        </main>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Initialize Mermaid
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });

        // --- Ripple Effect Logic ---
        function createRipple(event) {
            const button = event.currentTarget;
            // Check if the target is a button or has the .button class
            if (!button || !(button.tagName === 'BUTTON' || button.classList.contains('button')) || typeof button.getBoundingClientRect !== 'function') return;

            const circle = document.createElement("span");
            const diameter = Math.max(button.clientWidth, button.clientHeight);
            const radius = diameter / 2;
            // Attempt to get primary color RGB from CSS variable, fallback to default blue
            const primaryColorRgb = getComputedStyle(document.documentElement).getPropertyValue('--primary-color-rgb').trim() || '59, 130, 246';

            circle.style.width = circle.style.height = `${diameter}px`;
            const rect = button.getBoundingClientRect();
            circle.style.left = `${event.clientX - rect.left - radius}px`;
            circle.style.top = `${event.clientY - rect.top - radius}px`;
            circle.style.backgroundColor = `rgba(${primaryColorRgb}, 0.4)`; // Use the determined RGB
            circle.classList.add("ripple");

            const existingRipple = button.querySelector(".ripple");
            if (existingRipple) existingRipple.remove();

            button.appendChild(circle);
            // Clean up ripple element after animation
            setTimeout(() => circle.remove(), 600);
        }

        // --- Quiz Toggle Logic ---
        function toggleAnswer(quizId, buttonElement) {
            const quizCard = document.getElementById(quizId);
            if (!quizCard) return;
            const answer = quizCard.querySelector('.quiz-answer');
            const icon = buttonElement.querySelector('.icon-arrow');
            const buttonTextSpan = buttonElement.querySelector('.button-text'); // Get the span containing the text
            if (!answer || !icon || !buttonTextSpan) return;

            const isVisible = answer.classList.contains('visible');

            if (isVisible) {
                // Start hiding transition
                answer.style.maxHeight = '0';
                answer.style.opacity = '0';
                answer.style.marginTop = '0';
                answer.style.paddingTop = '0';
                answer.style.paddingBottom = '0';
                answer.classList.remove('visible');
                icon.classList.remove('rotated');
                buttonTextSpan.textContent = ' 检查答案'; // Change text back

                // After transition, set display to none for accessibility and layout
                setTimeout(() => {
                    // Double check it's still hidden before setting display:none
                    if (!answer.classList.contains('visible')) {
                        answer.style.display = 'none';
                        // Clean up inline styles set during transition
                        answer.style.removeProperty('max-height');
                        answer.style.removeProperty('opacity');
                        answer.style.removeProperty('margin-top');
                        answer.style.removeProperty('padding-top');
                        answer.style.removeProperty('padding-bottom');
                    }
                }, 500); // Match transition duration
            } else {
                // Prepare to show
                answer.style.display = 'block'; // Make it visible to measure scrollHeight
                // Set styles for the expanded state *before* adding 'visible' class for transition
                answer.style.paddingTop = '1rem';
                answer.style.paddingBottom = '1rem';
                answer.style.marginTop = '1rem';

                // Force reflow to ensure display:block is applied before transition starts
                requestAnimationFrame(() => {
                    answer.style.maxHeight = answer.scrollHeight + 'px';
                    answer.style.opacity = '1';
                    answer.classList.add('visible');
                    icon.classList.add('rotated');
                    buttonTextSpan.textContent = ' 隐藏答案'; // Change text
                });
            }
        }

        // --- Quiz Check Answer Logic ---
        function checkAnswer(questionName, correctAnswerValue) {
            const options = document.querySelectorAll(`input[name="${questionName}"]`);
            const feedbackElement = document.getElementById(`feedback-${questionName}`);
            const quizCard = feedbackElement ? feedbackElement.closest('.quiz-card') : null;
            let selectedValue = null;
            let selectedLabel = null;

            if (!feedbackElement || !quizCard) {
                console.error("Quiz feedback element or card not found for", questionName);
                return;
            }

            // Clear previous feedback and styles
            feedbackElement.style.display = 'none';
            feedbackElement.textContent = '';
            feedbackElement.className = 'quiz-feedback'; // Reset class
            quizCard.querySelectorAll('.quiz-option').forEach(opt => opt.classList.remove('selected', 'correct', 'incorrect'));

            // Find selected option
            options.forEach(option => {
                if (option.checked) {
                    selectedValue = option.value;
                    selectedLabel = option.closest('.quiz-option');
                    if (selectedLabel) selectedLabel.classList.add('selected');
                }
            });

            // Check if an option was selected
            if (!selectedValue) {
                feedbackElement.textContent = "请选择一个选项！";
                feedbackElement.className = 'quiz-feedback warning'; // Use warning style
                feedbackElement.style.display = 'block';
                return; // Stop processing if no selection
            }

            // Find the correct answer label
            let correctAnswerLabel = null;
            options.forEach(opt => { if (opt.value === correctAnswerValue) correctAnswerLabel = opt.closest('.quiz-option'); });

            // Provide feedback
            if (selectedValue === correctAnswerValue) {
                feedbackElement.textContent = "回答正确！";
                feedbackElement.className = 'quiz-feedback correct';
                if (selectedLabel) selectedLabel.classList.add('correct');
            } else {
                let correctAnswerText = '';
                if (correctAnswerLabel) {
                    correctAnswerText = correctAnswerLabel.querySelector('span')?.textContent || `选项 ${correctAnswerValue}`;
                    correctAnswerLabel.classList.add('correct'); // Highlight the correct one
                }
                feedbackElement.textContent = `回答错误。正确答案是: "${correctAnswerText}"`;
                feedbackElement.className = 'quiz-feedback incorrect';
                if (selectedLabel) selectedLabel.classList.add('incorrect'); // Mark the wrong selection
            }
            feedbackElement.style.display = 'block'; // Show the feedback

            // --- Automatically toggle the answer section visibility ---
            const toggleButton = quizCard.querySelector('.quiz-toggle'); // Find the toggle button for this quiz
            const answerSection = quizCard.querySelector('.quiz-answer');

            if (toggleButton && answerSection && !answerSection.classList.contains('visible')) {
                // If answer is hidden, show it
                toggleAnswer(quizCard.id, toggleButton);
            }
            // Optional: If you want to hide the answer again if the user clicks check while it's visible, add an else condition here.
            // else if (toggleButton && answerSection && answerSection.classList.contains('visible')) {
            //      // If answer is visible, maybe hide it? Or do nothing.
            //      // toggleAnswer(quizCard.id, toggleButton);
            // }
        }


        document.addEventListener('DOMContentLoaded', () => {
            // --- TOC Highlighting Logic ---
            const sections = document.querySelectorAll('main section[id]');
            const tocLinks = document.querySelectorAll('#local-toc a');
            let lastActiveTocLink = null;

            const tocObserverOptions = {
                root: null,
                rootMargin: '-20% 0px -60% 0px',
                threshold: 0
            };

            const tocObserverCallback = (entries) => {
                let bestVisibleEntry = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (!bestVisibleEntry || entry.boundingClientRect.top < bestVisibleEntry.boundingClientRect.top) {
                            bestVisibleEntry = entry;
                        }
                    }
                });

                if (bestVisibleEntry) {
                    const id = bestVisibleEntry.target.getAttribute('id');
                    const activeLink = document.querySelector(`#local-toc a[href="#${id}"]`);

                    if (activeLink && activeLink !== lastActiveTocLink) {
                        if (lastActiveTocLink) {
                            lastActiveTocLink.classList.remove('active');
                        }
                        activeLink.classList.add('active');
                        lastActiveTocLink = activeLink;
                    }
                }
            };

            const tocObserver = new IntersectionObserver(tocObserverCallback, tocObserverOptions);
            sections.forEach(section => tocObserver.observe(section));

            // Initial active link check
            const currentHash = window.location.hash;
            if (currentHash) {
                const initialActiveLink = document.querySelector(`#local-toc a[href="${currentHash}"]`);
                if (initialActiveLink) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    initialActiveLink.classList.add('active');
                    lastActiveTocLink = initialActiveLink;
                }
            } else if (tocLinks.length > 0 && !lastActiveTocLink) {
                tocLinks.forEach(link => link.classList.remove('active'));
                tocLinks[0].classList.add('active');
                lastActiveTocLink = tocLinks[0];
            }

            // --- Fade-in Animation Logic ---
            const mainContentSections = document.querySelectorAll('main > article > section.content-section');
            const fadeObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
            const fadeObserverCallback = (entries, observer) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const delayIndex = Array.from(mainContentSections).indexOf(entry.target);
                        entry.target.style.animationDelay = `${delayIndex * 0.05}s`;
                        entry.target.classList.add('fade-in-section');
                        observer.unobserve(entry.target);
                    }
                });
            };
            const fadeObserver = new IntersectionObserver(fadeObserverCallback, fadeObserverOptions);
            mainContentSections.forEach(section => fadeObserver.observe(section));

            // --- Attach Ripple Effect to Buttons ---
            // Apply to elements with class 'button' or 'quiz-toggle' which acts like a button
            document.querySelectorAll('.button, .quiz-toggle').forEach(button => {
                button.addEventListener('click', createRipple);
            });

            // --- Initialize Quiz Answer Sections (Hide them initially) ---
            document.querySelectorAll('.quiz-answer').forEach(answer => {
                answer.style.display = 'none'; // Ensure they are hidden on load
            });

        });
    </script>
</body>

</html>