<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>浏览器缓存机制</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="../../global.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        /* --- Material Symbols Base Style (Ensure consistency) --- */
        .material-symbols-outlined {
            font-variation-settings:
                'FILL' 0,
                'wght' 400,
                'GRAD' 0,
                'opsz' 24;
            vertical-align: middle;
            font-size: 1.25em;
            line-height: 1;
        }

        /* Adjust icon size within specific contexts */
        .local-side-nav .material-symbols-outlined,
        .content-section h2 .material-symbols-outlined {
            font-size: 1.3em;
        }

        /* --- Typography & Spacing (Use global.css classes like .head1, .head2 etc.) --- */
        .content-main p,
        .content-main ul,
        .content-main ol {
            margin-bottom: 1.25rem; /* Consistent paragraph/list spacing */
            line-height: 1.7; /* Improve readability */
        }

        /* Ensure code blocks use the mono font from global.css */
        .content-main pre {
            font-family: var(--font-family-mono);
            margin: 1.5rem 0; /* Add vertical spacing */
            position: relative; /* Needed for copy button positioning */
        }

        /* Inline code styling from global.css */
        .content-main *:not(pre)>code {
            background-color: var(--primary-color-light);
            color: var(--primary-color-dark);
            padding: 0.1rem 0.4rem;
            border-radius: 0.25rem;
            font-family: var(--font-family-mono);
            font-size: 0.875em;
        }

        /* --- Frequency/Level Tags --- */
        .level-tag {
            display: inline-block;
            margin-left: 0.5rem;
            font-size: 0.75rem;
            font-weight: 500;
            padding: 0.1rem 0.5rem;
            border-radius: 0.25rem;
            vertical-align: middle;
            border: 1px solid transparent;
        }

        .level-tag-high {
            background-color: var(--danger-color-light);
            color: var(--danger-color);
            border-color: var(--danger-color);
        }

        .level-tag-medium {
            background-color: var(--warning-color-light);
            color: var(--warning-color);
            border-color: var(--warning-color);
        }

        /* --- Tooltip Term --- */
        .tooltip-term {
            border-bottom: 1px dotted var(--primary-color);
            cursor: help;
            position: relative;
            color: var(--primary-color-dark);
            font-weight: 500;
        }
        .tooltip-term::before { /* Tooltip content */
            content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-8px);
            background-color: rgba(0, 0, 0, 0.85); color: white; padding: 0.4rem 0.75rem; border-radius: 4px; font-size: 0.8rem;
            white-space: nowrap; opacity: 0; visibility: hidden; transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out; z-index: 10;
        }
        .tooltip-term::after { /* Tooltip arrow */
            content: ''; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(0px);
            border-width: 5px; border-style: solid; border-color: rgba(0, 0, 0, 0.85) transparent transparent transparent;
            opacity: 0; visibility: hidden; transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out; z-index: 10;
        }
        .tooltip-term:hover::before, .tooltip-term:hover::after { opacity: 1; visibility: visible; }

        /* --- Mermaid Diagram Container --- */
        .mermaid-diagram-container {
            border-radius: 8px; border: 1px solid var(--border-color-default); background-color: var(--bg-color-white);
            padding: 1.5rem; margin: 1.5rem 0; display: flex; justify-content: center; align-items: center; overflow-x: auto;
        }
        .mermaid { text-align: center; }
        .mermaid svg { max-width: 100%; height: auto; }

        /* --- Interactive Simulation Styles --- */
        .status-indicator {
            transition: all 0.3s ease; padding: 2px 8px; border-radius: 9999px; font-size: 0.8rem; font-weight: 500;
            display: inline-flex; align-items: center; gap: 4px; border: 1px solid transparent; /* Add base border */
        }
        .status-server { background-color: #fef2f2; color: #dc2626; border-color: #fecaca; } /* Red */
        .status-cache-strong { background-color: #ecfdf5; color: #059669; border-color: #a7f3d0; } /* Green */
        .status-cache-memory { background-color: #eff6ff; color: #2563eb; border-color: #bfdbfe; } /* Blue */
        .status-cache-disk { background-color: #f0fdfa; color: #0d9488; border-color: #99f6e4; } /* Teal */
        .status-checking { background-color: #fffbeb; color: #d97706; border-color: #fde68a; } /* Amber */
        .status-304 { background-color: #f5f5f4; color: #57534e; border-color: #e7e5e4; } /* Stone */
        .status-private { background-color: #fdf4ff; color: #a855f7; border-color: #f5d0fe; } /* Fuchsia */
        .status-no-store { background-color: #f1f5f9; color: #475569; border-color: #e2e8f0; } /* Slate */
        .status-update { background-color: #ecfdf5; color: #059669; border-color: #a7f3d0; } /* Green for update */

        /* --- Code Block Copy Button --- */
        .copy-button {
            position: absolute; top: 8px; right: 8px; background-color: #4a5568; color: white; border: none;
            padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 0.8em; opacity: 0; /* Initially hidden */
            transition: opacity 0.2s ease; z-index: 1; /* Ensure button is clickable */
        }
        pre:hover .copy-button { opacity: 0.7; } /* Show on hover */
        .copy-button:hover { opacity: 1; }
        .copy-button:active { background-color: #2d3748; }
        .copy-button .tooltip {
            position: absolute; bottom: 100%; right: 0; margin-bottom: 5px; background-color: #2d3748; color: white;
            padding: 4px 8px; border-radius: 4px; font-size: 0.8em; white-space: nowrap; opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease; pointer-events: none; /* Prevent tooltip from blocking hover */
        }
        .copy-button:hover .tooltip { opacity: 1; visibility: visible; }

        /* --- Interview Points Table --- */
        .interview-table { /* Use Tailwind classes or define custom styles */
            /* Example: Apply Tailwind classes directly in HTML */
        }

        /* --- Fade-in Animation --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in { animation: fadeIn 0.5s ease-out forwards; opacity: 0; }
        .fade-in-delay-1 { animation-delay: 0.1s; }
        .fade-in-delay-2 { animation-delay: 0.2s; }
        .fade-in-delay-3 { animation-delay: 0.3s; }
        .fade-in-delay-4 { animation-delay: 0.4s; }
        .fade-in-delay-5 { animation-delay: 0.5s; }
        .fade-in-delay-6 { animation-delay: 0.6s; }
        .fade-in-delay-7 { animation-delay: 0.7s; }

    </style>
</head>

<body class="bg-gray-100">
    <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">浏览器缓存</h4>
            <ul id="local-toc">
                <li><a href="#intro" class="sidebar-link active"><span class="material-symbols-outlined">info</span><span>简介</span></a></li>
                <li><a href="#basics" class="sidebar-link"><span class="material-symbols-outlined">lightbulb</span><span>基础知识</span></a></li>
                <li><a href="#strong-cache" class="sidebar-link"><span class="material-symbols-outlined">shield_lock</span><span>强缓存</span></a></li>
                <li><a href="#negotiation-cache" class="sidebar-link"><span class="material-symbols-outlined">checklist</span><span>协商缓存</span></a></li>
                <li><a href="#lookup-process" class="sidebar-link"><span class="material-symbols-outlined">manage_search</span><span>缓存查找过程</span></a></li>
                <li><a href="#scenarios" class="sidebar-link"><span class="material-symbols-outlined">play_circle</span><span>交互场景模拟</span></a></li>
                <li><a href="#invalidation" class="sidebar-link"><span class="material-symbols-outlined">delete_sweep</span><span>缓存失效策略</span></a></li>
                <li><a href="#devtools" class="sidebar-link"><span class="material-symbols-outlined">build_circle</span><span>DevTools观察</span></a></li>
                <li><a href="#summary" class="sidebar-link"><span class="material-symbols-outlined">summarize</span><span>面试总结</span></a></li>
            </ul>
            <a href="../../index.html" class="back-link">
                &larr; 返回大纲目录
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="intro" class="content-section fade-in">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-symbols-outlined text-3xl text-blue-600">history</span> 浏览器缓存机制
                    </h1>
                    <p class="section-intro">
                        浏览器缓存是优化网页性能的关键技术。它通过在本地存储已访问资源的副本，减少了后续访问时的网络请求和加载时间。本节将详细介绍强缓存和协商缓存的概念、缓存查找流程，并通过交互式模拟加深理解。
                    </p>
                </section>

                <section id="basics" class="content-section fade-in fade-in-delay-1">
                    <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">lightbulb</span>缓存基础知识
                    </h2>
                    <div class="content-card space-y-6">
                        <div>
                            <h3 class="head3"><i class="fas fa-question-circle mr-1 text-cyan-500"></i> 什么是浏览器缓存？</h3>
                            <p class="text-sm text-gray-700">浏览器缓存（Browser Caching）是指浏览器将用户请求过的网络资源（如 HTML 页面、CSS 样式表、JavaScript 脚本、图片等）存储在本地磁盘或内存中。当用户再次访问同一页面或请求相同资源时，浏览器可以直接从本地加载，而无需重新向服务器发送请求。</p>
                        </div>

                        <div>
                            <h3 class="head3"><i class="fas fa-tachometer-alt mr-1 text-cyan-500"></i> 为什么需要缓存？（主要优点）</h3>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                                <li><strong>加快页面加载速度：</strong> 从本地读取资源远比通过网络下载快得多，显著提升用户体验。</li>
                                <li><strong>减少网络带宽消耗：</strong> 避免重复下载相同资源，节省用户的流量，也降低了网站运营成本。</li>
                                <li><strong>降低服务器负载：</strong> 大量请求被本地缓存处理，减轻了源服务器的压力。</li>
                            </ul>
                        </div>

                        <div>
                            <h3 class="head3"><i class="fas fa-cogs mr-1 text-cyan-500"></i> 缓存是如何工作的？</h3>
                            <p class="text-sm text-gray-700 mb-2">核心在于 HTTP 协议。服务器在响应请求时，可以通过特定的 HTTP 头部信息（如 <code>Cache-Control</code>, <code>Expires</code>, <code>ETag</code>, <code>Last-Modified</code>）来告诉浏览器如何缓存这个资源。</p>
                            <p class="text-sm text-gray-700">浏览器在后续请求相同资源时，会根据这些缓存指令来决定：</p>
                            <ol class="list-decimal list-inside space-y-1 text-sm text-gray-700 mt-2 ml-4">
                                <li><strong>直接使用本地缓存</strong>（如果缓存有效且未过期 - <a href="#strong-cache" class="text-blue-600 hover:underline font-medium">强缓存</a>）。</li>
                                <li><strong>向服务器询问资源是否有更新</strong>（如果缓存已过期或需要验证 - <a href="#negotiation-cache" class="text-blue-600 hover:underline font-medium">协商缓存</a>）。</li>
                                <li><strong>完全不使用缓存，直接请求服务器</strong>（如果被禁止缓存，如 <code>Cache-Control: no-store</code>）。</li>
                            </ol>
                        </div>
                        <p class="mt-3 text-sm text-gray-600"><i class="fas fa-lightbulb text-yellow-500 mr-1"></i><strong>核心思想：</strong>通过 HTTP 头部精确控制资源的存储、有效期和验证方式，实现性能与数据新鲜度的平衡。</p>
                    </div>
                </section>


                <section id="strong-cache" class="content-section fade-in fade-in-delay-2">
                    <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">shield_lock</span>强缓存 (Strong Cache)
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">基本概念</h3>
                        <p>
                            强缓存策略指示浏览器直接使用本地缓存副本，而<strong>无需</strong>向服务器发送任何请求来验证资源是否过期。这是最快的缓存方式。
                        </p>
                        <p>
                            浏览器通过检查资源的 HTTP 响应头中的特定字段来判断强缓存是否有效。主要涉及两个头部：<code>Expires</code> 和 <code>Cache-Control</code>。
                        </p>

                        <h4 class="head4 mt-6">1. <code>Expires</code> (HTTP/1.0)</h4>
                        <ul>
                            <li><strong>作用:</strong> 指定一个绝对的过期时间（GMT 格式）。在此时间之前，缓存被视为有效。</li>
                            <li><strong>示例:</strong>
                                <pre><code class="language-http">Expires: Wed, 21 Oct 2026 07:28:00 GMT</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                            </li>
                            <li><strong>缺点:</strong> 依赖于客户端本地时间，如果本地时间不准确，可能导致缓存提前或延迟失效。</li>
                        </ul>

                        <h4 class="head4 mt-6">2. <code>Cache-Control</code> (HTTP/1.1)</h4>
                        <ul>
                            <li><strong>作用:</strong> 提供了更灵活、更强大的缓存控制，优先级高于 <code>Expires</code>。</li>
                            <li><strong>常用指令:</strong>
                                <ul class="list-disc pl-5 mt-2 space-y-2">
                                    <li><code>max-age=&lt;seconds&gt;</code>: 指定资源缓存的最大有效时间（相对时间，单位秒），从响应生成时开始计算。<strong>最常用</strong>。
                                        <pre><code class="language-http">Cache-Control: max-age=31536000</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre> </li>
                                    <li><code>s-maxage=&lt;seconds&gt;</code>: 类似于 <code>max-age</code>，但仅用于共享缓存（如 CDN），优先级高于 <code>max-age</code>。</li>
                                    <li><code>public</code>: 表明响应可以被任何中间缓存（如 CDN、代理服务器）缓存。</li>
                                    <li><code>private</code>: 表明响应只能被最终用户的浏览器缓存，不允许中间缓存。默认值通常是 <code>private</code>。</li>
                                    <li><code>no-cache</code>: <strong class="text-red-600">强制进行协商缓存</strong>。浏览器在使用缓存副本前，必须先向服务器发送请求确认资源是否仍然有效。它<strong>不是</strong>完全不缓存。
                                        <pre><code class="language-http">Cache-Control: no-cache</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                                    </li>
                                    <li><code>no-store</code>: <strong class="text-red-600">完全禁止缓存</strong>。浏览器和任何中间缓存都不得存储这个响应的任何部分。每次请求都必须从服务器获取全新资源。
                                         <pre><code class="language-http">Cache-Control: no-store</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                                    </li>
                                    <li><code>must-revalidate</code>: 缓存一旦过期（例如 <code>max-age</code> 到期），在后续使用前必须向源服务器验证，不能直接使用陈旧副本（即使网络连接有问题）。</li>
                                     <li><code>immutable</code>: (可选) 表示资源内容永远不会改变。即使刷新页面(F5)，浏览器也倾向于不重新验证，直接使用强缓存（如果未过期）。适用于带内容哈希的资源。
                                         <pre><code class="language-http">Cache-Control: public, max-age=31536000, immutable</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                                    </li>
                                </ul>
                            </li>
                            <li><strong>组合使用:</strong> 可以组合多个指令，用逗号分隔。
                                 <pre><code class="language-http">Cache-Control: public, max-age=86400, must-revalidate</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                            </li>
                        </ul>
                        <p class="mt-4">
                            当 <code>Cache-Control</code> 和 <code>Expires</code> 同时存在时，<code>Cache-Control</code> 的优先级更高。现代 Web 开发中推荐使用 <code>Cache-Control</code>。
                        </p>
                    </div>
                </section>

                <section id="negotiation-cache" class="content-section fade-in fade-in-delay-3">
                    <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">checklist</span>协商缓存 (Negotiation Cache)
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">基本概念</h3>
                        <p>
                            当强缓存失效（例如 <code>max-age</code> 过期或设置为 <code>no-cache</code>）时，浏览器并不会立即下载新资源，而是会启动协商缓存机制。
                        </p>
                        <p>
                            浏览器向服务器发送一个“询问”请求，携带上次缓存资源时服务器提供的一些标识信息。服务器根据这些信息判断浏览器本地的缓存副本是否仍然是最新的。
                        </p>
                        <ul class="list-disc pl-5 space-y-1">
                            <li>如果资源<strong>未改变</strong>，服务器返回 <code>304 Not Modified</code> 状态码（响应体为空），告诉浏览器可以直接使用本地缓存。</li>
                            <li>如果资源<strong>已改变</strong>，服务器返回 <code>200 OK</code> 状态码，并在响应体中包含新的资源内容，同时更新缓存相关的 HTTP 头部。</li>
                        </ul>
                        <p class="mt-4">协商缓存依赖于两组 HTTP 头部字段（请求头和对应的响应头）：</p>

                        <h4 class="head4 mt-6">1. <code>Last-Modified</code> / <code>If-Modified-Since</code></h4>
                        <ul>
                            <li><strong>服务器响应头:</strong> <code>Last-Modified</code> 告诉浏览器资源的最后修改时间。
                                <pre><code class="language-http">Last-Modified: Tue, 15 Nov 2024 12:45:26 GMT</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                            </li>
                            <li><strong>浏览器请求头:</strong> 当强缓存失效后，浏览器在后续请求的 <code>If-Modified-Since</code> 字段中带上之前收到的 <code>Last-Modified</code> 值。
                                <pre><code class="language-http">If-Modified-Since: Tue, 15 Nov 2024 12:45:26 GMT</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                            </li>
                            <li><strong>服务器验证:</strong> 比较请求中的时间与资源的实际最后修改时间。</li>
                            <li><strong>缺点:</strong> 时间精度只能到秒；文件内容没变但修改时间变了（如保存操作）也会导致缓存失效；某些服务器可能无法准确获取时间。</li>
                        </ul>

                        <h4 class="head4 mt-6">2. <code>ETag</code> / <code>If-None-Match</code></h4>
                        <ul>
                            <li><strong>服务器响应头:</strong> <code>ETag</code> (Entity Tag) 是服务器为资源生成的唯一标识符（类似指纹），通常基于文件内容、版本号等。资源改变，<code>ETag</code> 改变。
                                <pre><code class="language-http">ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre> <pre><code class="language-http">ETag: W/"0815"</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre> </li>
                            <li><strong>浏览器请求头:</strong> 当强缓存失效后，浏览器在后续请求的 <code>If-None-Match</code> 字段中带上之前收到的 <code>ETag</code> 值。
                                <pre><code class="language-http">If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"</code><button class="copy-button" aria-label="复制"><i class="far fa-copy"></i><span class="tooltip">复制</span></button></pre>
                            </li>
                            <li><strong>服务器验证:</strong> 比较请求中的 <code>ETag</code> 与当前资源的 <code>ETag</code>。</li>
                            <li><strong>优点:</strong> 比 <code>Last-Modified</code> 更精确，解决了其缺点，能检测到秒级内的文件变动。</li>
                        </ul>
                         <p class="mt-4">
                            <code>ETag</code> 的优先级通常高于 <code>Last-Modified</code>。如果响应头同时包含两者，浏览器会同时发送 <code>If-None-Match</code> 和 <code>If-Modified-Since</code>。服务器需要同时满足这两个条件（或根据其内部逻辑优先判断 ETag）才会返回 <code>304</code>。
                        </p>
                    </div>
                </section>

                <section id="lookup-process" class="content-section fade-in fade-in-delay-4">
                    <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">manage_search</span>浏览器缓存查找过程
                        <span class="level-tag level-tag-medium">中频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">查找流程详解</h3>
                        <p>当浏览器需要请求一个资源时，它会按照以下顺序查找缓存：</p>
                         <div class="mermaid-diagram-container">
                            <pre class="mermaid">
graph TD
    A["请求资源"] --> B{"内存缓存 (Memory Cache)?"};
    B -- "✅ 命中" --> C["直接使用 (200 from memory cache)"];
    B -- "❌ 未命中" --> D{"硬盘缓存 (Disk Cache)?"};
    D --> E{"检查强缓存 (Cache-Control/Expires)"};
    E -- "✅ 有效" --> F["直接使用 (200 from disk cache)"];
    E -- "❌ 无效/不存在" --> G{"发起协商缓存请求"};
    G --> H["带 If-None-Match / If-Modified-Since"];
    H --> I["服务器"];
    I --> J{"资源未修改?"};
    J -- "✅ 是" --> K["服务器返回 304 Not Modified"];
    K --> L["浏览器使用硬盘缓存"];
    J -- "❌ 否" --> M["服务器返回 200 OK + 新资源"];
    M --> N["浏览器使用新资源 & 更新缓存"];
    D -- "❌ 不存在" --> O["发起网络请求"];
    O --> I;

    style C fill:#dcfce7,stroke:#15803d,stroke-width:1px,color:#15803d
    style F fill:#e0f2fe,stroke:#0284c7,stroke-width:1px,color:#0284c7
    style L fill:#e0f2fe,stroke:#0284c7,stroke-width:1px,color:#0284c7
    style N fill:#f3e8ff,stroke:#7e22ce,stroke-width:1px,color:#7e22ce
                            </pre>
                             <div class="mermaid-fallback text-xs text-gray-500 mt-2">
                                [缓存查找流程图：请求 -> 内存缓存? (是->使用) -> 硬盘缓存? (否->网络请求) -> 强缓存有效? (是->使用) -> 协商缓存请求 -> 服务器验证 -> (未修改->304->用缓存) / (已修改->200->用新资源)]
                            </div>
                        </div>
                        <ol class="list-decimal pl-5 mt-6 space-y-2">
                            <li><strong>查找内存缓存 (Memory Cache):</strong> 浏览器首先检查内存中是否有该资源的副本。内存缓存是短暂的（通常页面关闭后清空），但速度最快。如果找到且未过期（也受强缓存策略影响），直接使用。</li>
                            <li><strong>查找硬盘缓存 (Disk Cache):</strong> 如果内存缓存未命中，浏览器接着检查硬盘缓存。
                                <ul class="list-disc pl-5 mt-2 space-y-1">
                                    <li><strong>检查强缓存:</strong> 查看资源对应的 <code>Cache-Control</code> 和 <code>Expires</code> 头部信息。如果强缓存有效（未过期），直接从硬盘读取资源，不发送 HTTP 请求。状态码通常显示为 <code>200 OK (from disk cache)</code>。</li>
                                    <li><strong>检查协商缓存条件:</strong> 如果强缓存无效（已过期或设置为 <code>no-cache</code> 等），浏览器准备发起 HTTP 请求。</li>
                                </ul>
                            </li>
                            <li><strong>发起协商缓存请求:</strong> 请求头中会带上 <code>If-Modified-Since</code> 和/或 <code>If-None-Match</code> 的值（如果之前存在）。</li>
                            <li><strong>服务器验证:</strong> 服务器收到请求后，进行比较。
                                <ul class="list-disc pl-5 mt-2 space-y-1">
                                    <li><strong>命中协商缓存:</strong> 如果资源未改变，服务器返回 <code>304 Not Modified</code>。浏览器收到 <code>304</code> 后，从硬盘缓存中加载资源。</li>
                                    <li><strong>未命中协商缓存:</strong> 如果资源已改变，服务器返回 <code>200 OK</code> 和新的资源内容及更新后的缓存头部。浏览器使用新资源并更新本地缓存。</li>
                                </ul>
                            </li>
                             <li><strong>发起网络请求:</strong> 如果硬盘缓存中也不存在该资源（例如首次请求或缓存被清除），浏览器将发起完整的 HTTP 请求到服务器获取资源。</li>
                        </ol>

                        <h4 class="head4 mt-6">用户操作对缓存的影响</h4>
                        <ul class="list-disc pl-5 mt-2 space-y-1">
                            <li><strong>地址栏回车 / 链接跳转 / 前进后退:</strong> 优先检查内存缓存，然后硬盘缓存（强缓存 -> 协商缓存）。</li>
                            <li><strong>F5 刷新:</strong> 通常会跳过强缓存（请求头可能带 <code>Cache-Control: max-age=0</code>），直接发起协商缓存请求。</li>
                            <li><strong>Ctrl+F5 强制刷新:</strong> 跳过所有缓存（内存和硬盘，强缓存和协商缓存），直接向服务器请求全新资源（不带 <code>If-Modified-Since</code> / <code>If-None-Match</code>）。</li>
                        </ul>
                    </div>
                </section>

                <section id="scenarios" class="content-section fade-in fade-in-delay-5">
                    <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">play_circle</span>交互场景模拟
                    </h2>
                    <div class="content-card space-y-8">
                        <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                            <h3 class="font-semibold mb-2 text-gray-700">场景一：静态资源 (强缓存)</h3>
                            <p class="text-sm mb-3 text-gray-600">模拟加载设置了长强缓存 (max-age=31536000, immutable) 的 CSS 文件。</p>
                            <div class="flex items-center space-x-4 mb-3">
                                <button id="load-static-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-medium py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow text-sm">
                                    <i class="fas fa-download mr-1"></i> 加载 style.v1.css
                                </button>
                                <div id="static-status" class="text-sm font-medium">状态: 未加载</div>
                            </div>
                            <p class="text-xs text-gray-500 mb-3">重复点击按钮。首次点击模拟从服务器下载，之后会命中强缓存 (即使 F5 刷新也可能命中，因为设置了 immutable)。</p>

                            <h4 class="font-semibold text-sm mb-2 mt-4 text-gray-700">缓存失效：文件名哈希</h4>
                            <p class="text-sm mb-3 text-gray-600">点击发布新版，文件名改变，之前的强缓存失效。</p>
                            <div class="flex items-center space-x-4">
                                <button id="update-static-btn" class="bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow text-sm">
                                    <i class="fas fa-sync-alt mr-1"></i> 发布新版 (style.v2.css)
                                </button>
                                <div id="static-update-status" class="text-sm font-medium"></div>
                            </div>
                            <p class="text-xs text-gray-500 mt-2">点击“发布新版”后，再点击“加载”按钮，会模拟加载新文件。</p>
                        </div>

                        <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                            <h3 class="font-semibold mb-2 text-gray-700">场景二：动态 API (短强缓存 + 协商缓存)</h3>
                            <p class="text-sm mb-3 text-gray-600">模拟加载 <code>/api/news</code>。假设强缓存时间为 5 秒。</p>
                            <div class="flex items-center space-x-4 mb-3">
                                <button id="load-news-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-medium py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow text-sm">
                                    <i class="fas fa-sync mr-1"></i> 获取新闻
                                </button>
                                <div id="news-status" class="text-sm font-medium">状态: 未加载</div>
                            </div>
                            <p class="text-xs text-gray-500 mb-3">首次点击从服务器加载。5 秒内再次点击，命中强缓存。5 秒后再次点击，模拟协商缓存 (随机返回 304 或 200)。</p>
                            <div id="news-timer" class="text-xs text-gray-500 h-4"></div> <div id="news-data" class="mt-2 p-3 bg-white border border-gray-300 rounded text-xs text-gray-700 hidden max-h-32 overflow-y-auto"></div>
                        </div>

                        <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                            <h3 class="font-semibold mb-2 text-gray-700">场景三：个性化内容 (私有/不缓存)</h3>
                            <p class="text-sm mb-3 text-gray-600">模拟加载用户的购物车数据 <code>/api/cart</code>。</p>
                            <div class="flex items-center space-x-4 mb-3">
                                <button id="load-cart-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded-lg transition duration-150 ease-in-out shadow text-sm">
                                    <i class="fas fa-shopping-cart mr-1"></i> 查看购物车
                                </button>
                                <label class="inline-flex items-center cursor-pointer">
                                    <input type="checkbox" id="force-no-store" class="sr-only peer">
                                    <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-purple-300 rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                                    <span class="ms-3 text-sm font-medium text-gray-700">模拟 <code>no-store</code></span>
                                </label>
                            </div>
                            <div id="cart-status" class="text-sm font-medium mb-2">状态: 未加载</div>
                            <p class="text-xs text-gray-500 mb-3">默认模拟 <code>no-cache</code> (每次验证)。勾选 <code>no-store</code> 则模拟每次都强制从服务器获取。</p>
                            <div id="cart-data" class="mt-2 p-3 bg-white border border-gray-300 rounded text-xs text-gray-700 hidden max-h-32 overflow-y-auto"></div>
                        </div>
                    </div>
                </section>

                 <section id="invalidation" class="content-section fade-in fade-in-delay-6">
                    <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">delete_sweep</span>缓存失效策略
                    </h2>
                    <div class="content-card">
                        <p class="mb-4 text-gray-600">当服务器上的资源更新后，如何确保用户能及时获取到最新版本，而不是继续使用旧的缓存？这需要合理的缓存失效策略。</p>

                        <h3 class="head3">1. URL 版本控制 / 内容哈希 (Cache Busting) - 推荐 👍</h3>
                        <p class="text-sm mb-2 text-gray-600">这是最常用且推荐的方法。通过在文件名中加入版本号或文件内容的哈希值，确保每次资源更新时 URL 都发生变化。</p>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li>旧版本: <code>/static/js/app.<span class="font-mono bg-gray-200 px-1 rounded">abc123</span>.js</code></li>
                            <li>新版本: <code>/static/js/app.<span class="font-mono bg-green-100 px-1 rounded">def456</span>.js</code></li>
                        </ul>
                        <p class="text-sm mt-2 text-gray-600">浏览器会将新 URL 视为一个全新的资源，从而主动去服务器请求。配合长 <code>max-age</code> 的强缓存，可以做到高效缓存和即时更新的平衡。⭐️⭐️⭐️⭐️</p>
                         <div class="mt-4 p-4 border border-gray-200 rounded-lg bg-gray-50">
                             <h4 class="font-semibold text-sm mb-2 text-gray-700">可视化：文件名哈希的效果</h4>
                             <div class="flex flex-col items-center space-y-4 md:flex-row md:space-y-0 md:space-x-8">
                                 <div class="text-center p-4 border rounded-lg bg-white w-full md:w-1/2">
                                     <p class="font-medium mb-2">旧版本引用</p>
                                     <code class="text-sm bg-gray-100 p-1 rounded">&lt;script src="/app.<span class="text-red-600 font-mono">abc123</span>.js"&gt;&lt;/script&gt;</code>
                                     <p class="mt-2 text-xs text-gray-500">浏览器缓存了 <code class="text-xs">app.abc123.js</code></p>
                                     <i class="fas fa-database text-3xl text-blue-400 mt-2" title="缓存命中"></i>
                                 </div>
                                 <div class="text-center p-4 border rounded-lg bg-white w-full md:w-1/2">
                                     <p class="font-medium mb-2">新版本引用</p>
                                     <code class="text-sm bg-gray-100 p-1 rounded">&lt;script src="/app.<span class="text-green-600 font-mono">def456</span>.js"&gt;&lt;/script&gt;</code>
                                     <p class="mt-2 text-xs text-gray-500">浏览器视 <code class="text-xs">app.def456.js</code> 为新资源</p>
                                     <i class="fas fa-server text-3xl text-green-500 mt-2" title="请求服务器"></i>
                                 </div>
                             </div>
                         </div>

                        <h3 class="head3 mt-6">2. CDN 缓存刷新/预热 (Cache Purge/Prefetch)</h3>
                        <p class="text-sm mb-2 text-gray-600">如果使用了 CDN，即使更新了源站资源，CDN 节点上可能仍然缓存着旧版本。大多数 CDN 服务商提供 API 或控制台界面来手动或自动清理指定 URL 的缓存。</p>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li><strong>Purge (清理):</strong> 从 CDN 边缘节点删除指定资源的缓存。下次用户请求时，CDN 会回源获取最新版本。</li>
                            <li><strong>Prefetch (预热):</strong> 主动将新资源推送到 CDN 边缘节点，用户首次访问时就能直接从 CDN 获取。</li>
                        </ul>
                        <p class="text-sm mt-2 text-gray-600">这通常用于紧急修复或重要发布后，确保 CDN 快速同步。⭐️⭐️⭐️</p>

                        <h3 class="head3 mt-6">3. 合理设计 TTL (Time-To-Live)</h3>
                        <p class="text-sm mb-2 text-gray-600">为不同类型的资源设置合适的缓存时间：</p>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li><strong>静态资源 (带哈希):</strong> 可以设置非常长的 TTL (如一年 <code>max-age=31536000, immutable</code>)，依赖文件名更新来失效。</li>
                            <li><strong>动态 API 数据:</strong> 根据业务需求设置较短的 TTL (如几分钟)，并配合协商缓存。</li>
                            <li><strong>HTML 入口文件:</strong> 通常设置较短的 TTL 或 <code>no-cache</code>，因为它需要引用最新的带哈希的静态资源。</li>
                        </ul>

                        <p class="mt-4 text-sm text-gray-600"><i class="fas fa-lightbulb text-yellow-500 mr-1"></i><strong>关键：</strong>优先使用 URL 版本控制。CDN 清理是辅助手段。合理的 TTL 设计是基础。</p>
                    </div>
                </section>

                <section id="devtools" class="content-section fade-in fade-in-delay-7">
                     <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">build_circle</span>DevTools 实战观察指南
                    </h2>
                     <div class="content-card">
                         <p class="mb-4 text-gray-600">打开浏览器的开发者工具 (通常按 F12)，切换到 <strong>Network (网络)</strong> 面板，这是你观察和调试缓存行为的主战场。</p>
                         <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                             <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                                 <h3 class="font-semibold mb-2 text-gray-700"><i class="fas fa-ruler-combined mr-1"></i> 观察 `Size` 列</h3>
                                 <p class="text-sm mb-3 text-gray-600">刷新页面，观察资源加载的 `Size` 列显示：</p>
                                 <ul class="space-y-2 text-sm">
                                     <li class="flex items-start">
                                         <span class="status-indicator status-cache-memory mr-2 whitespace-nowrap"><i class="fas fa-brain"></i> memory cache</span>
                                         <span>: 资源从内存缓存加载，速度最快。</span>
                                     </li>
                                     <li class="flex items-start">
                                         <span class="status-indicator status-cache-disk mr-2 whitespace-nowrap"><i class="fas fa-hdd"></i> disk cache</span>
                                         <span>: 资源从磁盘缓存加载，速度较快 (命中了强缓存)。</span>
                                     </li>
                                     <li class="flex items-start">
                                         <span class="status-indicator status-304 mr-2 whitespace-nowrap"><i class="fas fa-exchange-alt"></i> 304</span>
                                         <span>: 协商缓存命中。Size 通常显示为头部大小。</span>
                                     </li>
                                     <li class="flex items-start">
                                         <span class="status-indicator status-server mr-2 whitespace-nowrap"><i class="fas fa-server"></i> (具体大小)</span>
                                         <span>: 资源从服务器完整下载 (如 `120 KB`)。</span>
                                     </li>
                                 </ul>
                                 <p class="text-xs text-gray-500 mt-3"><i class="fas fa-info-circle mr-1"></i> 提示：勾选 Network 面板顶部的 "Disable cache" 可以在开发时临时禁用缓存。</p>
                             </div>
                             <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                                 <h3 class="font-semibold mb-2 text-gray-700"><i class="fas fa-file-alt mr-1"></i> 查看 `Headers` 面板</h3>
                                 <p class="text-sm mb-3 text-gray-600">点击具体的网络请求，切换到 `Headers` 面板，仔细查看：</p>
                                 <ul class="space-y-2 text-sm">
                                     <li><strong>Response Headers (响应头):</strong>
                                         <ul class="list-disc list-inside ml-4 mt-1 text-gray-700">
                                             <li><code>Cache-Control</code>, <code>Expires</code>, <code>ETag</code>, <code>Last-Modified</code>, <code>Vary</code></li>
                                         </ul>
                                     </li>
                                     <li class="mt-2"><strong>Request Headers (请求头):</strong>
                                         <ul class="list-disc list-inside ml-4 mt-1 text-gray-700">
                                             <li><code>If-None-Match</code>, <code>If-Modified-Since</code> (协商缓存时)</li>
                                         </ul>
                                     </li>
                                 </ul>
                                 <p class="text-xs text-gray-500 mt-3"><i class="fas fa-search mr-1"></i> 通过检查这些头部，可以精确判断缓存策略是否按预期工作。</p>
                             </div>
                         </div>
                     </div>
                </section>

                 <section id="summary" class="content-section fade-in fade-in-delay-7">
                     <h2 class="flex items-center head2">
                        <span class="material-symbols-outlined">summarize</span>面试总结模板
                    </h2>
                     <div class="content-card bg-gradient-to-r from-blue-50 to-indigo-50 p-6 rounded-lg shadow-md">
                         <p class="mb-4 text-gray-600">当面试官问到浏览器缓存时，你可以这样组织回答，展现你的理解深度和实践经验：</p>
                         <div class="bg-white p-4 rounded-lg border border-blue-200 shadow-sm">
                             <p class="italic text-gray-700 leading-relaxed">
                                 “嗯，关于浏览器缓存，我理解它主要分为两大类：<strong>强缓存</strong>和<strong>协商缓存</strong>，目的是减少网络请求，提升页面加载速度。”
                                 <br><br>
                                 “<strong>强缓存</strong>是浏览器直接使用本地缓存，不与服务器通信。这主要通过 HTTP 响应头中的 <code>Cache-Control</code> (例如 <code>max-age</code>, <code>public</code>/<code>private</code>, <code>immutable</code>) 和 <code>Expires</code> (HTTP/1.0) 来控制。对于不经常变化的静态资源，比如带哈希文件名的 CSS、JS 文件，我们通常会设置一个很长的 <code>max-age</code>，利用强缓存来‘一劳永逸’。当资源更新时，我们会通过改变文件名（Cache Busting）来让浏览器请求新资源。”
                                 <br><br>
                                 “当强缓存失效后，或者资源被设置为 <code>no-cache</code> 时，就会进入<strong>协商缓存</strong>阶段。浏览器会向服务器发送一个验证请求，带上之前收到的 <code>ETag</code> (通过 <code>If-None-Match</code> 请求头) 或 <code>Last-Modified</code> 时间 (通过 <code>If-Modified-Since</code> 请求头)。服务器根据这些信息判断资源是否有更新。如果没有更新，服务器返回 <code>304 Not Modified</code> 状态码，浏览器就使用本地缓存，这样只传输了很小的头部信息，节省了带宽。如果资源有更新，服务器才返回 <code>200 OK</code> 和新的资源内容。”
                                 <br><br>
                                 “在实际项目中，我们会根据资源的特性来选择合适的缓存策略。比如：”
                                 <ul class="list-disc list-inside my-2 ml-4 text-sm space-y-1">
                                     <li>“构建产出的<strong>静态资源</strong>（CSS/JS/图片）使用带内容哈希的文件名 + 长时间的强缓存 (<code>max-age=31536000, immutable</code>)。”</li>
                                     <li>“<strong>不常变但可能更新的 API 数据</strong>（如配置信息）可以使用短时间的强缓存 + 协商缓存 (<code>max-age=60</code>, <code>ETag</code>)。”</li>
                                     <li>“<strong>需要实时性或个性化的数据</strong>（如购物车、用户信息）则使用 <code>Cache-Control: private, no-cache</code> 甚至 <code>no-store</code>，并可能配合 <code>Vary: Cookie</code> 头来处理代理缓存。”</li>
                                     <li>“网站的 <strong>HTML 入口文件</strong>通常设置 <code>no-cache</code> 或很短的 <code>max-age</code>，以确保能及时引用到最新的静态资源。”</li>
                                 </ul>
                                  “同时，我们也会关注 CDN 缓存策略，并使用 CDN 提供的<strong>缓存刷新 (Purge)</strong> 功能来应对紧急更新。”
                                 <br><br>
                                 “总的来说，目标是灵活运用这些缓存机制，结合 URL 版本化、CDN 策略，在保证数据实时性和安全性的前提下，最大化缓存命中率，减少用户等待时间，优化整体性能。”
                             </p>
                         </div>
                     </div>
                </section>


            </article>
        </main>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- Initialize Mermaid ---
            function initializeMermaid() {
                try {
                    if (typeof mermaid !== 'undefined') {
                        mermaid.initialize({ startOnLoad: false, theme: 'neutral', flowchart: { useMaxWidth: true, htmlLabels: true, curve: 'basis' }, securityLevel: 'loose' });
                        mermaid.run({ nodes: document.querySelectorAll('.mermaid') });
                        document.querySelectorAll('.mermaid-diagram-container').forEach(container => {
                            const mermaidEl = container.querySelector('.mermaid'); const fallbackEl = container.querySelector('.mermaid-fallback');
                            if (mermaidEl && fallbackEl && !mermaidEl.hasAttribute('data-processed')) {
                                if (mermaidEl.innerHTML.trim().startsWith('<svg') || mermaidEl.querySelector('svg')) { if (fallbackEl) fallbackEl.style.display = 'none'; }
                                else { if (fallbackEl) fallbackEl.style.display = 'block'; }
                            } else if (fallbackEl) { if (fallbackEl) fallbackEl.style.display = 'none'; }
                        });
                    } else { console.warn("Mermaid library not loaded."); document.querySelectorAll('.mermaid-fallback').forEach(el => el.style.display = 'block'); }
                } catch (e) { console.error("Mermaid initialization or rendering failed:", e); document.querySelectorAll('.mermaid-fallback').forEach(el => el.style.display = 'block'); }
            }
            window.addEventListener('load', initializeMermaid);

            // --- Initialize Prism Code Highlighting ---
            function initializePrism() {
                try { if (window.Prism) { Prism.highlightAll(); } else { console.warn("Prism library not loaded."); } }
                catch (e) { console.error("Prism highlighting failed:", e); }
            }
            initializePrism();

            // --- Sidebar Active Link Highlighting ---
            const sections = document.querySelectorAll('main section[id]');
            const sidebarLinks = document.querySelectorAll('.local-side-nav .sidebar-link');
            const sidebarNav = document.querySelector('.local-side-nav');
            if (sections.length > 0 && sidebarLinks.length > 0 && sidebarNav) {
                const observerOptions = { root: null, rootMargin: '0px 0px -60% 0px', threshold: 0 };
                let activeSectionId = null;
                const observer = new IntersectionObserver((entries) => {
                    let topmostVisibleSectionId = null; let minOffsetTop = Infinity;
                    entries.forEach(entry => { if (entry.isIntersecting) { if (entry.target.offsetTop < minOffsetTop) { minOffsetTop = entry.target.offsetTop; topmostVisibleSectionId = entry.target.getAttribute('id'); } } });
                    if (topmostVisibleSectionId) { activeSectionId = topmostVisibleSectionId; }
                    else if (window.scrollY === 0) { activeSectionId = sections[0].getAttribute('id'); }
                    sidebarLinks.forEach(link => {
                        const linkHref = link.getAttribute('href'); const linkSectionId = linkHref ? linkHref.substring(1) : null;
                        if (linkSectionId && linkSectionId === activeSectionId) { if (!link.classList.contains('active')) { link.classList.add('active'); if (sidebarNav.scrollHeight > sidebarNav.clientHeight) { link.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); } } }
                        else { link.classList.remove('active'); }
                    });
                }, observerOptions);
                sections.forEach(section => observer.observe(section));
                setTimeout(() => { // Initial check
                    let initialActiveId = window.location.hash ? window.location.hash.substring(1) : null;
                    if (!initialActiveId) { const scrollY = window.scrollY; const initialOffset = window.innerHeight * 0.4; for (const section of sections) { if (section.offsetTop <= scrollY + initialOffset) { initialActiveId = section.getAttribute('id'); } else { break; } } if (!initialActiveId) initialActiveId = sections[0].getAttribute('id'); }
                    if (initialActiveId) { activeSectionId = initialActiveId; sidebarLinks.forEach(link => { const linkHref = link.getAttribute('href'); const linkSectionId = linkHref ? linkHref.substring(1) : null; if (linkSectionId === activeSectionId) { link.classList.add('active'); if (sidebarNav.scrollHeight > sidebarNav.clientHeight) { link.scrollIntoView({ block: 'nearest' }); } } else { link.classList.remove('active'); } }); }
                }, 100);
            } else { console.warn("Sidebar highlighting elements not found or incomplete."); }

            // --- Code Block Copy Button Logic ---
            document.querySelectorAll('pre').forEach(pre => {
                const code = pre.querySelector('code');
                const button = pre.querySelector('.copy-button');
                if (button && code) {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent pre hover state from interfering
                        navigator.clipboard.writeText(code.innerText).then(() => {
                            const icon = button.querySelector('i');
                            const tooltip = button.querySelector('.tooltip');
                            const originalIconClass = icon.className;
                            const originalTooltipText = tooltip.textContent;
                            icon.className = 'fas fa-check text-green-400'; // Change icon to checkmark
                            tooltip.textContent = '已复制!';
                            button.style.opacity = '1'; // Keep button visible briefly
                            setTimeout(() => {
                                icon.className = originalIconClass;
                                tooltip.textContent = originalTooltipText;
                                button.style.opacity = ''; // Revert to hover-based opacity
                            }, 1500);
                        }).catch(err => {
                            console.error('无法复制:', err);
                            const tooltip = button.querySelector('.tooltip');
                            tooltip.textContent = '复制失败';
                            button.style.opacity = '1';
                            setTimeout(() => { tooltip.textContent = '复制'; button.style.opacity = ''; }, 1500);
                        });
                    });
                } else if (code && !button) { // Add button if missing
                    const newButton = document.createElement('button');
                    newButton.className = 'copy-button';
                    newButton.setAttribute('aria-label', '复制');
                    newButton.innerHTML = '<i class="far fa-copy"></i><span class="tooltip">复制</span>';
                    pre.appendChild(newButton);
                    // Re-run the event listener attachment for the new button
                     newButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(code.innerText).then(() => {
                            const icon = newButton.querySelector('i');
                            const tooltip = newButton.querySelector('.tooltip');
                            const originalIconClass = icon.className;
                            const originalTooltipText = tooltip.textContent;
                            icon.className = 'fas fa-check text-green-400';
                            tooltip.textContent = '已复制!';
                            newButton.style.opacity = '1';
                            setTimeout(() => {
                                icon.className = originalIconClass;
                                tooltip.textContent = originalTooltipText;
                                newButton.style.opacity = '';
                            }, 1500);
                        }).catch(err => {
                            console.error('无法复制:', err);
                            const tooltip = newButton.querySelector('.tooltip');
                            tooltip.textContent = '复制失败';
                             newButton.style.opacity = '1';
                            setTimeout(() => { tooltip.textContent = '复制'; newButton.style.opacity = ''; }, 1500);
                        });
                    });
                }
            });

            // --- Interactive Simulation Logic ---

            // Helper to set status indicators
            function setStatusIndicator(element, text, type) {
                 const icons = {
                     server: 'fas fa-server', cacheStrong: 'fas fa-bolt', cacheMemory: 'fas fa-brain', cacheDisk: 'fas fa-hdd',
                     checking: 'fas fa-sync-alt fa-spin', cache304: 'fas fa-check-circle', serverUpdate: 'fas fa-cloud-download-alt',
                     cachePrivate: 'fas fa-lock', noStore: 'fas fa-ban', update: 'fas fa-check-circle'
                 };
                 const styles = {
                     server: 'status-server', cacheStrong: 'status-cache-strong', cacheMemory: 'status-cache-memory', cacheDisk: 'status-cache-disk',
                     checking: 'status-checking', cache304: 'status-304', serverUpdate: 'status-server',
                     cachePrivate: 'status-private', noStore: 'status-no-store', update: 'status-update'
                 };
                 if(element) {
                     element.innerHTML = `<span class="status-indicator ${styles[type] || 'status-server'}"><i class="${icons[type] || 'fas fa-server'} mr-1"></i>${text}</span>`;
                 } else { console.error("Status element not found"); }
             }

            // Scenario 1: Static Resource
            const loadStaticBtn = document.getElementById('load-static-btn');
            const updateStaticBtn = document.getElementById('update-static-btn');
            const staticStatus = document.getElementById('static-status');
            const staticUpdateStatus = document.getElementById('static-update-status');
            let staticResource = { name: 'style.v1.css', version: 1, cached: false };

            if(loadStaticBtn && updateStaticBtn && staticStatus && staticUpdateStatus) {
                loadStaticBtn.addEventListener('click', () => {
                    if (!staticResource.cached) {
                        setStatusIndicator(staticStatus, `从服务器加载 ${staticResource.name}`, 'server');
                        staticResource.cached = true;
                        staticUpdateStatus.textContent = ''; // Clear update message
                    } else {
                        setStatusIndicator(staticStatus, `从强缓存加载 ${staticResource.name}`, 'cacheDisk'); // Assume disk for strong
                    }
                    loadStaticBtn.innerHTML = `<i class="fas fa-download mr-1"></i> 加载 ${staticResource.name}`;
                });

                updateStaticBtn.addEventListener('click', () => {
                    staticResource.version++;
                    staticResource.name = `style.v${staticResource.version}.css`;
                    staticResource.cached = false; // New version invalidates cache
                    setStatusIndicator(staticUpdateStatus, `已发布新版: ${staticResource.name}`, 'update');
                    staticStatus.innerHTML = '状态: 等待加载新版本';
                    loadStaticBtn.innerHTML = `<i class="fas fa-download mr-1"></i> 加载 ${staticResource.name}`;
                });
            } else { console.warn("Static resource simulation elements missing."); }

            // Scenario 2: Dynamic API (News)
            const loadNewsBtn = document.getElementById('load-news-btn');
            const newsStatus = document.getElementById('news-status');
            const newsTimer = document.getElementById('news-timer');
            const newsDataEl = document.getElementById('news-data');
            let newsCache = { data: null, etag: null, lastModified: null, loadTime: null, maxAge: 5000 };
            let newsVersion = 1;
            let newsTimerInterval;

            function updateNewsTimer() {
                clearInterval(newsTimerInterval);
                if (!newsCache.loadTime || !newsTimer) { if(newsTimer) newsTimer.textContent = ''; return; }
                newsTimerInterval = setInterval(() => {
                    const now = Date.now(); const elapsed = now - newsCache.loadTime; const remaining = newsCache.maxAge - elapsed;
                    if (remaining > 0) { newsTimer.textContent = `强缓存剩余: ${(remaining / 1000).toFixed(1)} 秒`; }
                    else { newsTimer.textContent = '强缓存已过期，下次将进行协商缓存'; clearInterval(newsTimerInterval); }
                }, 100);
            }

            function setNewsStatus(text, type, data = null) {
                setStatusIndicator(newsStatus, text, type);
                if (data && newsDataEl) {
                    newsDataEl.textContent = JSON.stringify(data, null, 2); newsDataEl.classList.remove('hidden');
                } else if (type !== 'checking' && type !== 'cache304' && newsDataEl) {
                    // Hide data if not checking and not 304 (unless you want to keep old data for 304)
                    // newsDataEl.classList.add('hidden');
                }
            }

            if(loadNewsBtn && newsStatus && newsTimer && newsDataEl) {
                loadNewsBtn.addEventListener('click', () => {
                    const now = Date.now();
                    // 1. Check Strong Cache
                    if (newsCache.loadTime && (now - newsCache.loadTime < newsCache.maxAge)) {
                        setNewsStatus('从强缓存加载', 'cacheStrong', newsCache.data); updateNewsTimer(); return;
                    }
                    // 2. Simulate negotiation
                    setNewsStatus('检查服务器更新...', 'checking'); if(newsTimer) newsTimer.textContent = ''; clearInterval(newsTimerInterval);
                    setTimeout(() => {
                        const hasUpdate = Math.random() < 0.3; // 30% chance of update
                        if (newsCache.data && !hasUpdate) { // Simulate 304
                            setNewsStatus('服务器确认无更新 (304)，使用缓存', 'cache304', newsCache.data);
                            newsCache.loadTime = Date.now(); updateNewsTimer(); // Reset timer
                        } else { // Simulate 200 OK
                            newsVersion++; const newData = { news: [`新闻 ${newsVersion}-1`, `新闻 ${newsVersion}-2`], timestamp: new Date().toLocaleTimeString() };
                            const newEtag = `news-v${newsVersion}-${Math.random().toString(36).substring(7)}`; const newLastModified = new Date().toUTCString();
                            setNewsStatus(`从服务器获取更新 (200)`, 'serverUpdate', newData);
                            newsCache = { data: newData, etag: newEtag, lastModified: newLastModified, loadTime: Date.now(), maxAge: 5000 };
                            updateNewsTimer();
                        }
                    }, 500); // Simulate network delay
                });
            } else { console.warn("News API simulation elements missing."); }

            // Scenario 3: Personalized Content (Cart)
            const loadCartBtn = document.getElementById('load-cart-btn');
            const cartStatus = document.getElementById('cart-status');
            const cartDataEl = document.getElementById('cart-data');
            const noStoreCheckbox = document.getElementById('force-no-store');
            let cartVersion = 1;
            let cartEtag = null; // Used only for no-cache simulation
            let cartCacheData = null; // Store data locally for 304 simulation

            function setCartStatus(text, type, data = null) {
                setStatusIndicator(cartStatus, text, type);
                if (data && cartDataEl) {
                    cartDataEl.textContent = JSON.stringify(data, null, 2); cartDataEl.classList.remove('hidden');
                    cartCacheData = data; // Update local cache for 304
                } else if (type !== 'checking' && type !== 'cachePrivate' && cartDataEl) {
                    // Hide data if not checking and not using private cache after 304
                    // cartDataEl.classList.add('hidden');
                } else if (type === 'cachePrivate' && cartCacheData && cartDataEl) {
                     // Ensure data is shown for 304 case
                     cartDataEl.textContent = JSON.stringify(cartCacheData, null, 2);
                     cartDataEl.classList.remove('hidden');
                }
            }

            if(loadCartBtn && cartStatus && cartDataEl && noStoreCheckbox) {
                loadCartBtn.addEventListener('click', () => {
                    const useNoStore = noStoreCheckbox.checked;
                    if (useNoStore) { // Simulate no-store
                        setCartStatus('强制请求服务器 (no-store)...', 'checking');
                        setTimeout(() => {
                            cartVersion++; const newData = { items: [`商品A v${cartVersion}`, '商品B'], user: 'Alice', timestamp: new Date().toLocaleTimeString() };
                            setCartStatus('从服务器获取 (no-store)', 'noStore', newData);
                            cartEtag = null; cartCacheData = null; // Clear local state for no-store
                        }, 300);
                    } else { // Simulate no-cache
                        setCartStatus('向服务器验证 (no-cache)...', 'checking');
                        setTimeout(() => {
                            const hasUpdate = Math.random() < 0.5; // 50% chance of update
                            const currentEtag = `cart-v${cartVersion}`; // Simple ETag
                            if (cartEtag === currentEtag && !hasUpdate) { // Simulate 304
                                setCartStatus('服务器确认无更新 (304)，使用私有缓存', 'cachePrivate', cartCacheData);
                            } else { // Simulate 200 OK
                                if (hasUpdate || !cartEtag) cartVersion++; // Update version if needed
                                const newData = { items: [`商品A v${cartVersion}`, '商品B'], user: 'Alice', timestamp: new Date().toLocaleTimeString() };
                                cartEtag = `cart-v${cartVersion}`; // Update ETag
                                setCartStatus('从服务器获取更新 (200)', 'serverUpdate', newData);
                            }
                        }, 300);
                    }
                });
            } else { console.warn("Cart simulation elements missing."); }

        }); // End DOMContentLoaded
    </script>

</body>

</html>
