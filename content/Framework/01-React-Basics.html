<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React 基础</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="../../global.css">
    <style>
        /* Minimal inline styles - Primarily rely on global.css and Tailwind */

        /* --- Base & Layout Adjustments --- */
        html {
            scroll-padding-top: 2rem; /* Adjust if header is sticky */
        }

        body {
            /* Base font, bg, color assumed from global.css */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-family: 'Inter', sans-serif; /* Ensure Inter font */
            background-color: var(--bg-color-lighter); /* Use global.css variable */
        }

        /* --- Typography (Leverage global.css .headX classes) --- */
        h1, h2, h3, h4, h5, h6 {
            scroll-margin-top: 2rem; /* Offset for sticky nav */
        }
        /* Increase bottom margin for headings for better whitespace */
        .head1 { margin-bottom: 1.5rem; } /* mb-6 */
        .head2 { margin-bottom: 1.25rem; } /* mb-5 */
        .head3 { margin-bottom: 0.75rem; } /* mb-3 */

        /* Style for frequency/level tags (Copied from 01-Network-Basics.html) */
        .level-tag {
            display: inline-block;
            margin-left: 0.5rem;
            font-size: 0.75rem; /* text-xs */
            font-weight: 500; /* font-medium */
            padding: 0.1rem 0.5rem;
            border-radius: 0.25rem; /* rounded-sm */
            vertical-align: middle;
            border: 1px solid transparent;
        }

        .level-tag-high {
            background-color: var(--danger-color-light);
            color: var(--danger-color);
            border-color: var(--danger-color);
        }

        .level-tag-medium {
            background-color: var(--warning-color-light);
            color: var(--warning-color);
            border-color: var(--warning-color);
        }

        .level-tag-low {
            background-color: var(--secondary-color-light);
            color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        /* --- Code Block Styling (Leverage Prism theme and global.css) --- */
        article pre {
            font-family: var(--font-family-mono);
            border-radius: 0.375rem; /* rounded-md */
            margin: 1.5rem 0; /* Increased margin */
            padding: 1em;
            overflow-x: auto;
        }
        article pre code[class*="language-"] {
            background: none; color: inherit; padding: 0; border-radius: 0;
            font-size: inherit; font-family: inherit; line-height: inherit;
            text-shadow: none; white-space: pre; display: block;
        }
        /* Inline code styling */
         *:not(pre) > code {
            background-color: rgba(17, 24, 39, 0.05); /* Light gray background */
            color: #DC2626; /* Reddish text color */
            padding: 0.1em 0.3em;
            border-radius: 0.25rem;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9em; /* Slightly smaller */
        }

        /* --- Card Adjustments --- */
        .content-card {
             /* Add transition for hover effects */
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out;
            margin-bottom: 1.5rem; /* mb-6, ensure spacing */
        }
        /* Hover effect: slight shadow increase and lift */
        .content-card:hover {
            /* Use Tailwind shadow-lg or a slightly stronger custom shadow */
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            transform: translateY(-2px); /* Slight lift effect */
        }
        .content-section > .content-card + .content-card {
            margin-top: 2rem; /* Increased space between cards */
        }
        .content-card > *:last-child {
            margin-bottom: 0 !important;
        }
        /* Increase spacing within cards */
        .content-card p, .content-card ul, .content-card ol {
            margin-bottom: 1rem; /* mb-4 */
        }
        .content-card ul, .content-card ol {
            padding-left: 1.5em;
        }
        .content-card li {
            margin-bottom: 0.5rem; /* mb-2 */
        }

        /* --- Information Blocks --- */
        .info-block {
            background-color: var(--primary-color-light); /* bg-blue-50 */
            border-left: 4px solid var(--primary-color); /* border-blue-500 */
            padding: 1rem; /* p-4 */
            margin: 1.5rem 0; /* my-6 */
            border-radius: 0.375rem; /* rounded-md */
            font-size: 0.9rem; /* text-sm */
            color: var(--text-color-default); /* text-gray-700 */
        }
        .info-block strong {
            color: var(--primary-color-dark); /* text-blue-700 */
        }
        .info-block code { /* Style inline code inside info blocks */
             background-color: rgba(59, 130, 246, 0.1); /* Lighter blue bg */
             color: var(--primary-color-dark);
             padding: 0.1em 0.3em;
             border-radius: 0.25rem;
             font-family: 'Roboto Mono', monospace;
             font-size: 0.9em;
        }
        .warning-block {
            background-color: var(--warning-color-light);
            border-left-color: var(--warning-color);
            color: #b45309; /* darker orange */
        }
         .warning-block strong {
             color: #92400e;
         }
         .warning-block code {
             background-color: rgba(249, 115, 22, 0.1);
             color: #b45309;
         }

        /* --- Fade-in Animation --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-section {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* --- Mermaid Diagram Styling --- */
        .mermaid {
            margin: 2rem 0; /* Increased margin */
            text-align: center;
            background-color: var(--bg-color-light);
            padding: 1.5rem; /* Increased padding */
            border-radius: 0.5rem; /* rounded-lg */
            border: 1px solid var(--border-color-light);
            overflow-x: auto; /* Ensure horizontal scroll if needed */
        }
        .mermaid svg { max-width: 100%; height: auto; display: block; margin: auto; }

        /* --- Quiz Card Styling (Copied & adapted from example.html) --- */
        .quiz-card {
            background-color: var(--quiz-bg, var(--primary-color-light));
            border: 1px solid var(--border-color-default);
            border-left: 4px solid var(--quiz-border-color, var(--primary-color));
            border-radius: 0.5rem; /* rounded-lg */
            padding: var(--quiz-padding, 1.5rem); /* p-6 */
            margin-top: 2rem; /* Add top margin */
            margin-bottom: 1.5rem; /* mb-6 */
            box-shadow: var(--card-shadow-default); /* shadow-md */
        }
        .quiz-question { font-size: 1.1rem; font-weight: 500; color: var(--text-color-dark); margin-bottom: 1.25rem; display: flex; align-items: center; gap: 0.5rem; }
        .quiz-options { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.25rem; }
        .quiz-option { display: block; padding: 0.75rem 1rem; border: 1px solid var(--border-color-default); border-radius: 0.375rem; background-color: white; cursor: pointer; transition: background-color 0.2s ease, border-color 0.2s ease; display: flex; align-items: center; }
        .quiz-option:hover { background-color: var(--quiz-option-hover-bg, rgba(59, 130, 246, 0.1)); border-color: var(--primary-color); }
        .quiz-option input[type="radio"] { margin-right: 0.75rem; width: 1rem; height: 1rem; accent-color: var(--primary-color); cursor: pointer; flex-shrink: 0; }
        .quiz-option span { flex-grow: 1; cursor: pointer; color: var(--text-color-default); font-size: 0.9rem; }
        .quiz-option.selected { border-color: var(--primary-color); background-color: rgba(59, 130, 246, 0.15); }
        .quiz-option.correct { border-color: var(--success-color); background-color: rgba(16, 185, 129, 0.1); }
        .quiz-option.incorrect { border-color: var(--danger-color); background-color: rgba(239, 68, 68, 0.1); }
        .quiz-feedback { margin-top: 1rem; padding: 0.75rem 1rem; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500; display: none; }
        .quiz-feedback.correct { background-color: var(--quiz-feedback-correct-bg); color: var(--quiz-feedback-correct-text); border: 1px solid var(--success-color); }
        .quiz-feedback.incorrect { background-color: var(--quiz-feedback-incorrect-bg); color: var(--quiz-feedback-incorrect-text); border: 1px solid var(--danger-color); }
        .quiz-feedback.warning { background-color: var(--warning-color-light); color: var(--warning-color); border: 1px solid var(--warning-color); }
        .quiz-toggle { /* Use button styles */ position: relative; overflow: hidden; display: inline-flex; align-items: center; gap: 0.25rem; }
        .quiz-toggle .material-icons { font-size: 1.1rem; transition: transform 0.3s ease-in-out; }
        .quiz-toggle .icon-arrow.rotated { transform: rotate(180deg); }
        .quiz-answer { max-height: 0; opacity: 0; transition: all 0.5s ease-in-out; overflow: hidden; padding-top: 0; padding-bottom: 0; margin-top: 0; border-top: 1px solid var(--border-color-light); }
        .quiz-answer.visible { max-height: 1000px; opacity: 1; padding-top: 1rem; padding-bottom: 1rem; margin-top: 1rem; overflow: auto; }

        /* --- Ripple Effect (Copied from example.html) --- */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(var(--primary-color-rgb, 59, 130, 246), 0.4); /* Use RGB for opacity */
            transform: scale(0);
            animation: ripple-animation 0.6s linear;
            pointer-events: none;
        }
        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

    </style>
</head>

<body class="bg-gray-100">
    <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">React 基础</h4>
            <ul id="local-toc">
                <li><a href="#intro" class="active"><span class="material-icons nav-icon">info</span>简介</a></li>
                <li><a href="#jsx"><span class="material-icons nav-icon">code</span>JSX 语法</a></li>
                 <li><a href="#fragments" class="ml-4 text-sm"><span class="material-icons nav-icon text-base">filter_none</span>Fragments</a></li>
                <li><a href="#components"><span class="material-icons nav-icon">widgets</span>组件</a></li>
                 <li><a href="#props-vs-state" class="ml-4 text-sm"><span class="material-icons nav-icon text-base">compare_arrows</span>Props vs State</a></li>
                <li><a href="#state"><span class="material-icons nav-icon">tune</span>State (useState)</a></li>
                <li><a href="#lifecycle"><span class="material-icons nav-icon">hourglass_empty</span>生命周期 (useEffect)</a></li>
                <li><a href="#events"><span class="material-icons nav-icon">touch_app</span>事件处理</a></li>
                 <li><a href="#controlled-uncontrolled" class="ml-4 text-sm"><span class="material-icons nav-icon text-base">rule</span>受控与非受控组件</a></li>
                <li><a href="#refs"><span class="material-icons nav-icon">attachment</span>Refs (useRef)</a></li>
                <li><a href="#hooks-rules"><span class="material-icons nav-icon">gavel</span>Hooks 规则</a></li>
            </ul>
            <a href="../../index.html" class="back-link">
                &larr; 返回大纲目录
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="intro" class="content-section fade-in-section" style="animation-delay: 0s;">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-icons text-3xl text-blue-600">looks_one</span>(一) React 基础
                    </h1>
                    <p>React 是一个用于构建用户界面的 JavaScript 库。它采用组件化思想，允许开发者将 UI 拆分成独立、可复用的部分。本节将介绍 React 开发中最核心的基础知识，这些是理解和使用 React 的基石，也是前端面试中的高频考点。</p>
                    <div class="info-block">💡
                        <strong>提示:</strong> 点击左侧导航可以快速跳转到相应主题。括号内标注了知识点的重要程度。部分章节末尾包含测验。
                    </div>
                </section>

                <section id="jsx" class="content-section fade-in-section" style="animation-delay: 0.05s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">code</span>JSX 语法
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">description</span>基本用法</h3>
                        <p>JSX (JavaScript XML) 是 React 的一种语法扩展，允许你在 JavaScript 代码中编写类似 HTML 的结构。它使得 UI 的描述更加直观和声明式。</p>
                        <p>注意：JSX 最终会被 Babel 等工具编译成普通的 JavaScript 函数调用（<code>React.createElement()</code>），浏览器本身并不直接理解 JSX。</p>
                        <pre><code class="language-javascript">// JSX Example
const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;

// The JSX above is equivalent to this JavaScript call:
const elementJS = React.createElement('h1', null, 'Hello, world!');</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">integration_instructions</span>嵌入表达式</h3>
                        <p>你可以在 JSX 中使用花括号 <code>{}</code> 嵌入任何有效的 JavaScript 表达式。这使得动态渲染内容变得容易。</p>
                        <pre><code class="language-javascript">const name = "Gemini";
const user = { firstName: "React", lastName: "User" };

function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

// Examples of embedding expressions
const greeting = &lt;h1&gt;Hello, {name}!&lt;/h1&gt;; // Embed a variable
const fullName = &lt;p&gt;Full Name: {formatName(user)}&lt;/p&gt;; // Embed function call result
const calculation = &lt;div&gt;Result: {2 * 3}&lt;/div&gt;; // Embed arithmetic operation
const elementWithClass = &lt;div className="container"&gt;Content&lt;/div&gt;; // Use className instead of class
const elementWithStyle = &lt;p style={{ color: 'blue', fontSize: '16px' }}&gt;Styled Text&lt;/p&gt;; // Embed style object
</code></pre>
                        <div class="info-block">
                            <p><strong>注意：</strong></p>
                            <ul>
                                <li>JSX 属性名使用驼峰命名法 (camelCase)，例如 <code>className</code> 对应 HTML 的 <code>class</code>，<code>onClick</code> 对应 <code>onclick</code>，<code>htmlFor</code> 对应 <code>for</code>。</li>
                                <li>样式 (<code>style</code>) 接受一个 JavaScript 对象，属性名也使用驼峰命名法 (如 <code>fontSize</code>, <code>backgroundColor</code>)。</li>
                                <li>JSX 表达式必须包含在单个父元素中。如果不想添加额外的 DOM 节点，可以使用 <code>&lt;React.Fragment&gt;</code> 或其简写语法 <code>&lt;&gt;</code> (见下文)。</li>
                            </ul>
                        </div>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">rule</span>条件渲染</h3>
                        <p>在 React 中，你可以使用标准的 JavaScript 语法来根据条件决定渲染哪些元素。</p>
                        <p><strong>1. 使用 <code>if/else</code> (在 return 语句外部):</strong></p>
                        <pre><code class="language-javascript">function Greeting({ isLoggedIn }) {
  if (isLoggedIn) {
    return &lt;h1&gt;Welcome back!&lt;/h1&gt;;
  } else {
    return &lt;h1&gt;Please sign up.&lt;/h1&gt;;
  }
}</code></pre>
                        <p><strong>2. 使用三元运算符 (<code>condition ? exprIfTrue : exprIfFalse</code>) (在 JSX 内部):</strong></p>
                        <pre><code class="language-javascript">function LoginStatus({ isLoggedIn }) {
  return (
    &lt;div&gt;
      User is &lt;b&gt;{isLoggedIn ? 'currently' : 'not'}&lt;/b&gt; logged in.
    &lt;/div&gt;
  );
}</code></pre>
                        <p><strong>3. 使用逻辑 <code>&&</code> 运算符 (<code>condition && expression</code>):</strong></p>
                        <p>如果条件为真，则渲染 <code>&&</code> 后面的表达式；如果条件为假，则什么都不渲染 (渲染 <code>false</code>，在 DOM 中无效果)。</p>
                        <pre><code class="language-javascript">function Mailbox({ unreadMessages }) {
  return (
    &lt;div&gt;
      <h1>Hello!</h1>
      {/* Only render if there are unread messages */}
      {unreadMessages.length > 0 &&
        &lt;h2&gt;
          You have {unreadMessages.length} unread messages.
        &lt;/h2&gt;
      }
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">list_alt</span>列表渲染与 Keys</h3>
                        <p>通常使用 JavaScript 的 <code>.map()</code> 方法来遍历数组，并为每个元素返回一个 React 元素。</p>
                        <p><strong>关键：</strong>为列表中的每个元素提供一个<strong class="text-red-600">唯一且稳定</strong>的 <code>key</code> prop。<code>key</code> 帮助 React 识别哪些元素发生了变化、添加或删除，从而高效地更新 UI。</p>
                        <pre><code class="language-javascript">const numbers = [1, 2, 3, 4, 5];

function NumberList() {
  const listItems = numbers.map((number) =>
    // key should be a stable and unique identifier, often the item's ID from data
    &lt;li key={number.toString()}&gt;
      Number {number}
    &lt;/li&gt;
  );
  return (
    &lt;ul&gt;{listItems}&lt;/ul&gt;
  );
}

// Can also use map directly within JSX
function TodoList({ todos }) { // Assuming todos = [{id: 'a1', text: '...'}, {id: 'b2', text: '...'}]
  return (
    &lt;ul&gt;
      {todos.map((todo) => (
        &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
</code></pre>
                        <div class="warning-block">
                            <p><strong>为什么 <code>key</code> 如此重要？</strong></p>
                            <ul>
                                <li><strong>高效 Diffing:</strong> <code>key</code> 是 React 在比较新旧虚拟 DOM 树时用来匹配子元素的主要依据。有了稳定的 key，React 可以快速判断元素是新增、删除还是仅仅移动或更新了内容。</li>
                                <li><strong>避免状态混乱:</strong> 如果使用数组索引作为 key，当列表项被添加、删除或重新排序时，索引会改变。这可能导致 React 错误地复用带有旧状态的组件实例，引发难以预料的 bug。</li>
                                <li><strong>性能:</strong> 没有 key 或使用不稳定 key 会迫使 React 进行更多不必要的 DOM 操作。</li>
                                <li><strong>要求:</strong> <code>key</code> 只需要在<strong class="text-red-600">同一层级的兄弟元素之间</strong>保持唯一，不需要全局唯一。它应该是字符串或数字类型。</li>
                                <li><strong>最佳实践:</strong> 优先使用数据中自带的唯一 ID (如数据库 ID) 作为 key。避免使用随机数或不稳定的值。仅在列表项既没有 ID 且顺序永远不变的情况下，才可考虑使用索引作为 key，但仍需谨慎。</li>
                            </ul>
                        </div>
                    </div>
                    <div class="quiz-card" id="quiz-jsx">
                        <div class="quiz-question"><span class="material-icons">quiz</span>JSX 测验：在 React 中，为什么强烈推荐为列表渲染中的每个元素提供一个唯一的 `key` prop？</div>
                        <div class="quiz-options">
                            <label class="quiz-option"><input type="radio" name="q_jsx" value="a"><span>为了给元素添加 CSS 类名。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_jsx" value="b"><span>为了帮助 React 高效地识别和更新列表项，避免状态混乱。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_jsx" value="c"><span>为了在元素上绑定点击事件。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_jsx" value="d"><span>为了让代码看起来更整洁。</span></label>
                        </div>
                        <div class="quiz-feedback" id="feedback-q_jsx"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_jsx', 'b', this)">
                            <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                        <div class="quiz-answer">
                            <p><strong>答案:</strong> B. 为了帮助 React 高效地识别和更新列表项，避免状态混乱。</p>
                            <p><strong>解析:</strong> `key` prop 是 React Diffing 算法用来识别列表中元素身份的关键。提供稳定且唯一的 key 可以让 React 准确地知道哪些元素是新增、删除、移动或更新的，从而进行最高效的 DOM 操作，并正确地保留或销毁组件状态。</p>
                        </div>
                    </div>
                </section>

                 <section id="fragments" class="content-section fade-in-section" style="animation-delay: 0.1s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">filter_none</span>React Fragments
                    </h2>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">layers</span>解决多余的 DOM 节点</h3>
                        <p>React 组件的 <code>render</code> 方法或函数组件的返回值必须是一个<strong class="text-red-600">单一的根元素</strong>。有时为了满足这个要求，我们不得不添加一个额外的 <code>&lt;div&gt;</code> 包装器，但这可能会在最终的 DOM 结构中引入不必要的层级。</p>
                        <p>React Fragments 允许你将多个子元素分组，而无需向 DOM 添加额外的节点。</p>
                        <p><strong>使用方式：</strong></p>
                        <pre><code class="language-javascript">import React from 'react'; // React import needed for React.Fragment

function Columns() {
  return (
    // 使用 React.Fragment
    &lt;React.Fragment&gt;
      &lt;td&gt;Column 1&lt;/td&gt;
      &lt;td&gt;Column 2&lt;/td&gt;
    &lt;/React.Fragment&gt;
  );
}

function ShortSyntaxColumns() {
  return (
    // 使用短语法 <> (更常用，无需导入 React)
    &lt;&gt;
      &lt;td&gt;Column A&lt;/td&gt;
      &lt;td&gt;Column B&lt;/td&gt;
    &lt;/&gt;
  );
}

function Table() {
  return (
    &lt;table border="1"&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;Columns /&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;ShortSyntaxColumns /&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
}</code></pre>
                        <p>短语法 <code>&lt;&gt;...&lt;/&gt;</code> 是最常用的方式。注意：短语法不支持添加 <code>key</code> 或其他属性，如果需要 key（例如在列表渲染中使用 Fragment），则必须使用显式的 <code>&lt;React.Fragment key={item.id}&gt;...&lt;/React.Fragment&gt;</code> 语法。</p>
                    </div>
                </section>

                <section id="components" class="content-section fade-in-section" style="animation-delay: 0.15s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">widgets</span>组件
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">functions</span>函数组件 (Function Components) - 重点</h3>
                        <p>这是现代 React 开发推荐的方式。函数组件是接收 <code>props</code> 对象作为参数并返回 JSX 的 JavaScript 函数。</p>
                        <p>通过使用 Hooks (如 <code>useState</code>, <code>useEffect</code>)，函数组件可以拥有状态 (state) 和生命周期等特性。</p>
                        <pre><code class="language-javascript">// A simple function component
function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

// Using ES6 destructuring for props
function Greeting({ name, message }) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{message}, {name}!&lt;/h2&gt;
    &lt;/div&gt;
  );
}

// Using components
function App() {
    return (
      &lt;div&gt;
        &lt;Welcome name="Sara" /&gt;
        &lt;Greeting name="Cahal" message="Good morning" /&gt;
      &lt;/div&gt;
    );
}</code></pre>
                        <p><strong>优点：</strong>通常更简洁、易于阅读、测试和理解；与 Hooks 结合使用功能强大。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">view_quilt</span>类组件 (Class Components) - 了解即可</h3>
                        <p>这是早期 React 的主要方式。类组件是继承自 <code>React.Component</code> 的 ES6 类。</p>
                        <ul>
                            <li>通过 <code>this.props</code> 访问 props。</li>
                            <li>通过 <code>this.state</code> 和 <code>this.setState()</code> 管理内部状态。</li>
                            <li>拥有生命周期方法（如 <code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code>）。</li>
                            <li>必须实现 <code>render()</code> 方法来返回 JSX。</li>
                        </ul>
                        <pre><code class="language-javascript">import React from 'react';

class WelcomeClass extends React.Component {
  render() {
    // Access props via this.props
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}

// Using a class component
const element = &lt;WelcomeClass name="Classy User" /&gt;;</code></pre>
                        <p>虽然现在不推荐编写新的类组件，但理解其基本概念有助于维护旧代码库和理解 React 的演变。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">input</span>Props 传递</h3>
                        <p>Props (properties 的缩写) 是组件之间传递数据的主要方式，遵循<strong class="text-blue-600">自顶向下</strong>的单向数据流。</p>
                         <div class="mermaid">
                          graph TD
                          A(父组件 App) -->|"props: name, age, email"| B("子组件 UserProfile");
                          A -->|"props: {...userData}"| C(子组件 UserProfile);
                          B -- "读取 props (只读)" --> D{UI 显示};
                          C -- "读取 props (只读)" --> D;

                          style A fill:#e0f2fe,stroke:#0ea5e9,stroke-width:2px
                          style B fill:#f0fdfa,stroke:#0d9488,stroke-width:1px
                          style C fill:#f0fdfa,stroke:#0d9488,stroke-width:1px
                          style D fill:#f1f5f9,stroke:#64748b
                         </div>
                        <ul>
                            <li>父组件通过 JSX 属性将数据传递给子组件。</li>
                            <li>子组件通过其参数（函数组件）或 <code>this.props</code>（类组件）接收这些数据。</li>
                            <li>Props 对于子组件来说是<strong class="text-red-600">只读</strong>的。子组件不能直接修改接收到的 props。这是为了保证数据流的可预测性。如果需要修改，应该由拥有该数据的父组件进行修改，并通过 props 重新传递，或者使用状态管理方案。</li>
                        </ul>
                        <pre><code class="language-javascript">function UserProfile({ name, age, email }) { // Child component receives props
  return (
    &lt;div className="border p-4 rounded bg-gray-50 mt-4"&gt;
      &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; {name}&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Age:&lt;/strong&gt; {age}&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function App() { // Parent component
  const userData = { name: "Alice", age: 30, email: "alice@example.com" };
  return (
    &lt;div&gt;
      &lt;h2 class="head4"&gt;用户信息&lt;/h2&gt;
      {/* Parent passes data via attributes */}
      &lt;UserProfile
        name={userData.name}
        age={userData.age}
        email={userData.email}
      /&gt;
      {/* Can use spread operator to pass object properties */}
      {/* &lt;UserProfile {...userData} /&gt; */}
    &lt;/div&gt;
  );
}</code></pre>
                        <p><code>props.children</code> 是一个特殊的 prop，它包含了组件标签之间的内容。</p>
                         <pre><code class="language-javascript">function Card({ children, title }) {
  // children prop contains the content between <Card> and </Card>
  return (
    &lt;div className="border rounded-lg p-4 shadow bg-white my-4"&gt;
      {title && &lt;h3 className="head5 mt-0 mb-3 text-indigo-700"&gt;{title}&lt;/h3&gt;}
      {children}
    &lt;/div&gt;
  );
}

function AppLayout() {
  return (
    &lt;Card title="信息卡片"&gt;
      &lt;p&gt;这段内容将作为 props.children 传递给 Card 组件。&lt;/p&gt;
      &lt;button className="button button-secondary"&gt;卡片内按钮&lt;/button&gt;
    &lt;/Card&gt;
  );
}</code></pre>
                    </div>
                     <div class="quiz-card" id="quiz-components">
                        <div class="quiz-question"><span class="material-icons">quiz</span>组件测验：关于 React 的 Props，以下哪个说法是正确的？</div>
                        <div class="quiz-options">
                            <label class="quiz-option"><input type="radio" name="q_components" value="a"><span>Props 是组件内部的可变状态。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_components" value="b"><span>子组件可以直接修改从父组件接收到的 Props。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_components" value="c"><span>Props 是父组件向子组件传递数据的只读属性。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_components" value="d"><span>只有类组件才能接收 Props。</span></label>
                        </div>
                        <div class="quiz-feedback" id="feedback-q_components"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_components', 'c', this)">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                        <div class="quiz-answer">
                            <p><strong>答案:</strong> C. Props 是父组件向子组件传递数据的只读属性。</p>
                            <p><strong>解析:</strong> Props 是 React 中实现自顶向下单向数据流的关键机制。父组件通过属性将数据传递给子组件，子组件接收这些数据作为 props，但不能直接修改它们。State 才是组件内部的可变数据。函数组件和类组件都可以接收 Props。</p>
                        </div>
                    </div>
                </section>

                 <section id="props-vs-state" class="content-section fade-in-section" style="animation-delay: 0.2s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">compare_arrows</span>Props vs State 对比
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">difference</span>核心区别</h3>
                        <p>Props 和 State 是 React 组件中数据的两个主要来源，理解它们的区别至关重要。</p>
                         <div class="mermaid">
                            graph LR
                                subgraph 父组件
                                    PState[内部 State] -- "计算/转换" --> PPropsOut(传给子组件的 Props)
                                end
                                subgraph 子组件
                                    CPropsIn(接收到的 Props) -- "影响渲染" --> CUI[UI 输出]
                                    CState[内部 State] -- "影响渲染" --> CUI
                                    CUI -- "用户交互" --> CEventHandler{事件处理}
                                    CEventHandler -- "更新 State" --> CState
                                end
                                PPropsOut --> CPropsIn

                                style PState fill:#fffbeb,stroke:#d97706
                                style CState fill:#fffbeb,stroke:#d97706
                                style PPropsOut fill:#eff6ff,stroke:#3b82f6
                                style CPropsIn fill:#eff6ff,stroke:#3b82f6
                                style CUI fill:#f3f4f6,stroke:#6b7280
                                style CEventHandler fill:#ecfdf5,stroke:#10b981
                         </div>
                        <div class="overflow-x-auto mt-6">
                            <table class="w-full border border-collapse">
                                <thead>
                                    <tr class="bg-gray-100">
                                        <th class="border p-3 text-left">特性</th>
                                        <th class="border p-3 text-left">Props</th>
                                        <th class="border p-3 text-left">State</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="border p-3 font-medium">来源</td>
                                        <td class="border p-3">从父组件传递下来</td>
                                        <td class="border p-3">在组件内部定义和管理</td>
                                    </tr>
                                    <tr>
                                        <td class="border p-3 font-medium">可变性</td>
                                        <td class="border p-3"><strong class="text-red-600">只读</strong> (Immutable)。子组件不能直接修改。</td>
                                        <td class="border p-3"><strong class="text-green-600">可变</strong> (Mutable)。组件可以通过 <code>setState</code> 函数修改。</td>
                                    </tr>
                                     <tr>
                                        <td class="border p-3 font-medium">所有权</td>
                                        <td class="border p-3">由父组件拥有和控制</td>
                                        <td class="border p-3">由组件自身拥有和控制</td>
                                    </tr>
                                    <tr>
                                        <td class="border p-3 font-medium">数据流</td>
                                        <td class="border p-3">单向 (从父到子)</td>
                                        <td class="border p-3">组件内部管理，更新会触发重新渲染</td>
                                    </tr>
                                    <tr>
                                        <td class="border p-3 font-medium">用途</td>
                                        <td class="border p-3">配置和定制子组件的外观和行为</td>
                                        <td class="border p-3">管理组件内部随时间变化的数据（如用户输入、计时器、API 响应）</td>
                                    </tr>
                                     <tr>
                                        <td class="border p-3 font-medium">访问方式 (函数组件)</td>
                                        <td class="border p-3">通过函数参数接收 (<code>props</code> 或解构 <code>{ propName }</code>)</td>
                                        <td class="border p-3">通过 <code>useState</code> Hook 返回的数组第一项访问</td>
                                    </tr>
                                     <tr>
                                        <td class="border p-3 font-medium">更新方式 (函数组件)</td>
                                        <td class="border p-3">由父组件重新渲染并传递新的 props</td>
                                        <td class="border p-3">通过 <code>useState</code> Hook 返回的数组第二项 (<code>setState</code> 函数) 更新</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <div class="info-block mt-6">
                            <strong>总结：</strong>可以将 Props 视为组件的配置参数（由外部传入且不可变），而 State 则是组件内部自己维护的状态（可随时间改变）。一个组件应该尽可能地**无状态** (stateless)，只依赖 Props 来渲染。只有当组件需要管理随时间变化且不适合由父组件控制的数据时，才应该使用 State。
                        </div>
                    </div>
                </section>

                <section id="state" class="content-section fade-in-section" style="animation-delay: 0.25s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">tune</span>State (useState Hook)
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">help_outline</span>什么是 State？</h3>
                        <p>State 是组件内部私有的、可变的数据。当 state 发生变化时，React 会自动重新渲染该组件及其子组件以反映这些变化。</p>
                        <p>与 props 不同，state 由组件自身管理。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">construction</span><code>useState</code> Hook 基本用法</h3>
                        <p><code>useState</code> 是 React 提供的一个 Hook，允许你在函数组件中添加和管理 state。</p>
                        <ul>
                            <li>调用 <code>useState(initialState)</code> 来声明一个 state 变量，<code>initialState</code> 是该 state 的初始值。</li>
                            <li>它返回一个包含两个元素的数组：<code>[currentState, setStateFunction]</code>。
                                <ul>
                                    <li><code>currentState</code>: 当前状态的值。</li>
                                    <li><code>setStateFunction</code>: 一个用于更新状态的函数。调用这个函数会<strong class="text-red-600">安排</strong>一次组件的重新渲染。</li>
                                </ul>
                            </li>
                        </ul>
                        <pre><code class="language-javascript">import React, { useState } from 'react';

function Counter() {
  // Declare a state variable named 'count' with an initial value of 0
  const [count, setCount] = useState(0);

  // Event handler to update the count
  const increment = () => {
    // Call setCount to schedule an update
    setCount(count + 1);
    // Note: 'count' variable here still holds the value from the *current* render
    // console.log(count); // Might log the old value
  };

  const decrement = () => {
    // Recommended: Use functional update if the new state depends on the previous state
    setCount(prevCount => prevCount - 1);
  };

  const reset = () => {
      setCount(0); // Set to a specific value
  }

  console.log("Counter component rendered"); // See how often this logs

  return (
    &lt;div className="space-x-2"&gt; {/* Added spacing for buttons */}
      &lt;p className="mb-3"&gt;Current Count: {count}&lt;/p&gt;
      &lt;button onClick={increment} className="button button-primary"&gt;Increment&lt;/button&gt;
      &lt;button onClick={decrement} className="button button-secondary"&gt;Decrement&lt;/button&gt;
      &lt;button onClick={reset} className="button button-danger"&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                        <div class="warning-block">
                            <p><strong><code>useState</code> 注意事项：</strong></p>
                            <ul>
                                <li><strong>Hooks 规则:</strong> 只能在函数组件的<strong class="text-red-600">顶层</strong>调用 Hooks，不能在循环、条件语句或嵌套函数中调用。（详见 Hooks 规则部分）</li>
                                <li><strong>异步更新:</strong> 调用 <code>setState</code> 函数<strong class="text-red-600">不会</strong>立即改变 state 的值，而是安排一次更新。React 可能会将多次 <code>setState</code> 调用合并为一次更新以优化性能。因此，不要依赖当前的 state 值来计算下一个 state（除非使用函数式更新）。</li>
                                <li><strong>函数式更新:</strong> 如果新状态依赖于前一个状态，应使用函数式更新：<code>setState(prevState => newState)</code>。这确保你总是基于最新的状态进行计算。</li>
                                <li><strong>不可直接修改:</strong> 永远不要直接修改 state 变量 (<code>count = count + 1</code> 是错误的)，必须使用 <code>setState</code> 函数来触发更新和重新渲染。</li>
                                <li><strong>对象和数组状态:</strong> 当状态是对象或数组时，更新时需要创建一个新的对象或数组，而不是直接修改原有的。例如：<code>setItems([...items, newItem])</code> 或 <code>setUser({...user, name: newName})</code>。</li>
                            </ul>
                        </div>
                    </div>
                     <div class="quiz-card" id="quiz-state">
                        <div class="quiz-question"><span class="material-icons">quiz</span>State 测验：当调用 `useState` 返回的 `setState` 函数时，会发生什么？</div>
                        <div class="quiz-options">
                            <label class="quiz-option"><input type="radio" name="q_state" value="a"><span>立即同步更新 state 变量的值。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_state" value="b"><span>安排一次组件的重新渲染，并在下次渲染时使用新的 state 值。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_state" value="c"><span>直接修改组件的 props。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_state" value="d"><span>什么也不会发生，除非使用函数式更新。</span></label>
                        </div>
                        <div class="quiz-feedback" id="feedback-q_state"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_state', 'b', this)">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                        <div class="quiz-answer">
                            <p><strong>答案:</strong> B. 安排一次组件的重新渲染，并在下次渲染时使用新的 state 值。</p>
                            <p><strong>解析:</strong> `setState` 函数是异步的。调用它并不会立即改变当前渲染周期中的 state 值，而是告诉 React：“我希望在未来的某个时候将 state 更新为这个新值，请安排一次重新渲染”。React 会在适当的时机（可能会合并多个更新）执行重新渲染，届时组件函数会再次执行，`useState` 会返回更新后的值。</p>
                        </div>
                    </div>
                </section>

                <section id="lifecycle" class="content-section fade-in-section" style="animation-delay: 0.3s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">hourglass_empty</span>生命周期 (useEffect Hook)
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                     <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">bolt</span>什么是副作用 (Side Effects)？</h3>
                        <p>副作用是指在组件渲染过程中执行的、会影响组件外部的操作，或者不能在渲染期间简单完成的操作。常见的副作用包括：</p>
                        <ul>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">public</span>数据获取 (Fetching data from an API)</li>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">subscriptions</span>设置订阅 (Setting up subscriptions, e.g., WebSockets)</li>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">edit_note</span>手动更改 DOM (通常应避免，但有时需要与非 React 库集成)</li>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">timer</span>设置定时器 (Timers)</li>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">biotech</span>日志记录或分析</li>
                        </ul>
                        <p>这些操作不应该直接放在组件的主体代码中执行，因为组件渲染应该是纯粹的（对于相同的输入产生相同的输出），并且可能会发生多次。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">construction</span><code>useEffect</code> Hook 基本用法</h3>
                        <p><code>useEffect</code> 是 React 提供的一个 Hook，用于在函数组件中处理副作用。它允许你在组件渲染完成后执行代码，并且可以选择性地在组件更新或卸载时执行清理操作。</p>
                        <p>语法：<code>useEffect(setupFunction, dependencies?)</code></p>
                        <ul>
                            <li><code>setupFunction</code>: 包含副作用逻辑的函数。这个函数会在 React 更新 DOM 之后异步执行。</li>
                            <li><code>dependencies</code> (可选): 一个数组，包含该 effect 依赖的所有来自组件作用域的值（props, state, context, 甚至函数）。React 会使用 <code>Object.is</code> 比较依赖项数组在每次渲染之间的变化，来决定是否需要跳过执行 <code>setupFunction</code>。</li>
                        </ul>
                         <div class="mermaid">
                            graph TD
                                A[组件渲染 Render] --> B{DOM 更新完成};
                                B --> C{useEffect 执行};
                                C -- "可选: 返回清理函数" --> D(Cleanup Function);
                                E[依赖项变化?] -- Yes --> A;
                                F[组件卸载 Unmount] -- "执行清理函数" --> D;
                                C -- "无清理函数" --> G((Effect 完成));
                                D -- "执行完毕" --> H((Cleanup 完成));

                                subgraph Effect 流程
                                    direction LR
                                    A --- C
                                end
                                subgraph Cleanup 流程
                                    direction LR
                                    E --- D
                                    F --- D
                                end

                                style A fill:#ccf,stroke:#60f
                                style B fill:#eee,stroke:#999
                                style C fill:#cfc,stroke:#090
                                style D fill:#fcc,stroke:#c00
                                style E fill:#ffc,stroke:#c90
                                style F fill:#fcc,stroke:#c00
                         </div>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">sync_alt</span>模拟生命周期行为</h3>
                        <p>通过控制 `dependencies` 数组，可以模拟类组件的生命周期方法：</p>
                        <p><strong>1. 模拟 <code>componentDidMount</code> (仅在挂载后运行一次):</strong></p>
                        <p>传入一个<strong class="text-blue-600">空数组 <code>[]</code></strong> 作为依赖项。Effect 函数只在组件首次渲染后执行一次。</p>
                        <pre><code class="language-javascript">import React, { useState, useEffect } from 'react';

function UserData({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // This effect runs only once after the initial render (component mount)
    console.log('Component mounted! Fetching data...');
    setLoading(true);
    let isCancelled = false; // Flag to prevent state update on unmounted component

    fetch(`https://jsonplaceholder.typicode.com/users/${userId}`) // Example API
      .then(response => response.json())
      .then(data => {
        if (!isCancelled) { // Only update state if component is still mounted
          setUser(data);
          setLoading(false);
        }
      })
      .catch(error => {
        if (!isCancelled) {
          console.error("Error fetching data:", error);
          setLoading(false);
        }
      });

    // Optional: Return a cleanup function (simulates componentWillUnmount)
    return () => {
      console.log('Component will unmount! Cleanup logic here.');
      isCancelled = true; // Set flag on cleanup
    };
  }, []); // Empty dependency array means run once on mount

  if (loading) {
    return &lt;div&gt;Loading user data...&lt;/div&gt;;
  }

  return (
    &lt;div className="info-block"&gt;
      {user ? &lt;strong&gt;Username: {user.name}&lt;/strong&gt; : 'User not found'}
    &lt;/div&gt;
  );
}</code></pre>

                        <p class="mt-4"><strong>2. 模拟 <code>componentDidUpdate</code> (依赖项变化时运行):</strong></p>
                        <p>传入一个包含<strong class="text-blue-600">依赖项的数组 <code>[dep1, dep2]</code></strong>。Effect 函数在首次渲染后执行，并且在<strong class="text-red-600">任何一个依赖项发生变化</strong>后的每次渲染后执行。</p>
                        <pre><code class="language-javascript">// Example within the UserData component above, if userId could change:
useEffect(() => {
  // This effect runs after the initial render AND
  // after every subsequent render IF 'userId' has changed.
  console.log(`Dependency 'userId' changed to: ${userId}. Refetching data...`);
  setLoading(true);
  let isCancelled = false;

  fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
    .then(response => response.json())
    .then(data => { if (!isCancelled) { setUser(data); setLoading(false); } })
    .catch(error => { if (!isCancelled) { console.error("Error:", error); setLoading(false); } });

  // Cleanup function runs before the effect runs again (due to dependency change)
  // and also when the component unmounts.
  return () => {
      console.log('Cleanup before re-running effect due to userId change or unmount.');
      isCancelled = true;
  };
}, [userId]); // Dependency array includes userId
</code></pre>
                        <p><strong>省略依赖项数组:</strong> 如果完全省略第二个参数，Effect 会在<strong class="text-red-600">每次组件渲染后</strong>都执行。这通常应该避免，因为它可能导致不必要的副作用执行和性能问题，甚至无限循环。</p>
                         <pre><code class="language-javascript">// Avoid this unless you specifically need to run on every render
useEffect(() => {
  console.log('Component rendered or updated. This runs VERY often!');
  // If this effect modifies state that causes a re-render, it can lead to infinite loops.
});</code></pre>

                        <p class="mt-4"><strong>3. 模拟 <code>componentWillUnmount</code> (清理副作用):</strong></p>
                        <p>在 <code>setupFunction</code> 中返回一个<strong class="text-blue-600">清理函数 (cleanup function)</strong>。这个清理函数会在以下时机执行：</p>
                        <ul>
                            <li>组件卸载 (unmount) 之前。</li>
                            <li>在下一次 Effect 执行之前（如果依赖项变化导致 Effect 需要重新运行）。</li>
                        </ul>
                        <p>清理函数用于清除上一次 effect 创建的资源，如清除定时器、取消订阅、移除事件监听器等，防止内存泄漏。</p>
                        <pre><code class="language-javascript">useEffect(() => {
  // Example: Setting up an event listener
  const handleScroll = () => console.log('Window scrolled!');
  window.addEventListener('scroll', handleScroll);
  console.log('Scroll listener added.');

  // Return the cleanup function
  return () => {
    console.log('Cleaning up scroll listener.');
    window.removeEventListener('scroll', handleScroll); // Remove the listener
  };
}, []); // Empty array: listener added on mount, removed on unmount
</code></pre>
                    </div>
                     <div class="warning-block">
                        <h3 class="head4 mt-0 mb-2 text-orange-800">useEffect 注意事项 (非常重要)</h3>
                        <ul>
                            <li><strong>依赖项完整性 (Exhaustive Deps):</strong> <strong class="text-red-600">必须</strong>在依赖项数组中包含 effect 内部用到的所有来自组件作用域的值（props, state, context, 函数等）。如果遗漏，effect 可能会捕获到过时的值（闭包陷阱），导致难以调试的 bug。强烈推荐使用 ESLint 的 `react-hooks/exhaustive-deps` 规则来帮助检查。</li>
                            <li><strong>避免无限循环：</strong> 如果 effect 内部调用了会改变其依赖项的 `setState` 函数，并且没有设置好跳出条件，就可能导致无限循环（更新状态 -> 触发 effect -> 更新状态 ...）。确保 effect 的执行条件是明确且会终止的。</li>
                            <li><strong>函数作为依赖项：</strong> 如果 effect 依赖于在组件内部定义的函数，该函数在每次渲染时默认会重新创建（即使函数体没变），这会不必要地触发 effect 重新运行。应该使用 <code>useCallback</code> Hook 来记忆化 (memoize) 这个函数，只有当函数的依赖项改变时才重新创建它。</li>
                             <li><strong>异步操作与清理：</strong> 在 effect 中执行异步操作（如 `fetch`）时，要特别注意组件可能在异步操作完成前就卸载了。需要在清理函数中处理这种情况，例如设置一个标志位，防止在已卸载的组件上调用 `setState`。</li>
                        </ul>
                    </div>
                     <div class="quiz-card" id="quiz-useeffect">
                        <div class="quiz-question"><span class="material-icons">quiz</span>useEffect 测验：如果 `useEffect` 的依赖项数组是空的 `[]`，那么它的副作用函数会在什么时候执行？</div>
                        <div class="quiz-options">
                            <label class="quiz-option"><input type="radio" name="q_useeffect" value="a"><span>每次组件渲染时。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_useeffect" value="b"><span>仅在组件第一次挂载（mount）后执行一次。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_useeffect" value="c"><span>仅在组件卸载（unmount）前执行一次。</span></label>
                            <label class="quiz-option"><input type="radio" name="q_useeffect" value="d"><span>当任何 state 或 prop 改变时。</span></label>
                        </div>
                        <div class="quiz-feedback" id="feedback-q_useeffect"></div>
                        <button class="quiz-toggle button button-secondary mt-4" onclick="checkAnswer('q_useeffect', 'b', this)">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                        <div class="quiz-answer">
                            <p><strong>答案:</strong> B. 仅在组件第一次挂载（mount）后执行一次。</p>
                            <p><strong>解析:</strong> 空的依赖项数组 `[]` 告诉 React，这个 effect 不依赖于任何 props 或 state。因此，它只会在组件首次渲染并挂载到 DOM 后执行一次。如果 effect 返回了清理函数，该清理函数会在组件卸载时执行。</p>
                        </div>
                    </div>
                </section>

                <section id="events" class="content-section fade-in-section" style="animation-delay: 0.35s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">touch_app</span>事件处理
                        <span class="level-tag level-tag-medium">中频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">ads_click</span>绑定事件处理器</h3>
                        <p>在 React 元素上处理事件与处理原生 DOM 事件类似，但有一些语法差异：</p>
                        <ul>
                            <li>React 事件命名采用<strong class="text-blue-600">驼峰命名法 (camelCase)</strong>，例如 <code>onClick</code>, <code>onChange</code>, <code>onSubmit</code>。</li>
                            <li>使用 JSX 语法，你需要传递一个<strong class="text-blue-600">函数引用</strong>作为事件处理函数，而不是一个包含函数调用的字符串。</li>
                        </ul>
                        <pre><code class="language-javascript">import React, { useState } from 'react';

function ButtonHandler() {
  const [message, setMessage] = useState('');

  // Define event handler function
  const handleClick = () => {
    alert('Button was clicked!');
  };

  // Define event handler for input change
  const handleChange = (event) => {
    // 'event' is React's SyntheticEvent object
    setMessage(event.target.value); // Get value from the input element
  };

  return (
    &lt;div&gt;
      {/* Pass the function reference 'handleClick' to onClick */}
      &lt;button onClick={handleClick} className="button button-primary"&gt;
        Click Me
      &lt;/button&gt;

      &lt;input
        type="text"
        value={message} // Controlled component: value driven by state
        onChange={handleChange} // Pass the function reference 'handleChange' to onChange
        placeholder="Type something..."
        className="ml-4 p-2 border rounded border-gray-300 focus:ring-2 focus:ring-blue-300 focus:border-blue-500 outline-none"
      /&gt;
      &lt;p className="mt-2"&gt;You typed: {message}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">gesture</span>事件对象 (SyntheticEvent)</h3>
                        <p>React 会向事件处理函数传递一个<strong class="text-blue-600">合成事件对象 (SyntheticEvent)</strong>。</p>
                        <ul>
                            <li>这是一个跨浏览器包装器，它包装了浏览器的原生事件对象，抹平了浏览器之间的差异。</li>
                            <li>它提供了与原生事件对象相似的接口（如 <code>event.preventDefault()</code>, <code>event.stopPropagation()</code>, <code>event.target</code>, <code>event.type</code>, <code>event.key</code> 等），保证了行为一致性。</li>
                            <li>合成事件对象是<strong class="text-red-600">池化</strong>的。这意味着事件处理函数执行完毕后，事件对象的属性会被置空，以供重用。如果你需要异步访问事件属性，需要调用 <code>event.persist()</code> 或将需要的属性保存到变量中。</li>
                            <li>如果你需要访问底层的原生事件对象，可以使用 <code>event.nativeEvent</code>。</li>
                        </ul>
                        <pre><code class="language-javascript">function FormSubmitHandler() {
  const handleSubmit = (event) => {
    // Prevent the default form submission behavior (page reload)
    event.preventDefault();
    console.log('Form submitted!');
    console.log('Event Type:', event.type); // e.g., "submit"
    console.log('Target Element:', event.target); // The form element
    // console.log('Native Event:', event.nativeEvent); // Access the original browser event

    // Example of accessing properties asynchronously (requires persist or saving)
    // const target = event.target; // Save the property
    // event.persist(); // Or call persist()
    // setTimeout(() => {
    //   console.log('Async access to target:', target); // Works if saved
    //   // console.log('Async access via event.target:', event.target); // Might be null if not persisted
    // }, 100);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;button type="submit" className="button button-secondary"&gt;Submit Form&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">forward_to_inbox</span>向事件处理器传递参数</h3>
                        <p>有时你需要向事件处理函数传递额外的参数（除了事件对象本身）。常见的做法是使用箭头函数或 <code>.bind()</code>。</p>
                        <pre><code class="language-javascript">function ItemList({ items, onDeleteItem }) { // Assume onDeleteItem is passed from parent

  // Handler now accepts the id first, then the event
  const handleDelete = (idToDelete, event) => {
    // 'event' is the SyntheticEvent
    console.log(`Deleting item with ID: ${idToDelete}`);
    console.log('Click event target:', event.target);
    onDeleteItem(idToDelete); // Call the function passed via props
  };

  return (
    &lt;ul&gt;
      {items.map(item => (
        &lt;li key={item.id} className="mb-2 flex justify-between items-center"&gt;
          <span>{item.text}</span>
          {/* Method 1: Arrow function wrapper */}
          {/* Creates a new function on each render, might have performance implications in very large lists */}
          &lt;button
            onClick={(e) => handleDelete(item.id, e)} // Pass item.id and the event 'e'
            className="button button-danger text-xs py-1 px-2"
          &gt;
            Delete (Arrow)
          &lt;/button&gt;

          {/* Method 2: Using .bind() */}
          {/* Also creates a new function on each render */}
          {/* &lt;button
            onClick={handleDelete.bind(null, item.id)} // Binds item.id as the first argument
            className="button button-danger text-xs py-1 px-2"
          &gt;
            Delete (Bind)
          &lt;/button&gt; */}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>
                        <div class="info-block">
                            <strong>性能考虑：</strong> 在 <code>.map()</code> 中直接使用箭头函数或 <code>.bind()</code> 会在每次渲染时都创建一个新的函数实例。对于非常大的列表或频繁更新的组件，这可能带来性能开销。更优化的方式通常涉及将处理函数定义在循环外部，并通过 data-* 属性或闭包等方式获取所需参数，或者使用事件委托。但在大多数情况下，上述方法的简洁性优先。
                        </div>
                    </div>
                </section>

                 <section id="controlled-uncontrolled" class="content-section fade-in-section" style="animation-delay: 0.4s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">rule</span>受控组件与非受控组件
                        <span class="level-tag level-tag-medium">中频基础</span>
                    </h2>
                    <p>在处理表单元素（如 <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, <code>&lt;select&gt;</code>）时，React 提供了两种主要的方式来管理表单数据：受控组件和非受控组件。</p>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">tune</span>受控组件 (Controlled Components)</h3>
                        <p>在受控组件中，表单元素的值<strong class="text-blue-600">完全由 React 的 state 控制</strong>。</p>
                        <ul>
                            <li>表单元素的 <code>value</code> (或 <code>checked</code> for checkboxes/radios) 属性绑定到 React state。</li>
                            <li>通过 <code>onChange</code> 事件处理器来更新 React state。每当用户输入时，<code>onChange</code> 触发，更新 state，然后组件重新渲染，将更新后的 state 值赋回给表单元素的 <code>value</code>。</li>
                        </ul>
                        <pre><code class="language-javascript">import React, { useState } from 'react';

function ControlledInput() {
  const [name, setName] = useState(''); // State controls the input value

  const handleChange = (event) => {
    setName(event.target.value); // Update state on every change
  };

  const handleSubmit = (event) => {
      event.preventDefault();
      alert(`A name was submitted: ${name}`);
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label htmlFor="nameInput"&gt;Name (Controlled): &lt;/label&gt;
      &lt;input
        id="nameInput"
        type="text"
        value={name}       {/* Value is driven by state */}
        onChange={handleChange} {/* State is updated on change */}
        className="p-2 border rounded border-gray-300 focus:ring-2 focus:ring-blue-300 focus:border-blue-500 outline-none"
      /&gt;
      &lt;button type="submit" className="button button-primary ml-2"&gt;Submit&lt;/button&gt;
      &lt;p&gt;Current value in state: {name}&lt;/p&gt;
    &lt;/form&gt;
  );
}</code></pre>
                        <p><strong>优点：</strong></p>
                        <ul>
                            <li>数据来源单一且明确（React state）。</li>
                            <li>易于实现即时验证、格式化输入、禁用提交按钮等逻辑。</li>
                            <li>React state 始终持有最新的表单值。</li>
                        </ul>
                        <p><strong>缺点：</strong></p>
                        <ul>
                            <li>需要为每个表单元素编写 <code>onChange</code> 处理器和 state。</li>
                        </ul>
                        <p><strong>受控组件是 React 中处理表单的推荐方式。</strong></p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">do_not_disturb_on</span>非受控组件 (Uncontrolled Components)</h3>
                        <p>在非受控组件中，表单数据<strong class="text-blue-600">由 DOM 自身处理</strong>。React 不直接控制表单元素的值。</p>
                        <ul>
                            <li>不设置表单元素的 <code>value</code> 属性（或使用 <code>defaultValue</code>/<code>defaultChecked</code> 设置初始值）。</li>
                            <li>需要时，使用 <strong class="text-red-600">Refs</strong> 来直接从 DOM 中读取表单元素的值。</li>
                        </ul>
                        <pre><code class="language-javascript">import React, { useRef } from 'react';

function UncontrolledInput() {
  const inputRef = useRef(null); // Ref to access the DOM node

   const handleSubmit = (event) => {
      event.preventDefault();
      // Read the value directly from the DOM node via ref
      alert(`A name was submitted: ${inputRef.current.value}`);
  }

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label htmlFor="nameUncontrolled"&gt;Name (Uncontrolled): &lt;/label&gt;
      &lt;input
        id="nameUncontrolled"
        type="text"
        ref={inputRef}       {/* Attach ref */}
        defaultValue="Initial Value" {/* Optional: Set initial value */}
        className="p-2 border rounded border-gray-300 focus:ring-2 focus:ring-blue-300 focus:border-blue-500 outline-none"
      /&gt;
      {/* No onChange handler needed to manage value */}
      &lt;button type="submit" className="button button-primary ml-2"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                        <p><strong>优点：</strong></p>
                        <ul>
                            <li>代码可能更简洁，尤其是对于简单表单或集成非 React 代码时。</li>
                            <li>文件输入 <code>&lt;input type="file" /&gt;</code> 始终是非受控的。</li>
                        </ul>
                        <p><strong>缺点：</strong></p>
                        <ul>
                            <li>难以实现即时验证或格式化。</li>
                            <li>需要命令式地通过 Ref 读取值，不如受控组件声明式。</li>
                        </ul>
                        <p>非受控组件在某些场景下有用，但通常推荐使用受控组件来获得更好的可预测性和控制力。</p>
                    </div>
                </section>

                <section id="refs" class="content-section fade-in-section" style="animation-delay: 0.45s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">attachment</span>Refs (useRef Hook)
                        <span class="level-tag level-tag-medium">中频基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">help_outline</span>什么是 Refs？</h3>
                        <p>Refs 提供了一种方式，允许我们访问渲染输出中的 DOM 节点或 React 元素实例。</p>
                        <p>在典型的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。然而，有些情况下你需要<strong class="text-blue-600">命令式地</strong>修改子组件或访问 DOM 节点，这时就需要使用 Refs。</p>
                        <p>常见的 Refs 使用场景：</p>
                        <ul>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">adjust</span>管理焦点 (focus)、文本选择或媒体（如 video, audio）播放控制。</li>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">animation</span>触发命令式动画。</li>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">integration_instructions</span>集成需要直接访问 DOM 的第三方库。</li>
                            <li><span class="material-icons text-sm mr-1 text-gray-500">calculate</span>测量 DOM 节点的大小或位置。</li>
                        </ul>
                        <div class="warning-block">
                            <p><strong>注意：</strong>应避免过度使用 Refs 来做可以通过声明式方式（Props 和 State）完成的事情。例如，不要用 Ref 来显示或隐藏一个元素，应该使用条件渲染。</p>
                        </div>
                    </div>
                    <div class="content-card">
                        <h3 class="head3 flex items-center gap-2"><span class="material-icons text-lg text-blue-600">construction</span><code>useRef</code> Hook 基本用法</h3>
                        <p><code>useRef</code> 是 React 提供的一个 Hook，用于在函数组件中创建和管理 Refs。</p>
                        <p><code>useRef(initialValue)</code> 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数 (<code>initialValue</code>)。返回的 <code>ref</code> 对象在组件的整个生命周期内保持不变。</p>

                        <p class="mt-4"><strong>用途 1: 访问 DOM 元素</strong></p>
                        <p>将 <code>ref</code> 对象附加到 JSX 元素的 <code>ref</code> 属性上，React 会在 DOM 节点挂载后将该节点赋值给 <code>ref.current</code>，并在卸载时将其设回 <code>null</code>。</p>
                        <pre><code class="language-javascript">import React, { useRef, useEffect } from 'react';

function FocusInput() {
  // 1. Create a ref object (initial value null for DOM refs)
  const inputRef = useRef(null);

  useEffect(() => {
    // 3. After the component mounts, access the DOM node via ref.current
    //    and call the focus() method.
    if (inputRef.current) {
      inputRef.current.focus();
      console.log('Input focused using ref!');
      console.log('Input DOM node:', inputRef.current); // Logs the <input> element
    }
    // Cleanup function is not strictly necessary here,
    // as React handles setting ref.current to null on unmount.
  }, []); // Empty dependency array ensures this runs only on mount

  return (
    &lt;div&gt;
      &lt;label htmlFor="myInput"&gt;Focus on load: &lt;/label&gt;
      {/* 2. Attach the ref object to the input element's ref attribute */}
      &lt;input
        ref={inputRef}
        id="myInput"
        type="text"
        className="ml-2 p-2 border rounded border-gray-300 focus:ring-2 focus:ring-blue-300 focus:border-blue-500 outline-none"
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                        <p class="mt-4"><strong>用途 2: 存储可变值 (不触发重新渲染)</strong></p>
                        <p><code>useRef</code> 也可以用来存储任何可变值，其行为类似于类组件中的实例属性。关键在于：<strong class="text-red-600">修改 <code>ref.current</code> 的值不会触发组件的重新渲染</strong>。这使得它适合存储那些不需要反映在 UI 上，但需要在多次渲染之间保持不变的值，例如定时器 ID、之前的 state/props 值等。</p>
                        <pre><code class="language-javascript">import React, { useState, useRef, useEffect } from 'react';

function TimerWithRef() {
  const [count, setCount] = useState(0);
  // Use ref to store the interval ID
  const intervalRef = useRef(null); // Initialize with null

  useEffect(() => {
    // Start the timer and store its ID in ref.current
    // Modifying ref.current here does NOT cause a re-render
    intervalRef.current = setInterval(() => {
      setCount(prevCount => prevCount + 1); // Updating state *does* cause re-render
    }, 1000);
    console.log('Timer started, ID stored in ref:', intervalRef.current);

    // Cleanup function: clear the interval when the component unmounts
    return () => {
      console.log('Clearing timer with ID from ref:', intervalRef.current);
      clearInterval(intervalRef.current); // Access the ID via ref.current
    };
  }, []); // Run only on mount and unmount

  const stopTimer = () => {
    console.log('Stopping timer with ID from ref:', intervalRef.current);
    clearInterval(intervalRef.current); // Access the ID via ref.current to stop
     // Modifying ref.current here also does NOT cause a re-render
     // intervalRef.current = null; // Optionally reset the ref
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Timer Count: {count}&lt;/p&gt;
      &lt;button onClick={stopTimer} className="button button-danger"&gt;Stop Timer&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
                        <p>在这个例子中，<code>intervalRef.current</code> 的变化不会导致 <code>TimerWithRef</code> 组件重新渲染，但它允许我们在组件的不同部分（effect 和事件处理器）之间共享和访问 interval ID。</p>
                    </div>
                </section>

                 <section id="hooks-rules" class="content-section fade-in-section" style="animation-delay: 0.5s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">gavel</span>Hooks 规则
                        <span class="level-tag level-tag-high">高频基础</span>
                    </h2>
                    <div class="content-card">
                         <p>Hooks (如 <code>useState</code>, <code>useEffect</code>, <code>useRef</code> 等) 是强大的工具，但必须遵循两条简单的规则，以确保它们能正常工作：</p>
                         <div class="warning-block">
                            <h3 class="head4 mt-0 mb-2 text-orange-800"><span class="material-icons text-lg mr-1">error_outline</span>规则 1: 只在顶层调用 Hooks (Only Call Hooks at the Top Level)</h3>
                            <p><strong>不要</strong>在循环、条件判断或嵌套函数中调用 Hooks。必须始终在你的 React 函数组件的<strong class="text-red-600">顶层</strong>调用它们。</p>
                            <p><strong>原因：</strong>React 依赖于 Hooks 的<strong class="text-red-600">调用顺序</strong>在每次渲染时保持一致，以此来正确地将 state 和 effect 与对应的 Hook 调用关联起来。如果在条件或循环中调用，顺序可能会改变，导致状态错乱或 effect 行为异常。</p>
                            <pre><code class="language-javascript">// 错误 ❌: 在条件语句中调用 useState
function ConditionalState({ condition }) {
  if (condition) {
    const [state, setState] = useState(0); // 错误！
  }
  // ...
}

// 正确 ✅: 始终在顶层调用，在 effect 或事件处理中使用条件逻辑
function CorrectConditionalState({ condition }) {
  const [state, setState] = useState(0);
  useEffect(() => {
    if (condition) {
      // 在 effect 内部使用条件逻辑
      console.log("Condition is true, state is", state);
    }
  }, [condition, state]); // 包含依赖项
  // ...
}</code></pre>
                         </div>
                         <div class="warning-block mt-6">
                            <h3 class="head4 mt-0 mb-2 text-orange-800"><span class="material-icons text-lg mr-1">error_outline</span>规则 2: 只在 React 函数中调用 Hooks (Only Call Hooks from React Functions)</h3>
                            <p><strong>不要</strong>在普通的 JavaScript 函数中调用 Hooks。</p>
                            <p>你只能在以下两种地方调用 Hooks：</p>
                            <ul>
                                <li>✅ <strong class="text-green-600">React 函数组件</strong> 的内部。</li>
                                <li>✅ <strong class="text-green-600">自定义 Hooks</strong> (Custom Hooks) 的内部（自定义 Hook 本身也是以 "use" 开头的函数）。</li>
                            </ul>
                             <pre><code class="language-javascript">// 错误 ❌: 在普通 JS 函数中调用 Hook
function regularFunction() {
  const [count, setCount] = useState(0); // 错误！
}

// 正确 ✅: 在 React 函数组件中调用
function MyComponent() {
  const [count, setCount] = useState(0); // 正确
  // ...
  return &lt;div&gt;{count}&lt;/div&gt;;
}

// 正确 ✅: 在自定义 Hook 中调用
function useCounter(initialValue) {
  const [count, setCount] = useState(initialValue); // 正确
  // ... (可以包含其他 Hooks)
  return [count, setCount];
}</code></pre>
                         </div>
                         <p class="mt-6">遵循这些规则可以确保 React 正确地管理组件的状态和副作用。ESLint 插件 (<code>eslint-plugin-react-hooks</code>) 可以帮助自动检查并强制执行这些规则。</p>
                    </div>
                </section>

            </article>
        </main>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Initialize Mermaid ---
             try {
                 mermaid.initialize({ startOnLoad: true, theme: 'neutral' });
                 // Force re-render if needed after initial load, sometimes helps complex diagrams
                 // setTimeout(() => mermaid.run(), 100);
             } catch (e) {
                 console.error("Mermaid initialization error:", e);
             }


            // --- TOC Highlighting Logic ---
            const sections = document.querySelectorAll('main section[id]');
            const tocLinks = document.querySelectorAll('#local-toc a');
            let lastActiveTocLink = null;

            const observerOptions = {
                root: null, // viewport
                rootMargin: '-20% 0px -60% 0px', // Adjust margins to prioritize top sections
                threshold: 0 // Trigger as soon as any part enters/leaves margin
            };

            const observerCallback = (entries) => {
                let bestVisibleEntry = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (!bestVisibleEntry || entry.boundingClientRect.top < bestVisibleEntry.boundingClientRect.top) {
                            bestVisibleEntry = entry;
                        }
                    }
                });

                if (bestVisibleEntry) {
                    const id = bestVisibleEntry.target.getAttribute('id');
                    // Try to find a link matching the section ID directly
                    let activeLink = document.querySelector(`#local-toc a[href="#${id}"]`);

                    // If not found, check if it's a sub-section (like controlled-uncontrolled under events)
                    // This logic might need refinement based on your exact TOC structure
                    if (!activeLink) {
                         const parentSectionLink = document.querySelector(`#local-toc a[href="#${id.split('-')[0]}"]`); // Crude parent guess
                         if (parentSectionLink) {
                             // Maybe highlight the parent? Or find the specific sub-link if structured differently
                             // For now, let's try highlighting the parent if sub-link isn't directly matched
                             // activeLink = parentSectionLink;
                         }
                    }


                    if (activeLink && activeLink !== lastActiveTocLink) {
                        if (lastActiveTocLink) {
                            lastActiveTocLink.classList.remove('active');
                        }
                        activeLink.classList.add('active');
                        lastActiveTocLink = activeLink;
                    }
                }
            };

            const observer = new IntersectionObserver(observerCallback, observerOptions);
            sections.forEach(section => observer.observe(section));

            // Initial active link check
            const currentHash = window.location.hash;
             if (currentHash) {
                 const initialActiveLink = document.querySelector(`#local-toc a[href="${currentHash}"]`);
                 if (initialActiveLink) {
                     tocLinks.forEach(link => link.classList.remove('active'));
                     initialActiveLink.classList.add('active');
                     lastActiveTocLink = initialActiveLink;
                 }
             } else if (tocLinks.length > 0 && !lastActiveTocLink) {
                 tocLinks.forEach(link => link.classList.remove('active'));
                 tocLinks[0].classList.add('active');
                 lastActiveTocLink = tocLinks[0];
             }

            // --- Fade-in Animation Logic ---
            const mainContentSections = document.querySelectorAll('main > article > section.content-section');
            const fadeObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
            const fadeObserverCallback = (entries, observer) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const delayIndex = Array.from(mainContentSections).indexOf(entry.target);
                        entry.target.style.animationDelay = `${delayIndex * 0.05}s`;
                        entry.target.classList.add('fade-in-section');
                        observer.unobserve(entry.target);
                    }
                });
            };
            const fadeObserver = new IntersectionObserver(fadeObserverCallback, fadeObserverOptions);
            mainContentSections.forEach(section => fadeObserver.observe(section));

            // --- Ripple Effect Logic ---
            function createRipple(event) {
                const button = event.currentTarget;
                if (!button || typeof button.getBoundingClientRect !== 'function') return;

                // Create ripple element
                const circle = document.createElement("span");
                const diameter = Math.max(button.clientWidth, button.clientHeight);
                const radius = diameter / 2;

                // Get primary color RGB from CSS variable for opacity
                const primaryColorRgb = getComputedStyle(document.documentElement)
                                        .getPropertyValue('--primary-color-rgb') // Assuming you define --primary-color-rgb: 59, 130, 246; in :root
                                        || '59, 130, 246'; // Fallback

                // Style and position ripple
                circle.style.width = circle.style.height = `${diameter}px`;
                const rect = button.getBoundingClientRect();
                circle.style.left = `${event.clientX - rect.left - radius}px`;
                circle.style.top = `${event.clientY - rect.top - radius}px`;
                circle.style.backgroundColor = `rgba(${primaryColorRgb}, 0.4)`; // Use RGB with alpha
                circle.classList.add("ripple"); // Add class for animation

                // Remove existing ripple before adding new one
                const existingRipple = button.querySelector(".ripple");
                if (existingRipple) {
                    existingRipple.remove();
                }

                // Add ripple and set timeout for removal
                button.appendChild(circle);
                setTimeout(() => circle.remove(), 600); // Match animation duration
            }

            // --- Quiz Toggle Logic ---
            function toggleAnswer(quizId, buttonElement) {
                const quizCard = document.getElementById(quizId);
                if (!quizCard) return;
                const answer = quizCard.querySelector('.quiz-answer');
                const icon = buttonElement.querySelector('.icon-arrow');
                const buttonTextSpan = buttonElement.querySelector('.button-text');
                if (!answer || !icon || !buttonTextSpan) return;

                const isVisible = answer.classList.contains('visible');

                if (isVisible) {
                    // Start hiding
                    answer.style.maxHeight = '0';
                    answer.style.opacity = '0';
                    answer.style.marginTop = '0';
                    answer.style.paddingTop = '0';
                    answer.style.paddingBottom = '0';
                    answer.classList.remove('visible');
                    icon.classList.remove('rotated');
                    buttonTextSpan.textContent = '检查答案'; // Or '显示答案' if separate toggle

                    // Use transitionend event for cleanup (more reliable than timeout)
                    answer.addEventListener('transitionend', function handler() {
                        if (!answer.classList.contains('visible')) { // Check again in case toggled quickly
                             answer.style.display = 'none';
                        }
                         answer.removeEventListener('transitionend', handler);
                    }, { once: true });

                } else {
                    // Start showing
                    answer.style.display = 'block'; // Make it visible to measure scrollHeight
                    const scrollHeight = answer.scrollHeight; // Get full height

                    // Force reflow before applying transition changes
                    requestAnimationFrame(() => {
                        answer.style.maxHeight = scrollHeight + 'px';
                        answer.style.opacity = '1';
                        answer.style.marginTop = '1rem';
                        answer.style.paddingTop = '1rem';
                        answer.style.paddingBottom = '1rem';
                        answer.classList.add('visible');
                        icon.classList.add('rotated');
                        buttonTextSpan.textContent = '隐藏答案';
                    });
                }
            }

            // --- Quiz Check Answer Logic (Global Function) ---
            window.checkAnswer = function(questionName, correctAnswerValue, buttonElement) {
                const options = document.querySelectorAll(`input[name="${questionName}"]`);
                const feedbackElement = document.getElementById(`feedback-${questionName}`);
                const quizCard = feedbackElement ? feedbackElement.closest('.quiz-card') : null;
                let selectedValue = null;
                let selectedLabel = null;

                if (!feedbackElement || !quizCard) return;

                // Reset previous styles
                quizCard.querySelectorAll('.quiz-option').forEach(opt => opt.classList.remove('selected', 'correct', 'incorrect'));

                // Find selected option
                options.forEach(option => {
                    if (option.checked) {
                        selectedValue = option.value;
                        selectedLabel = option.closest('.quiz-option');
                        if (selectedLabel) selectedLabel.classList.add('selected');
                    }
                });

                // Provide feedback if no option selected
                if (!selectedValue) {
                    feedbackElement.textContent = "请选择一个选项！";
                    feedbackElement.className = 'quiz-feedback warning';
                    feedbackElement.style.display = 'block';
                    return; // Stop processing
                }

                // Find the correct answer label
                let correctAnswerLabel = null;
                options.forEach(opt => { if (opt.value === correctAnswerValue) correctAnswerLabel = opt.closest('.quiz-option'); });

                // Display feedback and style options
                if (selectedValue === correctAnswerValue) {
                    feedbackElement.textContent = "回答正确！";
                    feedbackElement.className = 'quiz-feedback correct';
                    if(selectedLabel) selectedLabel.classList.add('correct');
                } else {
                    let correctAnswerText = '';
                    if (correctAnswerLabel) {
                        correctAnswerText = correctAnswerLabel.querySelector('span')?.textContent || `选项 ${correctAnswerValue}`;
                        correctAnswerLabel.classList.add('correct'); // Highlight correct answer as well
                    }
                    feedbackElement.textContent = `回答错误。正确答案是: "${correctAnswerText}"`;
                    feedbackElement.className = 'quiz-feedback incorrect';
                    if(selectedLabel) selectedLabel.classList.add('incorrect');
                }
                feedbackElement.style.display = 'block';

                // Toggle the answer visibility using the passed button element
                toggleAnswer(quizCard.id, buttonElement);
            }

            // Add ripple effect to all quiz toggle buttons
             document.querySelectorAll('.quiz-toggle').forEach(button => {
                 button.addEventListener('click', createRipple);
             });

            // Add ripple effect to other buttons if needed (e.g., form submit)
            document.querySelectorAll('.button:not(.quiz-toggle)').forEach(button => {
                 button.addEventListener('click', createRipple);
            });


        });
    </script>

</body>

</html>
