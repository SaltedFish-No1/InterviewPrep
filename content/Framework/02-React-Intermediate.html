<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React 进阶概念</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="../../global.css"> <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <style>
        /* Minimal inline styles - Primarily rely on global.css and Tailwind */

        /* --- Base & Layout Adjustments --- */
        html {
            scroll-padding-top: 6rem; /* Adjust based on potential sticky header */
        }

        body {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
            background-color: var(--bg-color-lighter, #f3f4f6);
            color: var(--text-color-default, #374151); /* Ensure default text color */
        }

        /* --- Typography & Content Adjustments --- */
        h1, h2, h3, h4, h5, h6 {
            scroll-margin-top: 6rem;
        }

        h2 { /* Add bottom border and adjust margin */
            border-bottom: 1px solid var(--border-color-light, #e5e7eb);
            padding-bottom: 0.5rem; /* pb-2 */
            margin-bottom: 2rem; /* Increased margin mb-8 */
        }
        h3.head3 { /* Ensure consistent margin below H3 in cards */
             margin-bottom: 1rem; /* mb-4 */
        }

        /* Improve paragraph spacing */
        p {
            margin-bottom: 1rem; /* mb-4 */
            line-height: var(--base-line-height, 1.65); /* Ensure consistent line height */
        }
        p:last-child {
            margin-bottom: 0; /* Remove margin from last paragraph in a block */
        }
        ul, ol { /* Add margin below lists */
            margin-bottom: 1rem; /* mb-4 */
        }
        ul:last-child, ol:last-child {
             margin-bottom: 0;
        }
        /* Adjust list item spacing */
        li {
            margin-bottom: 0.5rem; /* mb-2 */
        }


        /* Style for frequency/level tags */
        .level-tag {
            display: inline-block;
            margin-left: 0.5rem;
            font-size: 0.75rem;
            font-weight: 500;
            padding: 0.1rem 0.5rem;
            border-radius: 0.25rem;
            vertical-align: middle;
            border: 1px solid transparent;
        }
        .level-tag-low {
            background-color: var(--secondary-color-light, #ecfdf5);
            color: var(--secondary-color, #10b981);
            border-color: var(--secondary-color, #10b981);
        }
        .level-tag-base {
            background-color: var(--bg-color-lighter, #f3f4f6);
            color: var(--text-color-light, #6b7280);
            border-color: var(--border-color-default, #d1d5db);
        }

        /* --- Code Block Styling --- */
        pre[class*="language-"] {
             margin-top: 1rem;
             margin-bottom: 1.5rem; /* Increased margin mb-6 */
             max-height: 400px;
             overflow: auto;
             border-radius: var(--card-border-radius, 0.5rem); /* Use card radius */
             border: 1px solid var(--border-color-light, #e5e7eb); /* Add subtle border */
        }

        /* --- Card Styling Refinements --- */
        .content-card {
            background-color: var(--bg-color-white, white);
            border-radius: var(--card-border-radius, 0.75rem); /* Softer radius (rounded-xl) */
            box-shadow: var(--card-shadow-default, 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)); /* Tailwind shadow-md */
            padding: var(--card-padding, 1.5rem); /* p-6 */
            margin-bottom: 2rem; /* Increased spacing mb-8 */
            border: 1px solid var(--border-color-light, #e5e7eb); /* Subtle border */
            transition: box-shadow 0.2s ease-in-out;
        }
        .content-card:hover {
             box-shadow: var(--card-shadow-hover, 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)); /* Tailwind shadow-lg */
        }
        /* Ensure last card in a section doesn't have bottom margin */
        .content-section > .content-card:last-child {
            margin-bottom: 0;
        }


        /* --- Fade-in Animation --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-section {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* --- Mermaid Diagram Styling --- */
        .mermaid {
            margin-top: 1.5rem; /* mt-6 */
            margin-bottom: 1.5rem; /* mb-6 */
            text-align: center;
            background-color: var(--bg-color-light, #f9fafb);
            padding: 1rem; /* p-4 */
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid var(--border-color-light, #e5e7eb);
        }
        .mermaid svg { max-width: 100%; height: auto; display: block; margin: auto; }

        /* --- Tooltip Styling (Adapted from example.html) --- */
        .tooltip-term {
            border-bottom: 1px dotted var(--primary-color, #3b82f6);
            cursor: help;
            position: relative;
            color: var(--primary-color-dark, #2563eb);
            font-weight: 500; /* font-medium */
        }
        .tooltip-term::before { /* Tooltip text box */
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px); /* Position above */
            background-color: rgba(31, 41, 55, 0.9); /* bg-gray-800 with opacity */
            color: white;
            padding: 0.4rem 0.75rem; /* p-1.5 px-3 approx */
            border-radius: 4px; /* rounded-sm */
            font-size: 0.8rem; /* text-xs */
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }
        .tooltip-term::after { /* Tooltip arrow */
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(0px); /* Position arrow base */
            border-width: 5px;
            border-style: solid;
            border-color: rgba(31, 41, 55, 0.9) transparent transparent transparent; /* Arrow pointing down */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            z-index: 10;
        }
        .tooltip-term:hover::before,
        .tooltip-term:hover::after {
            opacity: 1;
            visibility: visible;
        }

        /* --- Quiz Card Styling (Adapted from example.html & global.css) --- */
        /* Use .quiz-card styles from global.css if available, otherwise define here */
        .quiz-card {
            background-color: var(--quiz-bg, var(--primary-color-light, #eff6ff));
            border: 1px solid var(--border-color-default, #d1d5db);
            border-left: 4px solid var(--quiz-border-color, var(--primary-color, #3b82f6));
            border-radius: 0.5rem; /* rounded-lg */
            padding: var(--quiz-padding, 1.5rem); /* p-6 */
            margin-top: 2rem; /* Add margin above quiz card mt-8 */
            box-shadow: var(--card-shadow-default, 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1));
        }
        .quiz-question {
            font-size: 1.1rem; /* text-lg */
            font-weight: 500; /* font-medium */
            color: var(--text-color-dark, #1f2937);
            margin-bottom: 1.25rem; /* mb-5 */
            display: flex;
            align-items: center;
        }
        .quiz-question .material-icons {
            margin-right: 0.5rem; /* mr-2 */
            color: var(--primary-color-dark, #2563eb);
        }
        .quiz-options {
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* space-y-3 approx */
            margin-bottom: 1.25rem; /* mb-5 */
        }
        .quiz-option {
            display: flex; /* Use flex for alignment */
            align-items: center;
            padding: 0.75rem 1rem; /* p-3 px-4 */
            border: 1px solid var(--border-color-default, #d1d5db);
            border-radius: 0.375rem; /* rounded-md */
            background-color: var(--bg-color-white, white);
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .quiz-option:hover {
            background-color: var(--quiz-option-hover-bg, rgba(59, 130, 246, 0.1));
            border-color: var(--primary-color, #3b82f6);
        }
        .quiz-option input[type="radio"] {
            margin-right: 0.75rem; /* mr-3 */
            width: 1rem; /* w-4 */
            height: 1rem; /* h-4 */
            accent-color: var(--primary-color, #3b82f6);
            cursor: pointer;
            flex-shrink: 0; /* Prevent radio button from shrinking */
        }
        .quiz-option span { /* Text label */
             flex-grow: 1;
             color: var(--text-color-default, #374151);
             font-size: 0.875rem; /* text-sm */
        }
        .quiz-option.selected {
            border-color: var(--primary-color, #3b82f6);
            background-color: rgba(59, 130, 246, 0.15);
        }
         .quiz-option.correct {
             border-color: var(--success-color, #10b981);
             background-color: var(--success-color-light, #ecfdf5);
         }
         .quiz-option.incorrect {
             border-color: var(--danger-color, #ef4444);
             background-color: var(--danger-color-light, #fee2e2);
         }
        .quiz-feedback {
            margin-top: 1rem; /* mt-4 */
            padding: 0.75rem 1rem; /* p-3 px-4 */
            border-radius: 0.375rem; /* rounded-md */
            font-size: 0.875rem; /* text-sm */
            font-weight: 500; /* font-medium */
            display: none; /* Initially hidden */
        }
        .quiz-feedback.correct {
            background-color: var(--quiz-feedback-correct-bg, var(--success-color-light, #ecfdf5));
            color: var(--quiz-feedback-correct-text, var(--success-color, #10b981));
            border: 1px solid var(--success-color, #10b981);
        }
        .quiz-feedback.incorrect {
            background-color: var(--quiz-feedback-incorrect-bg, var(--danger-color-light, #fee2e2));
            color: var(--quiz-feedback-incorrect-text, var(--danger-color, #ef4444));
            border: 1px solid var(--danger-color, #ef4444);
        }
         .quiz-feedback.warning {
             background-color: var(--warning-color-light, #fff7ed);
             color: var(--warning-color, #f97316);
             border: 1px solid var(--warning-color, #f97316);
         }
        .quiz-toggle { /* Button to check/show answer */
            /* Use button styles from global.css */
            margin-top: 1rem; /* mt-4 */
            position: relative; /* For ripple */
            overflow: hidden; /* For ripple */
        }
        .quiz-toggle .material-icons { /* Arrow icon */
            font-size: 1.1rem;
            transition: transform 0.3s ease-in-out;
            margin-right: 0.25rem; /* Add space between icon and text */
        }
        .quiz-toggle .icon-arrow.rotated {
            transform: rotate(180deg);
        }
        .quiz-answer { /* Collapsible answer section */
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, opacity 0.5s ease-in-out, padding-top 0.5s ease-in-out, padding-bottom 0.5s ease-in-out, margin-top 0.5s ease-in-out;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: 0;
            border: 1px solid var(--border-color-default, #d1d5db);
            background-color: var(--bg-color-lighter, #f3f4f6);
            border-radius: 0.375rem; /* rounded-md */
            color: var(--text-color-default, #374151);
            font-size: 0.875rem; /* text-sm */
        }
        .quiz-answer.visible {
            max-height: 1000px; /* Large enough for content */
            opacity: 1;
            padding-top: 1rem; /* p-4 */
            padding-bottom: 1rem; /* p-4 */
            margin-top: 1rem; /* mt-4 */
            overflow: auto; /* Allow scrolling if needed */
        }
        .quiz-answer p { margin-bottom: 0.5rem; } /* Adjust paragraph spacing inside answer */
        .quiz-answer p:last-child { margin-bottom: 0; }
        .quiz-answer strong { font-weight: 600; } /* font-semibold */

        /* Ripple Effect (Adapted from example.html) */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(var(--primary-color-rgb, 59, 130, 246), 0.4); /* Use RGB var or fallback */
            transform: scale(0);
            animation: ripple-animation 0.6s linear;
            pointer-events: none;
        }
        @keyframes ripple-animation {
            to {
                transform: scale(4);
                opacity: 0;
            }
        }


    </style>
</head>

<body class="bg-gray-100">
    <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">React 进阶</h4>
            <ul id="local-toc">
                <li><a href="#intro" class="active"><span class="material-icons nav-icon">category</span>简介</a></li>
                <li><a href="#context-api"><span class="material-icons nav-icon">account_tree</span>Context API</a></li>
                <li><a href="#common-hooks"><span class="material-icons nav-icon">construction</span>常用 Hooks</a></li>
                <li><a href="#virtual-dom"><span class="material-icons nav-icon">view_quilt</span>虚拟 DOM</a></li>
                <li><a href="#state-management"><span class="material-icons nav-icon">sync_alt</span>状态管理库</a></li>
            </ul>
            <a href="../../index.html" class="back-link"> &larr; 返回大纲目录
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="intro" class="content-section fade-in-section" style="animation-delay: 0s;">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-icons text-3xl text-blue-600">auto_awesome</span>(二) React 进阶概念 (了解)
                    </h1>
                    <p>本部分涵盖了一些 React 的进阶概念。虽然在面试中可能被标记为“低频”或“基础”，但理解这些概念有助于深入掌握 React 的工作原理，并在特定场景下编写更高效、更可维护的代码。</p>
                    <p class="mt-4 bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md text-sm">💡
                        <strong>提示:</strong> 点击左侧导航可以快速跳转到相应主题。代码块支持语法高亮。部分概念后附有小测验和关键术语提示。
                    </p>
                </section>

                <section id="context-api" class="content-section fade-in-section" style="animation-delay: 0.05s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">account_tree</span>Context API
                        <span class="level-tag level-tag-low">低频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">基本概念</h3>
                        <p>Context API 提供了一种在组件树中共享数据的方式，而无需显式地通过 props 逐层传递。</p>
                        <ul class="list-disc list-inside space-y-3 mt-4 text-sm text-gray-700">
                            <li><strong><code>React.createContext(defaultValue)</code>:</strong> 创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，它将从组件树中离自身最近的那个匹配的 <code>Provider</code> 中读取当前的 context 值。如果上层没有匹配的 Provider，则会使用 <code>defaultValue</code>。</li>
                            <li><strong><code>Context.Provider</code>:</strong> Provider 组件接收一个 <code>value</code> 属性，并将其传递给消费组件。一个 Provider 可以被嵌套，以覆盖组件树内更深层次的值。所有消费组件都会在 Provider 的 <code>value</code> 属性发生变化时重新渲染。</li>
                            <li><strong><code>useContext(MyContext)</code>:</strong> 这是消费 Context 值的最常用方式（在函数组件中）。它接收 Context 对象（<code>React.createContext</code> 的返回值）作为参数，并返回该 Context 的当前值。<code>useContext</code> 的参数必须是 Context 对象本身。</li>
                        </ul>
                         <div class="mermaid">
                            graph TD
                                A[App Component] -- value --> P(ThemeContext.Provider);
                                P --> B(Toolbar Component);
                                B --> C(ThemedButton Component);
                                C -- reads value via useContext --> P;

                                subgraph "Context Data Flow"
                                    A; P; B; C;
                                end

                                style P fill:#eff6ff,stroke:#60a5fa,stroke-width:2px
                                style C fill:#dbeafe,stroke:#60a5fa
                        </div>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">使用场景：解决 <span class="tooltip-term" data-tooltip="指为了将数据传递给深层子组件，中间的许多层级组件被迫接收并传递该 prop 的现象。">Prop Drilling</span></h3>
                        <p>最主要的应用场景是避免“属性逐层传递 (Prop Drilling)”。当顶层组件的数据需要传递给很深层级的子组件时，中间的每一层组件都不得不接收并向下传递这个 prop，即使它们本身并不需要这个数据。</p>
                        <p>使用 Context，你可以在顶层设置一个 Provider，然后在任何深度的子组件中使用 <code>useContext</code> 直接获取数据。</p>
                        <pre><code class="language-javascript">
// 1. 创建 Context
const ThemeContext = React.createContext('light'); // 默认值 'light'

// 2. App 组件中使用 Provider 包裹子组件，并传递 value
function App() {
  const [theme, setTheme] = React.useState('dark');

  // 将 theme 和 setTheme 都传入 context，以便子组件可以更改主题
  const contextValue = React.useMemo(() => ({ theme, setTheme }), [theme]);

  return (
    &lt;ThemeContext.Provider value={contextValue}&gt;
      &lt;Toolbar /&gt;
      &lt;ThemeToggler /&gt; {/* 提取切换按钮 */}
    &lt;/ThemeContext.Provider&gt;
  );
}

// 3. 中间组件 Toolbar (不需要关心 theme)
function Toolbar() {
  // Toolbar 不需要知道 theme 或 setTheme
  return (
    &lt;div className="p-4 border rounded mb-4"&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  );
}

// 4. 深层子组件 ThemedButton 使用 useContext 获取 theme
function ThemedButton() {
  const { theme } = React.useContext(ThemeContext); // 只解构需要的 theme

  const buttonStyle = {
    background: theme === 'dark' ? '#333' : '#eee',
    color: theme === 'dark' ? '#fff' : '#000',
    padding: '10px 20px',
    border: 'none',
    borderRadius: '5px',
    cursor: 'pointer'
  };

  return (
    &lt;button style={buttonStyle}&gt;
      I am styled by theme: {theme}
    &lt;/button&gt;
  );
}

// 5. 另一个消费 Context 的组件，用于切换主题
function ThemeToggler() {
    const { theme, setTheme } = React.useContext(ThemeContext);
    return (
        &lt;button
            onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
            className="button button-secondary"
        &gt;
            Toggle Theme (Current: {theme})
        &lt;/button&gt;
    );
}

// 注意：实际应用中需要 import React, { useState, useContext, useMemo } 等
// 使用 useMemo 包装 contextValue 是一个优化，防止不必要的 context 更新
                        </code></pre>
                        <p class="mt-4 text-sm text-gray-600"><strong>注意：</strong>Context 主要用于共享那些被认为是“全局”的数据（如主题、用户认证状态、语言偏好）。对于频繁更新的状态，或者更复杂的状态逻辑，专门的状态管理库（如 Redux, Zustand）可能是更好的选择，因为 Context 的更新默认会使所有消费该 Context 的组件重新渲染（可以通过 `React.memo` 等优化）。 </p>
                    </div>
                    <div class="quiz-card" id="quiz-context">
                        <div class="quiz-question"><span class="material-icons">quiz</span>Context API 主要解决什么问题？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_context" value="a">
                                <span>组件性能优化</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_context" value="b">
                                <span>避免属性逐层传递 (Prop Drilling)</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_context" value="c">
                                <span>处理异步操作</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_context" value="d">
                                <span>组件代码复用</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_context"></div>
                        <button class="quiz-toggle button button-secondary" onclick="checkAnswer('q_context', 'b', 'quiz-context')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                         <div class="quiz-answer">
                            <p><strong>答案:</strong> B. 避免属性逐层传递 (Prop Drilling)</p>
                            <p><strong>解析:</strong> Context API 最核心的用途就是提供一种在组件树中共享数据的方式，而无需手动地一层一层通过 props 传递，从而解决了 Prop Drilling 的问题。虽然它可能间接影响性能（不当使用时），但其主要目的不是性能优化。异步操作和代码复用通常由其他模式或 Hooks 处理。</p>
                        </div>
                    </div>
                </section>

                <section id="common-hooks" class="content-section fade-in-section" style="animation-delay: 0.1s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">construction</span>其他常用 Hooks (useMemo, useCallback)
                        <span class="level-tag level-tag-low">低频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">作用：性能优化</h3>
                        <p><code>useMemo</code> 和 <code>useCallback</code> 是 React 提供的用于性能优化的 Hooks。它们的核心机制是 <strong class="tooltip-term" data-tooltip="一种优化技术，通过缓存函数调用或计算的结果，在后续相同的输入时直接返回缓存结果，避免重复计算。">记忆化 (Memoization)</strong>，即缓存计算结果或函数实例，避免在每次渲染时不必要的重复计算或创建。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3"><code>useMemo</code></h3>
                        <p><code>useMemo</code> 用于缓存 <strong>计算结果</strong>。</p>
                        <p class="mt-2 text-sm text-gray-700"><code>const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);</code></p>
                        <ul class="list-disc list-inside space-y-3 mt-4 text-sm text-gray-700">
                            <li>它接收一个“创建”函数和依赖项数组。</li>
                            <li>在初始渲染时，会调用创建函数，缓存其返回值。</li>
                            <li>在后续渲染中，只有当依赖项数组 <code>[a, b]</code> 中的某个值发生变化时，才会重新执行创建函数并返回新值；否则，直接返回上一次缓存的值。</li>
                            <li><strong>使用场景：</strong> 当组件中有计算成本较高的操作（如复杂的数据筛选、排序、转换）时，可以使用 <code>useMemo</code> 避免在每次渲染时都重新计算，前提是计算的依赖项没有改变。</li>
                        </ul>
                        <pre><code class="language-javascript">
import React, { useState, useMemo } from 'react';

function ExpensiveCalculationComponent({ list, filter }) {
  // 假设 filterList 是一个非常耗时的操作
  const filterList = (list, filter) => {
    console.log('%cFiltering list...', 'color: orange; font-weight: bold;'); // 观察何时执行
    // 模拟耗时操作
    // let startTime = performance.now();
    // while (performance.now() - startTime < 500) { /* busy wait */ }
    return list.filter(item => item.toLowerCase().includes(filter.toLowerCase()));
  };

  // 使用 useMemo 缓存过滤结果
  // 只有当 list 或 filter 变化时，filterList 才会重新执行
  const visibleList = useMemo(() => filterList(list, filter), [list, filter]);

  return (
    &lt;div className="mt-4 p-4 border rounded bg-gray-50"&gt;
      &lt;h4 className="font-semibold mb-2"&gt;Filtered List (Memoized):&lt;/h4&gt;
      &lt;ul className="list-disc list-inside text-sm"&gt;
        {visibleList.map((item, index) => (
          &lt;li key={index}&gt;{item}&lt;/li&gt;
        ))}
        {visibleList.length === 0 && &lt;li className="text-gray-500"&gt;No items match.&lt;/li&gt;}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

function App() {
  const [list, setList] = useState(['Apple', 'Banana', 'Orange', 'Avocado']);
  const [filter, setFilter] = useState('');
  const [counter, setCounter] = useState(0); // 一个无关的状态，用于触发 App 重渲染

  console.log('%cApp Rendering...', 'color: lightblue;');

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        placeholder="Filter list"
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        className="border p-2 rounded mr-2 mb-2"
      /&gt;
      &lt;button onClick={() => setCounter(c => c + 1)} className="button button-secondary mb-2"&gt;
        Force Re-render App (Counter: {counter})
      &lt;/button&gt;
      {/* 即使 App 因 counter 变化而重渲染, 只要 list 和 filter 不变, */}
      {/* ExpensiveCalculationComponent 中的 useMemo 就不会重新计算 filterList */}
      &lt;ExpensiveCalculationComponent list={list} filter={filter} /&gt;
      &lt;p className="text-xs mt-2 text-gray-500"&gt;打开控制台观察 'Filtering list...' 的打印频率。&lt;/p&gt;
    &lt;/div&gt;
  );
}
// 需要 import React, useState, useMemo
                        </code></pre>
                    </div>
                    <div class="content-card">
                        <h3 class="head3"><code>useCallback</code></h3>
                        <p><code>useCallback</code> 用于缓存 <strong>函数实例</strong>。</p>
                        <p class="mt-2 text-sm text-gray-700"><code>const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]);</code></p>
                        <ul class="list-disc list-inside space-y-3 mt-4 text-sm text-gray-700">
                            <li>它接收一个内联回调函数和依赖项数组。</li>
                            <li>返回该回调函数的记忆化版本。这个记忆化版本只有在依赖项数组 <code>[a, b]</code> 中的某个值发生变化时才会更新。</li>
                            <li><strong>使用场景：</strong> 主要用在将回调函数作为 prop 传递给子组件时，特别是当子组件使用了 <strong class="tooltip-term" data-tooltip="一个高阶组件，用于优化函数组件。它会对 props 进行浅比较，只有 props 变化时才重新渲染组件。"><code>React.memo</code></strong> 或依赖于 prop 的引用相等性进行优化时。如果不使用 <code>useCallback</code>，父组件每次渲染都会创建一个新的函数实例，即使函数逻辑不变，这也会导致子组件认为 prop 变化而重新渲染。<code>useCallback</code> 确保在依赖不变的情况下，传递给子组件的是同一个函数实例。</li>
                        </ul>
                         <pre><code class="language-javascript">
import React, { useState, useCallback } from 'react';

// 子组件，使用 React.memo 进行优化
// 只有 props 发生变化时才会重新渲染
const MemoizedButton = React.memo(({ onClick, children }) => {
  console.log(`%cRendering Button: ${children}`, 'color: lightgreen;');
  return &lt;button onClick={onClick} className="button button-primary mr-2 mb-2"&gt;{children}&lt;/button&gt;;
});

function ParentComponent() {
  const [count1, setCount1] = useState(0);
  const [count2, setCount2] = useState(0);

  console.log('%cParentComponent Rendering...', 'color: pink;');

  // 使用 useCallback 缓存 handleClick1
  // 依赖项为空数组 [], 它只会在初始渲染时创建一次
  const handleClick1 = useCallback(() => {
    setCount1(c => c + 1);
    console.log('handleClick1 (memoized) called');
  }, []); // 依赖项为空，函数引用永不改变

  // 没有使用 useCallback
  // 每次 ParentComponent 渲染时，都会创建一个新的 handleClick2 函数实例
  const handleClick2 = () => {
    setCount2(c => c + 1);
    console.log('handleClick2 (new instance) called');
  };

  return (
    &lt;div&gt;
      &lt;p className="mb-2"&gt;Count 1 (updated by memoized callback): {count1}&lt;/p&gt;
      &lt;p className="mb-4"&gt;Count 2 (updated by new callback instance): {count2}&lt;/p&gt;
      {/* 传递缓存的回调 */}
      &lt;MemoizedButton onClick={handleClick1}&gt;Increment Count 1&lt;/MemoizedButton&gt;
      {/* 传递未缓存的回调 */}
      &lt;MemoizedButton onClick={handleClick2}&gt;Increment Count 2&lt;/MemoizedButton&gt;
      &lt;p className="text-xs mt-2 text-gray-500"&gt;
        打开控制台观察按钮的渲染日志。点击 Count 1 按钮，只有 Button 1 日志（首次点击时）和 Parent 日志。点击 Count 2 按钮，Parent 和 Button 2 都会打印渲染日志，因为 handleClick2 是新实例。
      &lt;/p&gt;
    &lt;/div&gt;
  );
}
// 需要 import React, useState, useCallback
                        </code></pre>
                        <p class="mt-4 text-sm text-gray-600"><strong>重要提示：</strong> 不要过度使用 <code>useMemo</code> 和 <code>useCallback</code>。它们本身也有开销（创建依赖项数组、比较依赖项）。只有在确实存在性能瓶颈，或者需要保证引用相等性（如传递给优化子组件的回调）时才使用它们。过早或不必要的优化可能会增加代码复杂度。</p>
                    </div>
                     <div class="quiz-card" id="quiz-hooks">
                        <div class="quiz-question"><span class="material-icons">quiz</span><code>useCallback</code> 主要用于优化什么场景？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_hooks" value="a">
                                <span>缓存复杂的计算结果</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_hooks" value="b">
                                <span>在组件卸载时执行清理操作</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_hooks" value="c">
                                <span>向优化过的子组件传递回调函数时，保持函数引用的稳定性</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_hooks" value="d">
                                <span>创建可变的 ref 对象</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_hooks"></div>
                        <button class="quiz-toggle button button-secondary" onclick="checkAnswer('q_hooks', 'c', 'quiz-hooks')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                         <div class="quiz-answer">
                            <p><strong>答案:</strong> C. 向优化过的子组件传递回调函数时，保持函数引用的稳定性</p>
                            <p><strong>解析:</strong> <code>useCallback</code> 的核心作用是返回一个记忆化的回调函数版本。这在将回调作为 prop 传递给使用 <code>React.memo</code> 优化的子组件时尤其重要，可以防止因为父组件渲染导致回调函数实例变化，从而避免子组件不必要的重新渲染。A 是 <code>useMemo</code> 的场景，B 是 <code>useEffect</code> 的清理函数场景，D 是 <code>useRef</code> 的场景。</p>
                        </div>
                    </div>
                </section>

                <section id="virtual-dom" class="content-section fade-in-section" style="animation-delay: 0.15s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">view_quilt</span>虚拟 DOM (Virtual DOM)
                        <span class="level-tag level-tag-low">低频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">基本概念</h3>
                        <p>虚拟 DOM (VDOM) 是真实 DOM 的一个轻量级、内存中的表示。它本质上是一个 JavaScript 对象，描述了 UI 的结构、属性和内容。</p>
                        <p>React 的工作流程大致如下：</p>
                        <ol class="list-decimal list-inside space-y-2 mt-4 text-sm text-gray-700">
                            <li>当组件的 state 或 props 发生变化时，React 会根据新的状态重新计算并创建一个 <strong>新的虚拟 DOM 树</strong>。</li>
                            <li>React 将这个新的 VDOM 树与上一次渲染生成的旧 VDOM 树进行比较（这个过程称为 <strong class="tooltip-term" data-tooltip="也称为 Diffing，是比较两棵虚拟 DOM 树，找出最小差异的过程，是 React 高效更新 UI 的关键。">Reconciliation</strong>）。</li>
                            <li>通过 Diffing 算法，React 找出两棵树之间的最小差异（需要更新、添加或删除的节点）。</li>
                            <li>React 将这些计算出的差异进行 <strong class="tooltip-term" data-tooltip="React 会将多个状态更新合并到一次渲染中进行处理，以提高性能，减少不必要的 DOM 操作。">批量更新 (Batching)</strong>，然后一次性地、高效地应用到 <strong>真实的 DOM</strong> 上。</li>
                        </ol>
                        <div class="mermaid">
                            graph TD
                                A[State/Props Change] --> B(Render Component);
                                B --> C{New Virtual DOM Tree};
                                C -- Diffing Algorithm (Reconciliation) --> D(Compare with Old VDOM);
                                D --> E{Calculate Minimal Changes};
                                E -- Batching --> F[Update Real DOM];

                                subgraph React Reconciliation Process
                                    B; C; D; E; F;
                                end

                                style A fill:#fffbeb,stroke:#d97706
                                style F fill:#dcfce7,stroke:#16a34a
                                style D fill:#e0f2fe,stroke:#0ea5e9
                        </div>
                    </div>
                     <div class="content-card">
                        <h3 class="head3">优势</h3>
                        <ul class="list-disc list-inside space-y-3 mt-4 text-sm text-gray-700">
                            <li><strong>性能提升：</strong> 直接操作真实 DOM 的成本很高（涉及重排 Reflow 和重绘 Repaint）。VDOM 通过 Diffing 和 Batching，最大限度地减少了对真实 DOM 的操作次数和范围，从而提高了 UI 更新性能，尤其是在复杂应用中。</li>
                            <li><strong>抽象化：</strong> VDOM 为开发者提供了一个声明式的编程模型。开发者只需关心 UI 应该是什么样子（基于当前状态），而无需手动编写繁琐的 DOM 操作代码。React 负责将声明转换为实际的 DOM 更新。</li>
                            <li><strong>跨平台能力：</strong> VDOM 的概念使得 React 不仅仅局限于浏览器。例如，React Native 利用类似的原理，将 React 组件渲染成原生移动应用界面（iOS/Android），而不是 DOM。</li>
                        </ul>
                    </div>
                     <div class="quiz-card" id="quiz-vdom">
                        <div class="quiz-question"><span class="material-icons">quiz</span>虚拟 DOM 的主要优势不包括以下哪项？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_vdom" value="a">
                                <span>通过 Diffing 和 Batching 提升性能</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_vdom" value="b">
                                <span>提供声明式编程模型，简化开发</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_vdom" value="c">
                                <span>直接操作硬件资源</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_vdom" value="d">
                                <span>有助于实现跨平台渲染 (如 React Native)</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_vdom"></div>
                        <button class="quiz-toggle button button-secondary" onclick="checkAnswer('q_vdom', 'c', 'quiz-vdom')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                         <div class="quiz-answer">
                            <p><strong>答案:</strong> C. 直接操作硬件资源</p>
                            <p><strong>解析:</strong> 虚拟 DOM 是一个内存中的 JavaScript 对象表示，它抽象了真实的 DOM 操作，但它本身并不直接操作硬件资源。硬件操作是由浏览器或操作系统内核负责的。性能提升、声明式编程和跨平台能力是 VDOM 的主要优势。</p>
                        </div>
                    </div>
                </section>

                <section id="state-management" class="content-section fade-in-section" style="animation-delay: 0.2s;">
                    <h2 class="flex items-center head2">
                        <span class="material-icons">sync_alt</span>状态管理库 (Redux/Zustand 等)
                        <span class="level-tag level-tag-low">低频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">存在和目的</h3>
                        <p>随着应用规模的增长和复杂度的提高，组件间共享状态的需求会越来越多，状态的来源和更新逻辑也可能变得分散和难以追踪。仅仅依靠组件自身的 state (`useState`) 或 Context API 可能会遇到以下问题：</p>
                         <ul class="list-disc list-inside space-y-2 mt-4 text-sm text-gray-700">
                             <li><strong>深度 Prop Drilling：</strong> 状态需要跨越很多层级传递。</li>
                             <li><strong>状态来源不清晰：</strong> 难以追踪某个状态是在哪里被修改的。</li>
                             <li><strong>逻辑分散：</strong> 更新同一状态的逻辑可能散布在多个组件中。</li>
                             <li><strong>组件间通信复杂：</strong> 非父子关系的组件共享状态比较困难。</li>
                         </ul>
                         <p>状态管理库旨在解决这些问题，提供一种 <strong>集中式、可预测、易于维护</strong> 的方式来管理应用的全局或共享状态。</p>
                         <p><strong>核心目的：</strong></p>
                         <ul class="list-disc list-inside space-y-2 mt-4 text-sm text-gray-700">
                            <li><strong>集中管理 (Centralized):</strong> 将共享状态从组件中抽离，统一存放在一个地方（Store）。</li>
                            <li><strong>可预测性 (Predictable):</strong> 通常强制使用特定的模式来更新状态（如 Redux 的 Action -> Reducer），使状态变化更容易追踪、调试和测试。</li>
                            <li><strong>解耦 (Decoupled):</strong> 组件负责渲染 UI 和触发状态变更的意图，状态管理逻辑由库处理，降低组件复杂度。</li>
                            <li><strong>易于共享 (Shareable):</strong> 应用中的任何组件都可以方便地访问和响应共享状态的变化。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">了解 Redux / Zustand</h3>
                         <ul class="list-disc list-inside space-y-3 mt-4 text-sm text-gray-700">
                            <li><strong>Redux:</strong>
                                <ul class="list-['-_'] list-inside ml-4 mt-2 space-y-1 text-xs text-gray-600">
                                    <li>经典、功能强大的状态管理库，基于 Flux 思想。</li>
                                    <li>核心概念：<strong>Store</strong> (单一数据源), <strong>Action</strong> (描述事件的对象), <strong>Reducer</strong> (根据 Action 更新状态的 <span class="tooltip-term" data-tooltip="指给定相同的输入，总是返回相同的输出，并且不产生任何副作用（如修改外部变量、发起网络请求等）的函数。">纯函数</span>)。</li>
                                    <li>强调 <span class="tooltip-term" data-tooltip="指一旦创建就不能被修改的数据。在 Redux 中，状态更新总是通过创建新的状态对象而不是直接修改旧对象来完成。">不可变性 (Immutability)</span> 和纯函数。</li>
                                    <li>过去因样板代码（Boilerplate）较多而闻名，但现在官方推荐的 <strong>Redux Toolkit (RTK)</strong> 大大简化了使用。</li>
                                    <li>生态成熟，调试工具强大。</li>
                                </ul>
                                <div class="mermaid">
                                    graph LR
                                        A[UI Component] -- Dispatch --> B(Action);
                                        B -- Processed by --> C{"Reducer (Pure Function)"};
                                        C -- Updates --> D((Store));
                                        D -- State --> A;

                                    subgraph Redux Basic Flow
                                        A; B; C; D;
                                    end

                                    style A fill:#dbeafe,stroke:#60a5fa
                                    style B fill:#ffedd5,stroke:#fb923c
                                    style C fill:#fef9c3,stroke:#facc15
                                    style D fill:#fce7f3,stroke:#f472b6,stroke-width:2px
                                </div>
                            </li>
                             <li><strong>Zustand:</strong>
                                <ul class="list-['-_'] list-inside ml-4 mt-2 space-y-1 text-xs text-gray-600">
                                    <li>一个更现代、轻量、简洁的状态管理库。</li>
                                    <li>基于 Hooks，API 非常直观，样板代码极少。</li>
                                    <li>不强制使用 Reducer 模式（但支持），提供了更灵活的方式来组织状态和更新逻辑（通常通过 `set` 函数直接更新）。</li>
                                    <li>上手快，心智负担小，适用于各种规模的项目，尤其受不喜欢 Redux 复杂性的开发者欢迎。</li>
                                </ul>
                                <div class="mermaid">
                                    graph LR
                                    A[UI Component] -- Calls action --> B{"Store Hook (useStore)"};
                                    B -- "Uses 'set' function" --> C((Store State));
                                    C -- Selects state --> A;
                                
                                    subgraph Zustand Basic Flow Simplified
                                        A
                                        B
                                        C
                                    end
                                
                                    style A fill:#dbeafe,stroke:#60a5fa
                                    style B fill:#ecfdf5,stroke:#34d399
                                    style C fill:#f1f5f9,stroke:#64748b,stroke-width:2px
                                
                                </div>
                            </li>
                        </ul>
                        <p class="mt-4 text-sm text-gray-600"><strong>面试要点：</strong> 理解为什么需要状态管理库（解决什么问题），知道 Redux 和 Zustand 是常见的选择，并大致了解它们的核心思想或特点（Redux 的 Action/Reducer，Zustand 的简洁/Hook 기반）。重点在于理解问题域和解决方案，而非精通所有库的细节（除非职位特别要求）。</p>
                    </div>
                     <div class="quiz-card" id="quiz-state">
                        <div class="quiz-question"><span class="material-icons">quiz</span>与 Context API 相比，状态管理库 (如 Redux) 通常更适合哪种场景？</div>
                        <div class="quiz-options">
                            <label class="quiz-option">
                                <input type="radio" name="q_state" value="a">
                                <span>仅用于传递简单的 UI 主题</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_state" value="b">
                                <span>处理非常简单、组件局部化的状态</span>
                            </label>
                            <label class="quiz-option">
                                <input type="radio" name="q_state" value="c">
                                <span>管理复杂、频繁更新、跨组件共享的全局应用状态</span>
                            </label>
                             <label class="quiz-option">
                                <input type="radio" name="q_state" value="d">
                                <span>替代所有 useState 的使用</span>
                            </label>
                        </div>
                        <div class="quiz-feedback mt-4" id="feedback-q_state"></div>
                        <button class="quiz-toggle button button-secondary" onclick="checkAnswer('q_state', 'c', 'quiz-state')">
                             <span class="material-icons icon-arrow">expand_more</span><span class="button-text">检查答案</span>
                        </button>
                         <div class="quiz-answer">
                            <p><strong>答案:</strong> C. 管理复杂、频繁更新、跨组件共享的全局应用状态</p>
                            <p><strong>解析:</strong> 状态管理库提供了更强大的功能来处理复杂的状态逻辑、中间件（如处理异步操作）、更好的性能优化（精确订阅）和强大的调试工具，这些在大型应用中管理频繁更新的全局状态时非常有优势。Context API 更适合共享不经常变化或逻辑相对简单的全局数据。局部状态应优先使用 `useState`。状态库并非要替代所有 `useState`。</p>
                        </div>
                    </div>
                </section>

            </article>
        </main>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Initialize Mermaid after DOM is ready
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });

        document.addEventListener('DOMContentLoaded', () => {
            // --- TOC Highlighting & Fade-in Logic ---
            const sections = document.querySelectorAll('main section[id]');
            const tocLinks = document.querySelectorAll('#local-toc a');
            const mainContentSections = document.querySelectorAll('main > article > section.content-section');

            // TOC Highlighting
            const tocObserverOptions = { root: null, rootMargin: '-20% 0px -60% 0px', threshold: 0 };
            let lastActiveTocLink = null;

            const tocObserverCallback = (entries) => {
                let bestVisibleEntry = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (!bestVisibleEntry || entry.boundingClientRect.top < bestVisibleEntry.boundingClientRect.top) {
                            bestVisibleEntry = entry;
                        }
                    }
                });
                if (bestVisibleEntry) {
                    const id = bestVisibleEntry.target.getAttribute('id');
                    const activeLink = document.querySelector(`#local-toc a[href="#${id}"]`);
                    if (activeLink && activeLink !== lastActiveTocLink) {
                        if (lastActiveTocLink) lastActiveTocLink.classList.remove('active');
                        activeLink.classList.add('active');
                        lastActiveTocLink = activeLink;
                    }
                }
            };
            const tocObserver = new IntersectionObserver(tocObserverCallback, tocObserverOptions);
            sections.forEach(section => tocObserver.observe(section));

            // Initial active link
            const currentHash = window.location.hash;
            if (currentHash) {
                const initialActiveLink = document.querySelector(`#local-toc a[href="${currentHash}"]`);
                if (initialActiveLink) {
                     tocLinks.forEach(link => link.classList.remove('active'));
                     initialActiveLink.classList.add('active');
                     lastActiveTocLink = initialActiveLink;
                }
            } else if (tocLinks.length > 0 && !lastActiveTocLink) {
                 tocLinks[0].classList.add('active');
                 lastActiveTocLink = tocLinks[0];
            }

            // Fade-in Animation
            const fadeObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
            const fadeObserverCallback = (entries, observer) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        const delayIndex = Array.from(mainContentSections).indexOf(entry.target);
                        entry.target.style.animationDelay = `${delayIndex * 0.05}s`;
                        entry.target.classList.add('fade-in-section');
                        observer.unobserve(entry.target);
                    }
                });
            };
            const fadeObserver = new IntersectionObserver(fadeObserverCallback, fadeObserverOptions);
            mainContentSections.forEach(section => fadeObserver.observe(section));

            // --- Quiz Card Logic (Adapted from example.html) ---

            // Ripple Effect for Buttons
            function createRipple(event) {
                const button = event.currentTarget;
                // Check if button is a valid element and has getBoundingClientRect
                if (!button || typeof button.getBoundingClientRect !== 'function') return;

                const circle = document.createElement("span");
                const diameter = Math.max(button.clientWidth, button.clientHeight);
                const radius = diameter / 2;

                // Try to get RGB from CSS variable, fallback to default blue
                const primaryColorRgb = getComputedStyle(document.documentElement)
                                        .getPropertyValue('--primary-color-rgb')
                                        .trim() || '59, 130, 246'; // Default blue-500 RGB

                circle.style.width = circle.style.height = `${diameter}px`;
                const rect = button.getBoundingClientRect();
                circle.style.left = `${event.clientX - rect.left - radius}px`;
                circle.style.top = `${event.clientY - rect.top - radius}px`;
                circle.style.backgroundColor = `rgba(${primaryColorRgb}, 0.4)`; // Use RGB for opacity
                circle.classList.add("ripple");

                const existingRipple = button.querySelector(".ripple");
                if (existingRipple) existingRipple.remove();

                button.appendChild(circle);
                // Clean up ripple after animation
                setTimeout(() => circle.remove(), 600);
            }

            // Toggle Answer Visibility
            window.toggleAnswer = function(quizId, buttonElement) {
                const quizCard = document.getElementById(quizId);
                if (!quizCard) return;
                const answer = quizCard.querySelector('.quiz-answer');
                const icon = buttonElement?.querySelector('.icon-arrow'); // Make buttonElement optional check
                const buttonTextSpan = buttonElement?.querySelector('.button-text'); // Make buttonElement optional check

                if (!answer) return;

                const isVisible = answer.classList.contains('visible');

                if (isVisible) {
                    answer.style.maxHeight = '0';
                    answer.style.opacity = '0';
                    answer.style.marginTop = '0';
                    answer.style.paddingTop = '0';
                    answer.style.paddingBottom = '0';
                    answer.classList.remove('visible');
                    if (icon) icon.classList.remove('rotated');
                    if (buttonTextSpan) buttonTextSpan.textContent = ' 查看答案';
                    // Use setTimeout to set display: none after transition completes
                    setTimeout(() => {
                        // Double check if it's still hidden before setting display none
                        if (!answer.classList.contains('visible')) {
                            answer.style.display = 'none';
                        }
                    }, 500); // Match transition duration
                } else {
                    answer.style.display = 'block'; // Make it block to measure scrollHeight
                    // Set final styles before triggering transition
                    answer.style.paddingTop = '1rem';
                    answer.style.paddingBottom = '1rem';
                    answer.style.marginTop = '1rem';
                    // Use requestAnimationFrame to ensure display: block is applied before setting maxHeight
                    requestAnimationFrame(() => {
                        answer.style.maxHeight = answer.scrollHeight + 'px';
                        answer.style.opacity = '1';
                        answer.classList.add('visible');
                        if (icon) icon.classList.add('rotated');
                        if (buttonTextSpan) buttonTextSpan.textContent = ' 隐藏答案';
                    });
                }
            }

            // Check Answer Logic
            window.checkAnswer = function(questionName, correctAnswerValue, quizId) {
                const options = document.querySelectorAll(`input[name="${questionName}"]`);
                const feedbackElement = document.getElementById(`feedback-${questionName}`);
                const quizCard = document.getElementById(quizId); // Use quizId passed to function
                let selectedValue = null;
                let selectedLabel = null;

                if (!feedbackElement || !quizCard) {
                    console.error("Quiz elements not found for:", questionName, quizId);
                    return;
                }

                // Reset previous feedback and styles
                quizCard.querySelectorAll('.quiz-option').forEach(opt => opt.classList.remove('selected', 'correct', 'incorrect'));
                feedbackElement.style.display = 'none';
                feedbackElement.textContent = '';

                // Find selected option
                options.forEach(option => {
                    if (option.checked) {
                        selectedValue = option.value;
                        selectedLabel = option.closest('.quiz-option');
                        if (selectedLabel) selectedLabel.classList.add('selected');
                    }
                });

                // Check if an option was selected
                if (!selectedValue) {
                    feedbackElement.textContent = "请选择一个选项！";
                    feedbackElement.className = 'quiz-feedback warning'; // Use warning class
                    feedbackElement.style.display = 'block';
                    return;
                }

                // Find the correct answer label
                let correctAnswerLabel = null;
                options.forEach(opt => {
                    if (opt.value === correctAnswerValue) {
                        correctAnswerLabel = opt.closest('.quiz-option');
                    }
                });

                // Provide feedback
                if (selectedValue === correctAnswerValue) {
                    feedbackElement.textContent = "回答正确！";
                    feedbackElement.className = 'quiz-feedback correct';
                    if(selectedLabel) selectedLabel.classList.add('correct');
                } else {
                    let correctAnswerText = '';
                    if (correctAnswerLabel) {
                        // Try to get text from the span inside the label
                        correctAnswerText = correctAnswerLabel.querySelector('span')?.textContent || `选项 ${correctAnswerValue}`;
                        correctAnswerLabel.classList.add('correct'); // Highlight the correct one
                    }
                    feedbackElement.textContent = `回答错误。正确答案是: "${correctAnswerText}"`;
                    feedbackElement.className = 'quiz-feedback incorrect';
                    if(selectedLabel) selectedLabel.classList.add('incorrect'); // Mark the wrong selection
                }
                feedbackElement.style.display = 'block';

                // Automatically show the answer section when checking
                const toggleButton = quizCard.querySelector('.quiz-toggle');
                const answerSection = quizCard.querySelector('.quiz-answer');
                if (toggleButton && answerSection && !answerSection.classList.contains('visible')) {
                    toggleAnswer(quizId, toggleButton);
                }
            }

            // Add ripple effect to all quiz toggle buttons
            document.querySelectorAll('.quiz-toggle').forEach(button => {
                button.addEventListener('click', createRipple);
            });

        }); // End DOMContentLoaded
    </script>

</body>

</html>
