<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP 协议核心</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
        integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="../../global.css"> <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <style>
        /* Minimal inline styles - Primarily rely on global.css and Tailwind */

        /* Adjust scroll padding for potential sticky header */
        html {
            scroll-padding-top: 6rem;
        }

        /* Basic body setup, inheriting most styles from global.css */
        body {
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
            background-color: var(--bg-color-lighter, #f3f4f6);
        }

        /* Adjust scroll margin for headings to account for sticky nav */
        h1, h2, h3, h4, h5, h6 {
            scroll-margin-top: 6rem;
        }

        /* Style for frequency/level tags (copied from 01-Network-Basics.html) */
        .level-tag {
            display: inline-block;
            margin-left: 0.5rem;
            font-size: 0.75rem; /* text-xs */
            font-weight: 500; /* font-medium */
            padding: 0.1rem 0.5rem;
            border-radius: 0.25rem; /* rounded-sm */
            vertical-align: middle;
            border: 1px solid transparent;
        }
        .level-tag-high { background-color: var(--danger-color-light); color: var(--danger-color); border-color: var(--danger-color); }
        .level-tag-medium { background-color: var(--warning-color-light); color: var(--warning-color); border-color: var(--warning-color); }
        .level-tag-low { background-color: var(--secondary-color-light); color: var(--secondary-color); border-color: var(--secondary-color); }
        .level-tag-base { background-color: var(--bg-color-lighter); color: var(--text-color-light); border-color: var(--border-color-default); }
        .level-tag-advanced { background-color: var(--primary-color-light); color: var(--primary-color-dark); border-color: var(--primary-color); }

        /* Fade-in Animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in-section {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* Ensure content cards have appropriate margin */
        .content-card {
            margin-bottom: 1.5rem; /* Consistent spacing */
        }
        .content-card:last-child {
            margin-bottom: 0;
        }
        .content-section > .content-card + .content-card {
             margin-top: 1.5rem; /* Space between cards within the same section */
        }

        /* Basic list styling within article content */
        article ul { list-style: disc; padding-left: 1.5em; margin-bottom: 1em; }
        article ol { list-style: decimal; padding-left: 1.5em; margin-bottom: 1em; }
        article li { margin-bottom: 0.5em; }
        article ul ul, article ol ol { margin-top: 0.5em; margin-bottom: 0.5em; padding-left: 1em; }


        /* Style for list items representing knowledge points */
        .knowledge-point {
            padding: 0.5rem 0;
            border-bottom: 1px dashed var(--border-color-light);
            transition: background-color 0.2s ease;
        }
        .knowledge-point:last-child {
            border-bottom: none;
        }
        .knowledge-point:hover {
            background-color: rgba(59, 130, 246, 0.05); /* Light blue hover */
        }
        .knowledge-point .material-icons {
            font-size: 1.1rem;
            vertical-align: middle;
            margin-right: 0.3rem;
            color: var(--text-color-light);
        }
        .knowledge-point strong.highlight { /* Highlight "重点" */
            color: var(--danger-color);
            font-weight: 600;
        }
        .knowledge-point code { /* Inline code style from global.css */ }

        /* Table Styling (from 01-Network-Basics.html) */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1rem;
            font-size: 0.875rem; /* text-sm */
        }
        th, td {
            border: 1px solid var(--border-color-default);
            padding: 0.5rem 0.75rem;
            text-align: left;
            vertical-align: top; /* Align content top */
        }
        th {
            background-color: var(--bg-color-lighter);
            font-weight: 600;
            color: var(--text-color-dark);
        }
        tbody tr:nth-child(odd) {
            background-color: var(--bg-color-light);
        }
        tbody tr:hover {
            background-color: var(--primary-color-light); /* blue-50 */
        }
        td ul { margin-bottom: 0; padding-left: 1.2em;} /* Tighter list spacing in tables */
        td li { margin-bottom: 0.25em; }

        /* Mermaid Diagram Styling */
        .mermaid {
            margin: 1.5rem 0;
            text-align: center;
            background-color: var(--bg-color-light);
            padding: 1rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color-light);
        }
        .mermaid svg { max-width: 100%; height: auto; display: block; margin: auto; }

    </style>
</head>

<body class="bg-gray-100">
    <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">HTTP 协议核心</h4>
            <ul id="local-toc">
                <li><a href="#intro" class="active"><span class="material-icons nav-icon">http</span>简介</a></li>
                <li><a href="#http-evolution"><span class="material-icons nav-icon">history</span>HTTP 演进</a></li>
                <li><a href="#http2-features"><span class="material-icons nav-icon">fast_forward</span>HTTP/2 特性</a></li>
                <li><a href="#http3-features"><span class="material-icons nav-icon">rocket</span>HTTP/3 特性</a></li>
                <li><a href="#http-message-structure"><span class="material-icons nav-icon">description</span>HTTP 报文结构</a></li>
                <li><a href="#http-methods"><span class="material-icons nav-icon">terminal</span>HTTP 方法</a></li>
                <li><a href="#http-method-properties"><span class="material-icons nav-icon">check_circle</span>方法属性</a></li>
                <li><a href="#get-vs-post"><span class="material-icons nav-icon">compare_arrows</span>GET vs POST</a></li>
                <li><a href="#put-vs-patch"><span class="material-icons nav-icon">difference</span>PUT vs PATCH</a></li>
                <li><a href="#http-status-codes"><span class="material-icons nav-icon">tag</span>HTTP 状态码</a></li>
                <li><a href="#status-code-details"><span class="material-icons nav-icon">rule</span>状态码细节</a></li>
                <li><a href="#http-body-encoding"><span class="material-icons nav-icon">compress</span>消息体与编码</a></li>
                <li><a href="#http-core-headers"><span class="material-icons nav-icon">view_headline</span>核心头部</a></li>
            </ul>
            <a href="../../index.html" class="back-link"> &larr; 返回大纲目录
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="intro" class="content-section fade-in-section" style="animation-delay: 0s;">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-icons text-3xl text-blue-600">http</span>(二) HTTP 协议核心
                    </h1>
                    <p>HTTP (HyperText Transfer Protocol) 是万维网（World Wide Web）数据通信的基础，是一个用于传输超媒体文档（例如 HTML）的应用层协议。它是一种请求-响应协议，通常运行在 TCP/IP 协议栈之上。理解 HTTP 的核心概念、演进历程和关键特性对于任何 Web 开发者（前端、后端、全栈）都至关重要。</p>
                    <p class="mt-4 bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md text-sm">💡
                        <strong>提示:</strong> 本页详细介绍了 HTTP 协议的核心知识点。点击左侧导航可快速跳转。括号内标注了知识点在面试中的常见程度和基础/进阶级别。
                    </p>
                </section>

                <section id="http-evolution" class="content-section fade-in-section" style="animation-delay: 0.05s;">
                    <h2 class="flex items-center head2"><span class="material-icons">history</span>HTTP 演进
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-base">基础</span>
                        <strong class="highlight">(重点)</strong>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">HTTP/0.9 ~ HTTP/3 主要版本特性对比</h3>
                        <p class="mb-4">HTTP 协议并非一成不变，它经历了多个版本的迭代，以适应不断增长的 Web 需求，提升性能和安全性。</p>
                        <div class="overflow-x-auto">
                            <table>
                                <thead>
                                    <tr>
                                        <th>版本</th>
                                        <th>主要特性与改进</th>
                                        <th>关键问题/局限</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>HTTP/0.9</strong><br>(1991)</td>
                                        <td>
                                            <ul>
                                                <li>极其简单，只有一个 <code>GET</code> 方法。</li>
                                                <li>没有请求头或响应头。</li>
                                                <li>服务器响应仅包含 HTML 文档本身，响应后连接关闭。</li>
                                            </ul>
                                        </td>
                                        <td>功能非常有限，无法传输元数据，效率低。</td>
                                    </tr>
                                    <tr>
                                        <td><strong>HTTP/1.0</strong><br>(1996, RFC 1945)</td>
                                        <td>
                                            <ul>
                                                <li>引入 <strong>请求头 (Request Headers)</strong> 和 <strong>响应头 (Response Headers)</strong>，允许传输元数据。</li>
                                                <li>引入 <strong>状态码 (Status Codes)</strong>，标识请求结果。</li>
                                                <li>引入多种请求方法 (如 <code>POST</code>, <code>HEAD</code>)。</li>
                                                <li>引入 <strong>内容类型 (Content-Type)</strong>，支持多种数据格式。</li>
                                                <li>引入了简单的缓存机制 (如 <code>Expires</code>, <code>Pragma: no-cache</code>)。</li>
                                                <li>默认 <strong>短连接</strong> (每次请求/响应后关闭连接)。</li>
                                            </ul>
                                        </td>
                                        <td>短连接导致每次请求都需要建立 TCP 连接，开销大；无 Host 头部，难以支持虚拟主机；管道化支持不完善。</td>
                                    </tr>
                                    <tr>
                                        <td><strong>HTTP/1.1</strong><br>(1997/1999/2014, RFC 2616 -> 7230-7235)</td>
                                        <td>
                                            <ul>
                                                <li><strong>持久连接 (Persistent Connections / Keep-Alive)</strong> 成为默认行为，减少了 TCP 连接建立开销。</li>
                                                <li>引入 <strong>管道化 (Pipelining)</strong>，允许客户端在收到前一个响应前发送多个请求（但服务器需按序响应，易引发队头阻塞）。</li>
                                                <li>强制要求 <strong>Host 头部</strong>，支持虚拟主机。</li>
                                                <li>更完善的 <strong>缓存控制</strong> (<code>Cache-Control</code>, <code>ETag</code>, <code>If-Match</code> 等)。</li>
                                                <li>引入 <strong>内容协商</strong> (<code>Accept-*</code> headers)。</li>
                                                <li>引入 <strong>分块传输编码 (Transfer-Encoding: chunked)</strong>，允许流式传输。</li>
                                                <li>增加更多方法 (<code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>, <code>OPTIONS</code>, <code>TRACE</code>, <code>CONNECT</code>)。</li>
                                            </ul>
                                        </td>
                                        <td><strong>队头阻塞 (Head-of-Line Blocking):</strong> 同一连接上的请求/响应必须按序处理，一个慢请求会阻塞后续请求；头部冗余，每次请求都携带大量重复信息；文本协议解析效率相对较低。</td>
                                    </tr>
                                    <tr>
                                        <td><strong>HTTP/2</strong><br>(2015, RFC 7540)</td>
                                        <td>
                                            <ul>
                                                <li><strong>二进制分帧 (Binary Framing):</strong> 协议交互单元是帧，解析效率高，不易出错。</li>
                                                <li><strong>多路复用 (Multiplexing):</strong> 在单个 TCP 连接上并行处理多个请求/响应流，解决了应用层队头阻塞。</li>
                                                <li><strong>头部压缩 (HPACK):</strong> 高效压缩 HTTP 头部，减少传输开销。</li>
                                                <li><strong>服务器推送 (Server Push):</strong> 服务器可主动推送资源给客户端。</li>
                                                <li><strong>请求优先级 (Request Prioritization):</strong> 允许客户端指定请求的优先级。</li>
                                            </ul>
                                        </td>
                                        <td><strong>TCP 队头阻塞:</strong> 底层 TCP 的丢包仍然会阻塞该连接上的所有流；握手延迟（TCP + TLS）。</td>
                                    </tr>
                                    <tr>
                                        <td><strong>HTTP/3</strong><br>(2022, RFC 9114)</td>
                                        <td>
                                            <ul>
                                                <li><strong>基于 QUIC 协议 (运行在 UDP 上):</strong> 绕过 TCP 限制，实现快速部署和创新。</li>
                                                <li><strong>彻底解决队头阻塞:</strong> QUIC 的流是独立的，一个流的丢包不影响其他流。</li>
                                                <li><strong>0-RTT / 1-RTT 连接建立:</strong> 结合传输层和 TLS 1.3 握手，显著减少连接延迟。</li>
                                                <li><strong>连接迁移 (Connection Migration):</strong> 网络切换（IP/端口变化）时连接不中断。</li>
                                                <li><strong>强制加密:</strong> 内置 TLS 1.3 加密。</li>
                                                <li><strong>头部压缩 (QPACK):</strong> 针对 QUIC 设计的头部压缩，解决 HPACK 的队头阻塞问题。</li>
                                                <li>改进的拥塞控制和丢失恢复机制。</li>
                                            </ul>
                                        </td>
                                        <td>需要 UDP 支持（部分网络环境可能限制 UDP）；用户态实现可能带来 CPU 开销；协议相对较新，生态系统仍在发展中。</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section id="http2-features" class="content-section fade-in-section" style="animation-delay: 0.1s;">
                    <h2 class="flex items-center head2"><span class="material-icons">fast_forward</span>HTTP/2 特性详解
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                        <strong class="highlight">(重点)</strong>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">二进制分帧 (Binary Framing)</h3>
                        <p>HTTP/2 将所有传输的信息（请求/响应头、消息体）分割为更小的消息和帧，并采用二进制格式编码。帧是 HTTP/2 通信的最小单位。</p>
                        <ul>
                            <li><strong>帧类型:</strong> 定义了多种帧类型，如 HEADERS 帧（传输头部）、DATA 帧（传输消息体）、SETTINGS 帧（连接设置）、PING 帧（检测连接）、GOAWAY 帧（关闭连接）等。</li>
                            <li><strong>流标识符 (Stream ID):</strong> 每个帧都属于一个特定的“流”（Stream），用于标识逻辑上的请求-响应交互。</li>
                            <li><strong>优点:</strong> 解析效率高，不易出错（相比文本协议）；为多路复用奠定基础。</li>
                        </ul>
                         <div class="mermaid">
                            %%{init: {"flowchart": {"htmlLabels": true}}}%%
                            graph LR
                              A["HTTP/1.1 消息<br/>（文本）"] --> B("解析困难<br/>易出错")
                              C["HTTP/2 消息"] --> D["分割为帧"]
                              D --> E["HEADERS 帧<br/>(二进制)"]
                              D --> F["DATA 帧<br/>(二进制)"]
                              D --> G["其他帧..."]
                              E & F & G --> H["网络传输"]
                              H --> I["接收端重组"]
                              I --> J["高效解析"]
                            
                              style A fill:#fef9c3,stroke:#ca8a04
                              style C fill:#dcfce7,stroke:#16a34a
                              style D fill:#e0f2fe,stroke:#0ea5e9
                              style E fill:#f1f5f9,stroke:#64748b
                              style F fill:#f1f5f9,stroke:#64748b
                              style G fill:#f1f5f9,stroke:#64748b
                              style H fill:#e5e7eb,stroke:#4b5563
                              style I fill:#e0f2fe,stroke:#0ea5e9
                              style J fill:#dcfce7,stroke:#16a34a
                            
                         </div>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">多路复用 (Multiplexing)</h3>
                        <p>这是 HTTP/2 最核心的改进之一。它允许在 <strong>单个 TCP 连接</strong> 上同时、并行地发送和接收多个请求和响应，这些请求/响应被组织成独立的逻辑流 (Stream)。</p>
                        <ul>
                            <li><strong>流 (Stream):</strong> 一个虚拟的通道，承载一个双向的字节序列。每个请求-响应对对应一个流。客户端发起的流 ID 为奇数，服务器发起的流 ID 为偶数。</li>
                            <li><strong>帧交错:</strong> 不同流的帧可以在 TCP 连接上交错发送，接收方根据帧头的流 ID 将它们重新组装。</li>
                            <li><strong>解决队头阻塞:</strong> 由于帧是交错的，一个请求的阻塞（如等待服务器处理）不会影响其他流的传输，解决了 HTTP/1.1 的应用层队头阻塞。</li>
                        </ul>
                        <div class="mermaid">
                            graph TD
                                subgraph "HTTP/1.1 (Pipelining - 理论)"
                                    direction LR
                                    C1[Client] -- Req1 --> S1[Server]
                                    C1 -- Req2 --> S1
                                    C1 -- Req3 --> S1
                                    S1 -- Resp1 --> C1
                                    S1 -- Resp2 (阻塞) --> C1
                                    S1 -- Resp3 (等待) --> C1
                                end
                                subgraph "HTTP/2 (Multiplexing)"
                                    direction LR
                                    C2[Client] -- Stream1 (Frames) --> S2[Server]
                                    C2 -- Stream3 (Frames) --> S2
                                    S2 -- Stream1 (Frames) --> C2
                                    C2 -- Stream5 (Frames) --> S2
                                    S2 -- Stream3 (Frames) --> C2
                                    S2 -- Stream5 (Frames) --> C2
                                end
                                style C1 fill:#fef9c3, stroke:#ca8a04
                                style S1 fill:#fef9c3, stroke:#ca8a04
                                style C2 fill:#dcfce7, stroke:#16a34a
                                style S2 fill:#dcfce7, stroke:#16a34a
                        </div>
                        <p class="mt-2 text-sm text-gray-600">注意：HTTP/2 的多路复用解决了应用层的队头阻塞，但如果底层 TCP 发生丢包，仍然会阻塞整个连接上的所有流（TCP 队头阻塞）。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">头部压缩 (HPACK)</h3>
                        <p>HTTP 请求和响应通常包含大量重复的头部信息（如 User-Agent, Accept 等）。HPACK (Header Compression for HTTP/2) 是一种专门为 HTTP/2 设计的压缩算法。</p>
                        <ul>
                            <li><strong>静态表 (Static Table):</strong> 定义了常用的 HTTP 头部字段（如 <code>:method: GET</code>）。</li>
                            <li><strong>动态表 (Dynamic Table):</strong> 维护一个动态更新的头部字段列表，用于存储之前传输过的头部。后续请求可以引用表中的条目。</li>
                            <li><strong>哈夫曼编码 (Huffman Coding):</strong> 对头部字段的值进行哈夫曼编码，进一步压缩。</li>
                            <li><strong>优点:</strong> 大幅减少了头部传输的冗余，降低了带宽消耗和延迟。</li>
                            <li><strong>局限:</strong> HPACK 压缩和解压上下文与 TCP 连接绑定，可能受 TCP 队头阻塞影响；且存在一定的安全风险（如 CRIME 攻击，虽然现代实现已缓解）。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">服务器推送 (Server Push)</h3>
                        <p>允许服务器在客户端请求一个资源（如 HTML）时，主动将客户端可能需要的其他资源（如 CSS, JS）“推送”给客户端，而无需客户端显式请求。</p>
                        <ul>
                            <li><strong>机制:</strong> 服务器发送 PUSH_PROMISE 帧，告知客户端它将要推送的资源，然后通过新的流发送资源数据。</li>
                            <li><strong>目的:</strong> 减少请求往返次数，提前将资源放入客户端缓存，理论上可以加快页面加载速度。</li>
                            <li><strong>挑战与争议:</strong>
                                <ul>
                                    <li>难以准确预测客户端是否需要或已经缓存了该资源，可能推送不必要的资源，浪费带宽。</li>
                                    <li>实现和优化复杂，缓存交互问题多。</li>
                                    <li>实际应用效果不佳，许多 CDN 和服务器已默认禁用或不推荐使用。</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </section>

                <section id="http3-features" class="content-section fade-in-section" style="animation-delay: 0.15s;">
                    <h2 class="flex items-center head2"><span class="material-icons">rocket</span>HTTP/3 特性详解
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                        <strong class="highlight">(重点)</strong>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">基于 QUIC (UDP)</h3>
                        <p>HTTP/3 不再使用 TCP 作为传输层协议，而是选择了基于 UDP 的 QUIC 协议。</p>
                        <ul>
                            <li><strong>原因:</strong> 摆脱 TCP 的内核实现限制和中间设备僵化问题，实现更快的协议演进和部署；从根本上解决 TCP 队头阻塞。</li>
                            <li><strong>实现:</strong> QUIC 在用户态实现了可靠传输、拥塞控制、流量控制、多路复用等功能，并集成了 TLS 1.3 加密。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">彻底解决 HOL 阻塞</h3>
                        <p>QUIC 引入了独立流的概念，这是其相比 HTTP/2 的关键优势。</p>
                        <ul>
                            <li><strong>QUIC 流独立性:</strong> QUIC 连接上的每个流都有自己独立的传输状态和序号空间。</li>
                            <li><strong>丢包影响局部化:</strong> 如果一个 QUIC 流的数据包丢失，只会阻塞该流的数据交付，其他流可以继续正常传输和交付给应用层。</li>
                            <li><strong>效果:</strong> 彻底解决了困扰 TCP 和 HTTP/2 的队头阻塞问题（包括传输层和应用层）。</li>
                        </ul>
                        <div class="mermaid">
                            graph TD
                            subgraph "TCP (HTTP/2)"
                              A["TCP Connection"] --> B{Packet Loss}
                              B -- "Blocks" --> C["Stream 1"]
                              B -- "Blocks" --> D["Stream 2"]
                              B -- "Blocks" --> E["Stream 3"]
                            end
                          
                            subgraph "QUIC (HTTP/3)"
                              F["QUIC Connection (UDP)"] --> G{Packet Loss in Stream 2}
                              G -- "Blocks Only" --> H["Stream 2"]
                              F -- "Continues" --> I["Stream 1"]
                              F -- "Continues" --> J["Stream 3"]
                            end
                          
                            style B fill:#fee2e2,stroke:#dc2626;
                            style G fill:#fee2e2,stroke:#dc2626;
                            style H fill:#fef9c3,stroke:#ca8a04;
                          
                        </div>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">0/1-RTT 连接建立</h3>
                        <p>QUIC 通过合并传输层握手和加密握手（TLS 1.3）来减少连接建立的延迟。</p>
                        <ul>
                            <li><strong>首次连接 (1-RTT):</strong> 客户端发送 ClientHello (包含 QUIC 参数)，服务器响应 ServerHello + EncryptedExtensions + Certificate + CertificateVerify + Finished (包含 QUIC 参数和 TLS 记录)。客户端验证后即可发送加密的应用数据。通常需要 1 个 RTT。</li>
                            <li><strong>连接恢复 (0-RTT):</strong> 如果客户端之前已与服务器建立过连接，可以将会话信息缓存起来。下次连接时，在第一个包中就发送 ClientHello 和加密的应用数据。服务器验证通过后即可处理数据，实现 0-RTT。</li>
                            <li><strong>对比:</strong> TCP + TLS 1.2 通常需要 3-4 RTT，TCP + TLS 1.3 需要 2-3 RTT。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">连接迁移 (Connection Migration)</h3>
                        <p>QUIC 使用连接 ID (Connection ID) 而不是 IP 地址和端口号（五元组）来唯一标识一个连接。</p>
                        <ul>
                            <li><strong>机制:</strong> 连接 ID 由端点协商生成，可以有多个。当客户端的网络发生变化（如从 Wi-Fi 切换到蜂窝网络，导致 IP 或端口改变）时，它可以继续使用相同的连接 ID 向服务器发送数据包。</li>
                            <li><strong>效果:</strong> 服务器收到带有已知连接 ID 但来自新 IP/端口的数据包时，可以识别出是同一次连接，更新路径信息，连接得以保持，无需重新建立。这对于移动设备体验提升显著。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">头部压缩 (QPACK)</h3>
                        <p>QPACK 是为 HTTP/3 设计的头部压缩机制，解决了 HPACK 在多路复用场景下可能遇到的队头阻塞问题。</p>
                        <ul>
                            <li><strong>问题背景:</strong> HPACK 的动态表更新指令和引用该更新的 HEADERS 帧如果乱序到达，可能导致后续依赖该更新的流被阻塞。</li>
                            <li><strong>QPACK 解决方案:</strong>
                                <ul>
                                    <li>QPACK 使用独立的、单向的 QUIC 流来传输动态表的更新指令。</li>
                                    <li>HEADERS 帧只引用那些已被对端确认收到的动态表条目。</li>
                                </ul>
                            </li>
                            <li><strong>效果:</strong> 解耦了动态表更新和头部帧的传输，避免了压缩/解压缩过程中的队头阻塞。</li>
                        </ul>
                    </div>
                </section>

                <section id="http-message-structure" class="content-section fade-in-section" style="animation-delay: 0.2s;">
                    <h2 class="flex items-center head2"><span class="material-icons">description</span>HTTP 报文结构
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <p>HTTP 协议通过交换报文（Message）来进行通信，分为请求报文和响应报文。</p>
                        <h3 class="head3 mt-4">请求报文 (Request Message)</h3>
                        <pre><code class="language-http">
POST /path/to/resource HTTP/1.1     <-- 请求行 (Request Line): 方法(Method) URI 版本(Version)
Host: www.example.com               <-- 请求头 (Request Headers)
User-Agent: curl/7.64.1
Accept: */*
Content-Type: application/json
Content-Length: 27

{ "name": "Gemini", "type": "AI" }  <-- 消息体 (Message Body / Payload) - 可选
                        </code></pre>
                        <ul>
                            <li><strong>请求行 (Request Line):</strong> 包含请求方法、请求资源的 URI 和 HTTP 协议版本。</li>
                            <li><strong>请求头 (Request Headers):</strong> 包含关于请求或客户端的附加信息，格式为 `名称: 值`。</li>
                            <li><strong>空行 (Empty Line):</strong> 一个 CRLF（回车换行符），用于分隔头部和消息体。</li>
                            <li><strong>消息体 (Message Body):</strong> 包含请求发送的数据，如 POST 请求的表单数据或 JSON。GET 请求通常没有消息体。</li>
                        </ul>
                    </div>
                     <div class="content-card">
                        <h3 class="head3">响应报文 (Response Message)</h3>
                        <pre><code class="language-http">
HTTP/1.1 200 OK                     <-- 状态行 (Status Line): 版本(Version) 状态码(Status Code) 原因短语(Reason Phrase)
Date: Thu, 24 Apr 2025 02:31:00 GMT <-- 响应头 (Response Headers)
Server: Apache
Content-Type: application/json
Content-Length: 45

{ "message": "Success!", "dataId": 123 } <-- 消息体 (Message Body / Payload) - 可选
                        </code></pre>
                        <ul>
                            <li><strong>状态行 (Status Line):</strong> 包含 HTTP 协议版本、响应状态码和状态码的文本描述。</li>
                            <li><strong>响应头 (Response Headers):</strong> 包含关于响应或服务器的附加信息。</li>
                            <li><strong>空行 (Empty Line):</strong> 分隔头部和消息体。</li>
                            <li><strong>消息体 (Message Body):</strong> 包含响应返回的数据，如 HTML 页面、JSON 数据或图片。某些响应（如 204 No Content, 304 Not Modified）没有消息体。</li>
                        </ul>
                    </div>
                </section>

                <section id="http-methods" class="content-section fade-in-section" style="animation-delay: 0.25s;">
                    <h2 class="flex items-center head2"><span class="material-icons">terminal</span>HTTP 方法
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-base">基础</span>
                        <strong class="highlight">(重点)</strong>
                    </h2>
                    <div class="content-card">
                        <p>HTTP 方法（也称为谓词）指示了对请求资源要执行的操作。它们具有约定的语义。</p>
                        <div class="overflow-x-auto mt-4">
                            <table>
                                <thead>
                                    <tr>
                                        <th>方法</th>
                                        <th>语义 (Semantic)</th>
                                        <th>常见用途</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>GET</code></td>
                                        <td><strong>获取 (Retrieve)</strong> 指定资源的表示。</td>
                                        <td>请求网页、图片、API 数据查询。</td>
                                    </tr>
                                    <tr>
                                        <td><code>POST</code></td>
                                        <td>向服务器 <strong>提交 (Submit)</strong> 数据，通常导致服务器状态的改变或资源的创建。</td>
                                        <td>提交表单、上传文件、创建新资源 (如新用户、新订单)。</td>
                                    </tr>
                                    <tr>
                                        <td><code>PUT</code></td>
                                        <td>用请求中的有效载荷 <strong>替换 (Replace)</strong> 目标资源的全部当前状态。如果资源不存在，则创建。</td>
                                        <td>完整更新资源 (如更新用户配置文件的全部内容)。</td>
                                    </tr>
                                    <tr>
                                        <td><code>PATCH</code></td>
                                        <td>对资源应用 <strong>部分修改 (Partial Modify)</strong>。</td>
                                        <td>只更新资源的某个字段 (如只修改用户的邮箱地址)。</td>
                                    </tr>
                                    <tr>
                                        <td><code>DELETE</code></td>
                                        <td><strong>删除 (Delete)</strong> 指定的资源。</td>
                                        <td>删除用户、删除文章等。</td>
                                    </tr>
                                    <tr>
                                        <td><code>HEAD</code></td>
                                        <td>请求获取与 <code>GET</code> 请求相同的响应头，但 <strong>没有响应体 (No Body)</strong>。</td>
                                        <td>检查资源是否存在、获取资源的元数据（如最后修改时间、大小）而无需下载整个资源。</td>
                                    </tr>
                                    <tr>
                                        <td><code>OPTIONS</code></td>
                                        <td>请求获取目标资源支持的 <strong>通信选项 (Options)</strong>。</td>
                                        <td>查询服务器支持哪些 HTTP 方法 (<code>Allow</code> header)；CORS 预检请求 (Preflight Request)。</td>
                                    </tr>
                                    <tr>
                                        <td><code>CONNECT</code></td>
                                        <td>建立一个到由目标资源标识的服务器的隧道 (Tunnel)。</td>
                                        <td>用于 HTTPS 的 HTTP 代理。</td>
                                    </tr>
                                    <tr>
                                        <td><code>TRACE</code></td>
                                        <td>执行一个消息环回测试，主要用于诊断。</td>
                                        <td>调试代理服务器。(因安全风险，通常被禁用)</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section id="http-method-properties" class="content-section fade-in-section" style="animation-delay: 0.3s;">
                    <h2 class="flex items-center head2"><span class="material-icons">check_circle</span>HTTP 方法属性
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">安全性 (Safe)</h3>
                        <p>如果一个 HTTP 方法被认为是“安全的”，那么它就不应该改变服务器的状态。换句话说，它应该是只读操作。</p>
                        <ul>
                            <li><strong>安全方法:</strong> <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>。</li>
                            <li><strong>非安全方法:</strong> <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code>。</li>
                            <li><strong>意义:</strong> 搜索引擎爬虫、浏览器预取等机制可以安全地发起 GET 请求，而不必担心会意外修改数据。</li>
                        </ul>
                    </div>
                     <div class="content-card">
                        <h3 class="head3">幂等性 (Idempotent)</h3>
                        <p>如果一个 HTTP 方法是“幂等的”，那么对同一个资源执行一次或多次该方法所产生的效果应该是相同的（即服务器状态相同）。</p>
                        <ul>
                            <li><strong>幂等方法:</strong> <code>GET</code>, <code>HEAD</code>, <code>PUT</code>, <code>DELETE</code>, <code>OPTIONS</code>。</li>
                            <li><strong>非幂等方法:</strong> <code>POST</code>, <code>PATCH</code> (通常)。</li>
                            <li><strong>解释:</strong>
                                <ul>
                                    <li><code>GET /users/1</code>: 多次获取用户信息，服务器状态不变。</li>
                                    <li><code>PUT /users/1</code> (body: {name:"A"}): 多次用 A 替换用户 1 的信息，最终结果都是用户 1 的信息是 {name:"A"}。</li>
                                    <li><code>DELETE /users/1</code>: 多次删除用户 1，最终结果都是用户 1 不存在。</li>
                                    <li><code>POST /orders</code>: 多次提交创建订单请求，会创建多个订单。</li>
                                    <li><code>PATCH /users/1</code> (body: {increment: "visits"}): 多次执行增加访问次数的操作，每次都会改变状态。</li>
                                </ul>
                            </li>
                            <li><strong>意义:</strong> 在网络不稳定的情况下，客户端可以安全地重试幂等请求，而不必担心产生副作用。</li>
                        </ul>
                    </div>
                </section>

                <section id="get-vs-post" class="content-section fade-in-section" style="animation-delay: 0.35s;">
                    <h2 class="flex items-center head2"><span class="material-icons">compare_arrows</span>GET 与 POST 方法的区别
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-base">基础</span>
                        <strong class="highlight">(重点)</strong>
                    </h2>
                    <div class="content-card">
                        <p>GET 和 POST 是最常用的两种 HTTP 方法，它们的区别是面试中的经典问题。</p>
                        <div class="overflow-x-auto mt-4">
                            <table>
                                <thead>
                                    <tr>
                                        <th>比较维度</th>
                                        <th>GET</th>
                                        <th>POST</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>语义/目的</strong></td>
                                        <td>从服务器获取资源 (Read)</td>
                                        <td>向服务器提交数据，请求服务器处理 (Create/Update/Process)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>参数传递</strong></td>
                                        <td>参数附加在 URL 的查询字符串中 (<code>?key=value&key2=value2</code>)</td>
                                        <td>参数放在请求体 (Message Body) 中</td>
                                    </tr>
                                    <tr>
                                        <td><strong>幂等性</strong></td>
                                        <td>是 (Idempotent)</td>
                                        <td>否 (Non-idempotent)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>安全性</strong></td>
                                        <td>是 (Safe)</td>
                                        <td>否 (Not Safe)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>可缓存性</strong></td>
                                        <td>请求可被浏览器或代理缓存</td>
                                        <td>默认不可缓存 (除非响应头明确允许)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>浏览器历史/书签</strong></td>
                                        <td>请求会保留在历史记录中，可被收藏为书签</td>
                                        <td>请求默认不保留在历史记录中，不应被收藏</td>
                                    </tr>
                                    <tr>
                                        <td><strong>数据长度限制</strong></td>
                                        <td>URL 长度受浏览器和服务器限制 (通常几 KB)</td>
                                        <td>请求体大小理论上无限制 (受服务器配置影响)</td>
                                    </tr>
                                     <tr>
                                        <td><strong>数据类型</strong></td>
                                        <td>通常只传输 ASCII 字符</td>
                                        <td>可以传输二进制数据 (如文件上传)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>可见性</strong></td>
                                        <td>参数在 URL 中可见，相对不安全</td>
                                        <td>参数在请求体中，相对安全 (但仍可通过开发者工具查看，HTTPS 加密是关键)</td>
                                    </tr>
                                    <tr>
                                        <td><strong>后退/刷新</strong></td>
                                        <td>无害</td>
                                        <td>浏览器通常会警告用户数据可能被重新提交</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="mt-4 text-sm text-gray-600"><strong>总结:</strong> 根据操作的语义选择方法。查询数据用 GET，提交或修改数据用 POST (或其他如 PUT/PATCH/DELETE)。不要用 GET 来执行有副作用的操作。</p>
                    </div>
                </section>

                <section id="put-vs-patch" class="content-section fade-in-section" style="animation-delay: 0.4s;">
                    <h2 class="flex items-center head2"><span class="material-icons">difference</span>PUT 与 PATCH 方法的区别
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <p>PUT 和 PATCH 都用于更新服务器上的资源，但它们的操作方式不同。</p>
                        <div class="overflow-x-auto mt-4">
                            <table>
                                <thead>
                                    <tr>
                                        <th>比较维度</th>
                                        <th>PUT</th>
                                        <th>PATCH</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><strong>操作范围</strong></td>
                                        <td><strong>整体替换 (Replace)</strong>: 请求体包含资源的完整表示，用于替换目标资源的全部内容。如果资源不存在，则创建。</td>
                                        <td><strong>部分更新 (Partial Update)</strong>: 请求体包含对资源的更改指令或部分数据，用于修改目标资源的特定字段或部分内容。</td>
                                    </tr>
                                    <tr>
                                        <td><strong>幂等性</strong></td>
                                        <td><strong>是 (Idempotent)</strong>: 多次发送相同的 PUT 请求，资源最终状态是一致的。</td>
                                        <td><strong>通常否 (Non-idempotent)</strong>: 多次发送相同的 PATCH 请求（如增加计数器），资源状态会持续改变。但如果 PATCH 操作本身是幂等的（如设置某个字段为固定值），则该 PATCH 请求也是幂等的。</td>
                                    </tr>
                                    <tr>
                                        <td><strong>带宽消耗</strong></td>
                                        <td>可能更高，因为需要发送资源的完整表示。</td>
                                        <td>通常更低，因为只发送需要修改的部分。</td>
                                    </tr>
                                    <tr>
                                        <td><strong>使用场景</strong></td>
                                        <td>需要完全替换资源内容时。</td>
                                        <td>只需要修改资源的部分属性时，更高效。</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        <p class="mt-4 text-sm text-gray-600"><strong>示例:</strong> 假设有一个用户信息 <code>/users/1</code> 内容为 <code>{"name": "Alice", "email": "alice@example.com"}</code>。</p>
                        <ul>
                            <li><code>PUT /users/1</code> with body <code>{"name": "Alice V2"}</code> 会导致资源变为 <code>{"name": "Alice V2"}</code> (email 丢失)。</li>
                            <li><code>PATCH /users/1</code> with body <code>{"name": "Alice V2"}</code> (使用如 JSON Merge Patch) 会导致资源变为 <code>{"name": "Alice V2", "email": "alice@example.com"}</code> (只更新 name)。</li>
                        </ul>
                    </div>
                </section>

                <section id="http-status-codes" class="content-section fade-in-section" style="animation-delay: 0.45s;">
                    <h2 class="flex items-center head2"><span class="material-icons">tag</span>HTTP 状态码
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-base">基础</span>
                        <strong class="highlight">(重点)</strong>
                    </h2>
                    <div class="content-card">
                        <p>HTTP 状态码是服务器对客户端请求的响应代码，用三位数字表示。它们被分为五类：</p>
                        <ul class="space-y-2 mt-4">
                            <li><span class="font-semibold text-blue-600">1xx (Informational / 信息性):</span> 表示请求已接收，继续处理。不常用。
                                <ul><li><code>100 Continue</code>: 客户端应继续发送请求的剩余部分。</li></ul>
                            </li>
                            <li><span class="font-semibold text-green-600">2xx (Success / 成功):</span> 表示请求已成功被服务器接收、理解、并接受。
                                <ul>
                                    <li><code>200 OK</code>: 请求成功。最常见的成功状态码。</li>
                                    <li><code>201 Created</code>: 请求成功，并且服务器创建了新的资源。</li>
                                    <li><code>204 No Content</code>: 请求成功，但响应报文不含实体的主体部分 (没有 Body)。通常用于 DELETE 或 PUT 成功后。</li>
                                </ul>
                            </li>
                            <li><span class="font-semibold text-yellow-600">3xx (Redirection / 重定向):</span> 表示需要客户端采取进一步的操作才能完成请求。
                                <ul>
                                    <li><code>301 Moved Permanently</code>: 请求的资源已被永久移动到新 URL。</li>
                                    <li><code>302 Found</code>: 请求的资源临时从不同 URL 响应 (常用于临时重定向)。</li>
                                    <li><code>304 Not Modified</code>: 资源未修改，客户端可以使用缓存版本。</li>
                                    <li><code>307 Temporary Redirect</code>: 类似 302，但明确要求客户端不得改变请求方法。</li>
                                    <li><code>308 Permanent Redirect</code>: 类似 301，但明确要求客户端不得改变请求方法。</li>
                                </ul>
                            </li>
                            <li><span class="font-semibold text-orange-600">4xx (Client Error / 客户端错误):</span> 表示客户端可能发生了错误，妨碍了服务器的处理。
                                <ul>
                                    <li><code>400 Bad Request</code>: 请求语法错误或参数无效。</li>
                                    <li><code>401 Unauthorized</code>: 请求要求身份验证 (需要登录或提供有效凭证)。</li>
                                    <li><code>403 Forbidden</code>: 服务器理解请求，但拒绝执行 (权限不足)。</li>
                                    <li><code>404 Not Found</code>: 服务器找不到请求的资源。</li>
                                    <li><code>405 Method Not Allowed</code>: 服务器禁止使用当前 HTTP 方法访问该资源。</li>
                                    <li><code>409 Conflict</code>: 请求与服务器当前状态冲突 (如创建已存在的资源)。</li>
                                </ul>
                            </li>
                            <li><span class="font-semibold text-red-600">5xx (Server Error / 服务器错误):</span> 表示服务器在处理请求的过程中发生了错误。
                                <ul>
                                    <li><code>500 Internal Server Error</code>: 服务器内部错误，无法完成请求。</li>
                                    <li><code>502 Bad Gateway</code>: 作为网关或代理的服务器从上游服务器收到了无效响应。</li>
                                    <li><code>503 Service Unavailable</code>: 服务器暂时无法处理请求 (过载或维护)。</li>
                                    <li><code>504 Gateway Timeout</code>: 作为网关或代理的服务器未及时从上游服务器获得响应。</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </section>

                <section id="status-code-details" class="content-section fade-in-section" style="animation-delay: 0.5s;">
                    <h2 class="flex items-center head2"><span class="material-icons">rule</span>状态码细节辨析
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">301 vs 302 (vs 307 vs 308)</h3>
                        <ul>
                            <li><strong>301 Moved Permanently:</strong>
                                <ul>
                                    <li>语义: 资源已 <strong>永久</strong> 移动到新的 URL。</li>
                                    <li>行为: 浏览器/搜索引擎会更新书签/索引。</li>
                                    <li>方法变更: 原始规范允许 GET/HEAD 外的方法变更为 GET，但现代浏览器通常不会这样做。</li>
                                    <li>用途: 网站改版、域名更换 (SEO 友好)。</li>
                                </ul>
                            </li>
                            <li><strong>302 Found:</strong>
                                <ul>
                                    <li>语义: 资源 <strong>临时</strong> 可在不同 URL 找到。</li>
                                    <li>行为: 浏览器/搜索引擎不会更新记录，下次还会访问原 URL。</li>
                                    <li>方法变更: 历史上很多实现会将 POST 请求改为 GET 请求。</li>
                                    <li>用途: 临时的活动页面、未登录跳转登录页。</li>
                                </ul>
                            </li>
                             <li><strong>307 Temporary Redirect:</strong>
                                <ul>
                                    <li>语义: 类似 302，资源 <strong>临时</strong> 可在不同 URL 找到。</li>
                                    <li>行为: 要求客户端 <strong>不得改变</strong> 请求方法。</li>
                                    <li>用途: 需要保持原请求方法（如 POST）的临时重定向。</li>
                                </ul>
                            </li>
                             <li><strong>308 Permanent Redirect:</strong>
                                <ul>
                                    <li>语义: 类似 301，资源已 <strong>永久</strong> 移动。</li>
                                    <li>行为: 要求客户端 <strong>不得改变</strong> 请求方法。</li>
                                    <li>用途: 需要保持原请求方法的永久重定向。</li>
                                </ul>
                            </li>
                        </ul>
                        <p class="text-sm mt-2"><strong>总结:</strong> 优先使用 301/308 表示永久移动，302/307 表示临时移动。如果需要保持请求方法，使用 307/308。</p>
                    </div>
                     <div class="content-card">
                        <h3 class="head3">401 Unauthorized vs 403 Forbidden</h3>
                        <ul>
                            <li><strong>401 Unauthorized:</strong>
                                <ul>
                                    <li>语义: 请求要求 <strong>身份验证</strong>。客户端需要提供有效的凭证（如通过 <code>Authorization</code> 头）。</li>
                                    <li>场景: 用户未登录；提供的用户名/密码或 Token 无效/过期。</li>
                                    <li>响应头: 通常包含 <code>WWW-Authenticate</code> 头，告知客户端如何进行认证。</li>
                                </ul>
                            </li>
                            <li><strong>403 Forbidden:</strong>
                                <ul>
                                    <li>语义: 服务器理解请求，但 <strong>拒绝授权</strong> 执行。客户端身份已确认（或无关），但没有访问该资源的权限。</li>
                                    <li>场景: 用户已登录，但试图访问管理员页面；IP 地址被禁止访问。</li>
                                    <li>响应头: 不会包含 <code>WWW-Authenticate</code> 头。</li>
                                </ul>
                            </li>
                        </ul>
                         <p class="text-sm mt-2"><strong>总结:</strong> 401 是“你没票/票过期了”，403 是“你有票，但这票不能进这个门”。</p>
                    </div>
                     <div class="content-card">
                        <h3 class="head3">502 Bad Gateway vs 504 Gateway Timeout</h3>
                        <p>这两个错误都发生在服务器作为网关或代理时。</p>
                        <ul>
                            <li><strong>502 Bad Gateway:</strong>
                                <ul>
                                    <li>语义: 网关/代理服务器从其需要访问的 <strong>上游服务器</strong> 收到了一个 <strong>无效的响应</strong>。</li>
                                    <li>原因: 上游服务器崩溃、网络问题导致响应损坏、协议不兼容等。</li>
                                </ul>
                            </li>
                            <li><strong>504 Gateway Timeout:</strong>
                                <ul>
                                    <li>语义: 网关/代理服务器在规定的时间内 <strong>未能从上游服务器获得响应</strong>。</li>
                                    <li>原因: 上游服务器处理请求过慢、网络连接超时、DNS 解析问题等。</li>
                                </ul>
                            </li>
                        </ul>
                        <p class="text-sm mt-2"><strong>总结:</strong> 502 是上游服务器“说胡话了”，504 是上游服务器“没理我”。</p>
                    </div>
                </section>

                <section id="http-body-encoding" class="content-section fade-in-section" style="animation-delay: 0.55s;">
                    <h2 class="flex items-center head2"><span class="material-icons">compress</span>HTTP 消息体与编码
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">Content-Type</h3>
                        <p>指定消息体 (Payload) 的 <strong>媒体类型 (Media Type / MIME Type)</strong>，告知接收方如何解析数据。</p>
                        <ul>
                            <li><strong>常见值:</strong>
                                <ul>
                                    <li><code>text/html</code>: HTML 文档</li>
                                    <li><code>text/plain</code>: 纯文本</li>
                                    <li><code>text/css</code>: CSS 样式表</li>
                                    <li><code>application/javascript</code>: JavaScript 代码</li>
                                    <li><code>application/json</code>: JSON 数据</li>
                                    <li><code>application/xml</code>: XML 数据</li>
                                    <li><code>application/octet-stream</code>: 二进制数据流 (通用)</li>
                                    <li><code>image/jpeg</code>, <code>image/png</code>, <code>image/gif</code>: 图片</li>
                                    <li><code>multipart/form-data</code>: 在 POST 请求中用于上传文件和表单数据</li>
                                    <li><code>application/x-www-form-urlencoded</code>: 表单数据编码 (默认)</li>
                                </ul>
                            </li>
                            <li>可以包含字符集参数，如 <code>Content-Type: text/html; charset=utf-8</code>。</li>
                        </ul>
                    </div>
                     <div class="content-card">
                        <h3 class="head3">Content-Encoding</h3>
                        <p>指示在传输过程中对消息体使用了何种 <strong>内容编码 (通常是压缩)</strong>。接收方需要先解码才能得到原始数据。</p>
                        <ul>
                            <li><strong>常见值:</strong>
                                <ul>
                                    <li><code>gzip</code>: 使用 Lempel-Ziv coding (LZ77) 和 32-bit CRC。最常用。</li>
                                    <li><code>deflate</code>: 使用 zlib 结构和 deflate 压缩算法。</li>
                                    <li><code>br</code>: Brotli 压缩算法，通常比 gzip 压缩率更高。</li>
                                    <li><code>identity</code>: 未使用编码 (默认)。</li>
                                </ul>
                            </li>
                            <li>客户端通过 <code>Accept-Encoding</code> 请求头告知服务器它支持的编码类型。</li>
                        </ul>
                    </div>
                     <div class="content-card">
                        <h3 class="head3">Transfer-Encoding: chunked</h3>
                        <p>指示消息体使用 <strong>分块传输编码</strong>。这允许服务器在不知道内容总长度的情况下开始发送响应。</p>
                        <ul>
                            <li><strong>机制:</strong> 消息体被分成若干块 (chunk)，每块包含其自身的大小 (十六进制) 和数据，最后以一个大小为 0 的块结束。</li>
                            <li><strong>用途:</strong> 对于动态生成的内容（如流式数据、长轮询），服务器无需缓冲整个响应即可发送；HTTP/1.1 持久连接中，可以在不关闭连接的情况下确定消息体的结束。</li>
                            <li><strong>注意:</strong> <code>Transfer-Encoding: chunked</code> 和 <code>Content-Length</code> 头是互斥的。HTTP/2 使用其自身的帧机制，不再需要 chunked 编码。</li>
                        </ul>
                        <pre><code class="language-http">
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

4\r\n        <-- 块大小 (4字节)
Wiki\r\n      <-- 块数据
5\r\n        <-- 块大小 (5字节)
pedia\r\n     <-- 块数据
E\r\n        <-- 块大小 (14字节)
 in \r\n
chunks.\r\n  <-- 块数据
0\r\n        <-- 结束块 (大小为0)
\r\n         <-- 结束标记
                        </code></pre>
                    </div>
                </section>

                <section id="http-core-headers" class="content-section fade-in-section" style="animation-delay: 0.6s;">
                    <h2 class="flex items-center head2"><span class="material-icons">view_headline</span>HTTP 核心头部
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <p>HTTP 头部是协议的关键组成部分，用于传递关于请求、响应或消息体的重要元数据。以下是一些核心头部：</p>
                        <div class="overflow-x-auto mt-4">
                            <table>
                                <thead>
                                    <tr>
                                        <th>头部名称</th>
                                        <th>类型</th>
                                        <th>描述与用途</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr> <td><code>Host</code></td> <td>请求头</td> <td>指定请求的目标服务器域名和端口号。HTTP/1.1 必需，用于支持虚拟主机。</td> </tr>
                                    <tr> <td><code>Connection</code></td> <td>通用头 (请求/响应)</td> <td>控制当前连接的管理选项。常见值：<code>keep-alive</code> (保持连接), <code>close</code> (关闭连接)。HTTP/1.1 默认为 keep-alive。</td> </tr>
                                    <tr> <td><code>User-Agent</code></td> <td>请求头</td> <td>包含发起请求的用户代理（通常是浏览器）的信息。</td> </tr>
                                    <tr> <td><code>Accept</code></td> <td>请求头</td> <td>告知服务器客户端能够理解的内容类型 (MIME types)。</td> </tr>
                                    <tr> <td><code>Accept-Encoding</code></td> <td>请求头</td> <td>告知服务器客户端支持的内容编码（压缩算法）。</td> </tr>
                                    <tr> <td><code>Accept-Language</code></td> <td>请求头</td> <td>告知服务器客户端偏好的自然语言。</td> </tr>
                                    <tr> <td><code>Content-Type</code></td> <td>实体头 (请求/响应)</td> <td>指示消息体的媒体类型。</td> </tr>
                                    <tr> <td><code>Content-Length</code></td> <td>实体头 (请求/响应)</td> <td>指示消息体的长度（字节）。与 <code>Transfer-Encoding: chunked</code> 互斥。</td> </tr>
                                    <tr> <td><code>Content-Encoding</code></td> <td>实体头 (请求/响应)</td> <td>指示消息体使用的内容编码（压缩）。</td> </tr>
                                    <tr> <td><code>Cache-Control</code></td> <td>通用头 (请求/响应)</td> <td>指定缓存指令。例如 <code>no-cache</code>, <code>no-store</code>, <code>public</code>, <code>private</code>, <code>max-age=...</code>。</td> </tr>
                                    <tr> <td><code>Expires</code></td> <td>响应头</td> <td>指定响应过期的日期/时间 (HTTP/1.0 缓存控制)。优先级低于 <code>Cache-Control</code>。</td> </tr>
                                    <tr> <td><code>ETag</code></td> <td>响应头</td> <td>资源的特定版本标识符 (实体标签)。用于缓存验证。</td> </tr>
                                    <tr> <td><code>If-None-Match</code></td> <td>请求头</td> <td>用于条件 GET 请求。如果服务器资源的 ETag 与此值匹配，则返回 304 Not Modified。</td> </tr>
                                    <tr> <td><code>Last-Modified</code></td> <td>响应头</td> <td>资源最后修改的日期/时间。</td> </tr>
                                    <tr> <td><code>If-Modified-Since</code></td> <td>请求头</td> <td>用于条件 GET 请求。如果资源在此时间之后未修改，则返回 304 Not Modified。</td> </tr>
                                    <tr> <td><code>Cookie</code></td> <td>请求头</td> <td>包含先前由服务器通过 <code>Set-Cookie</code> 头存储的 HTTP Cookie。</td> </tr>
                                    <tr> <td><code>Set-Cookie</code></td> <td>响应头</td> <td>服务器向客户端发送 Cookie 以供存储。</td> </tr>
                                    <tr> <td><code>Origin</code></td> <td>请求头</td> <td>指示请求来源的域。主要用于 CORS。</td> </tr>
                                    <tr> <td><code>Access-Control-Allow-Origin</code></td> <td>响应头</td> <td>CORS 响应头，指定允许访问该资源的来源域。</td> </tr>
                                    <tr> <td><code>Access-Control-Allow-Methods</code></td> <td>响应头</td> <td>CORS 响应头 (预检请求)，指定允许的 HTTP 方法。</td> </tr>
                                    <tr> <td><code>Access-Control-Allow-Headers</code></td> <td>响应头</td> <td>CORS 响应头 (预检请求)，指定允许的 HTTP 请求头。</td> </tr>
                                    <tr> <td><code>Location</code></td> <td>响应头</td> <td>用于重定向响应 (3xx)，指示资源的新的 URL。</td> </tr>
                                    <tr> <td><code>Authorization</code></td> <td>请求头</td> <td>包含用于向服务器证明用户代理身份的凭证。</td> </tr>
                                    <tr> <td><code>WWW-Authenticate</code></td> <td>响应头</td> <td>用于 401 响应，定义应使用的身份验证方法。</td> </tr>
                                    <tr> <td><code>Referer</code></td> <td>请求头</td> <td>指示请求来源页面的 URL (可能涉及隐私问题)。</td> </tr>
                                    <tr> <td><code>Server</code></td> <td>响应头</td> <td>包含处理请求的源头服务器软件的信息。</td> </tr>
                                    <tr> <td><code>Date</code></td> <td>响应头</td> <td>包含消息发送的日期和时间。</td> </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

            </article>
        </main>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        mermaid.initialize({ startOnLoad: true, theme: 'neutral' });

        // JavaScript for TOC highlighting and fade-in animations
        // (Copied and adapted from 01-Network-Basics.html)
        document.addEventListener('DOMContentLoaded', () => {

            // --- TOC Highlighting & Fade-in ---
            const sections = document.querySelectorAll('main section[id]'); // Observe sections with IDs
            const tocLinks = document.querySelectorAll('#local-toc a');
            const mainContentSections = document.querySelectorAll('main > article > section.content-section'); // Target sections for fade-in

            // TOC Highlighting Logic
            const tocObserverOptions = {
                root: null,
                rootMargin: '-20% 0px -60% 0px', // Prioritize sections near the top
                threshold: 0
            };
            let lastActiveTocLink = null;

            const tocObserverCallback = (entries) => {
                let bestVisibleEntry = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (!bestVisibleEntry || entry.boundingClientRect.top < bestVisibleEntry.boundingClientRect.top) {
                            bestVisibleEntry = entry;
                        }
                    }
                });

                if (bestVisibleEntry) {
                    const id = bestVisibleEntry.target.getAttribute('id');
                    const activeLink = document.querySelector(`#local-toc a[href="#${id}"]`);

                    if (activeLink && activeLink !== lastActiveTocLink) {
                        if (lastActiveTocLink) {
                            lastActiveTocLink.classList.remove('active');
                        }
                        activeLink.classList.add('active');
                        lastActiveTocLink = activeLink;
                    }
                }
            };

            const tocObserver = new IntersectionObserver(tocObserverCallback, tocObserverOptions);
            sections.forEach(section => tocObserver.observe(section));

            // Initial active link check
            const currentHash = window.location.hash;
            if (currentHash) {
                const initialActiveLink = document.querySelector(`#local-toc a[href="${currentHash}"]`);
                if (initialActiveLink) {
                    tocLinks.forEach(link => link.classList.remove('active'));
                    initialActiveLink.classList.add('active');
                    lastActiveTocLink = initialActiveLink;
                }
            } else if (tocLinks.length > 0 && !lastActiveTocLink) {
                tocLinks[0].classList.add('active');
                lastActiveTocLink = tocLinks[0];
            }

            // Fade-in Animation Logic for Sections
            const fadeObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
            const fadeObserverCallback = (entries, observer) => {
                entries.forEach((entry) => {
                    // Use the index from the querySelectorAll result for consistent delay
                    const delayIndex = Array.from(mainContentSections).indexOf(entry.target);
                    if (entry.isIntersecting) {
                        entry.target.style.animationDelay = `${delayIndex * 0.05}s`;
                        entry.target.classList.add('fade-in-section');
                        observer.unobserve(entry.target);
                    }
                });
            };
            const fadeObserver = new IntersectionObserver(fadeObserverCallback, fadeObserverOptions);
            mainContentSections.forEach(section => fadeObserver.observe(section));

             // Activate Prism for syntax highlighting
             // Ensure Prism runs *after* content is potentially loaded/visible
             setTimeout(() => {
                Prism.highlightAll();
             }, 0);


        }); // End of DOMContentLoaded listener
    </script>

</body>

</html>
