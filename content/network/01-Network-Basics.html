<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>网络基础</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
        integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="../../global.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


    <style>
        /* Minimal inline styles - Primarily rely on global.css and Tailwind */

        /* --- Base & Layout Adjustments --- */
        html {
            scroll-padding-top: 6rem;
            /* Adjust based on sticky nav height */
        }

        body {
            /* Base font, bg, color assumed from global.css */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-family: 'Inter', sans-serif;
            scroll-behavior: smooth;
            background-color: #f8fafc;
            /* Light gray background */
        }

        /* --- Typography --- */
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            scroll-margin-top: 6rem;
            /* Offset for sticky nav */
        }

        h2 {
            border-bottom: 1px solid var(--border-color-light);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
            /* Consistent spacing */
        }

        h3 {
            margin-top: 0;
            /* Reset top margin as card handles spacing */
            margin-bottom: 1rem;
            color: var(--primary-color-dark);
            /* Use a distinct color for card titles */
            font-size: 1.25rem;
            /* Ensure size consistency */
        }

        h4 {
            /* Sub-heading for visualizations or inner sections */
            font-size: 1.1rem;
            font-weight: 600;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-color-dark);
        }

        h5 {
            /* Smaller sub-heading */
            font-size: 1rem;
            font-weight: 600;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            color: var(--text-color-default);
        }


        /* Style for frequency/level tags */
        .level-tag {
            display: inline-block;
            margin-left: 0.5rem;
            font-size: 0.75rem;
            /* text-xs */
            font-weight: 500;
            /* font-medium */
            padding: 0.1rem 0.5rem;
            border-radius: 0.25rem;
            /* rounded-sm */
            vertical-align: middle;
            border: 1px solid transparent;
        }

        .level-tag-high {
            background-color: var(--danger-color-light);
            color: var(--danger-color);
            border-color: var(--danger-color);
        }

        .level-tag-medium {
            background-color: var(--warning-color-light);
            color: var(--warning-color);
            border-color: var(--warning-color);
        }

        .level-tag-low {
            background-color: var(--secondary-color-light);
            color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        .level-tag-base {
            background-color: var(--bg-color-lighter);
            color: var(--text-color-light);
            border-color: var(--border-color-default);
        }

        .level-tag-advanced {
            background-color: var(--primary-color-light);
            color: var(--primary-color-dark);
            border-color: var(--primary-color);
        }

        /* --- Fade-in Animation --- */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in-section {
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* --- Content Card Adjustments --- */
        .content-card {
            margin-bottom: 1.5rem;
            /* Ensure spacing between cards */
        }

        .content-card:last-child {
            margin-bottom: 0;
        }

        .content-section>.content-card+.content-card {
            margin-top: 1.5rem;
            /* Space between cards within the same section */
        }

        /* --- List Styling within Content --- */
        article ul {
            list-style: disc;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }

        article ol {
            list-style: decimal;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }

        article li {
            margin-bottom: 0.5em;
        }

        article ul ul,
        article ol ol,
        article ul ol,
        article ol ul {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

        /* --- Code Block Styling --- */
        pre code {
            display: block;
            padding: 1rem;
            background-color: #1a202c;
            /* Darker background */
            color: #e2e8f0;
            /* Lighter text */
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            /* Use mono font */
            font-size: 0.875em;
            overflow-x: auto;
            position: relative;
            border: 1px solid #2d3748;
        }

        /* Inline code */
        *:not(pre)>code {
            background-color: rgba(17, 24, 39, 0.05);
            /* Light gray background */
            color: #DC2626;
            /* Reddish text color */
            padding: 0.1em 0.3em;
            border-radius: 0.25rem;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9em;
            /* Slightly smaller */
        }

        /* --- Table Styling --- */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1rem;
        }

        th,
        td {
            border: 1px solid var(--border-color-default);
            padding: 0.5rem 0.75rem;
            text-align: left;
        }

        th {
            background-color: var(--bg-color-lighter);
            font-weight: 600;
        }

        tbody tr:nth-child(odd) {
            background-color: var(--bg-color-light);
        }

        tbody tr:hover {
            background-color: #eff6ff;
        }

        /* blue-50 */

        /* --- Mermaid Diagram Styling --- */
        .mermaid {
            transition: opacity 0.5s ease-in-out;
            margin: 1.5rem 0;
            text-align: center;
            background-color: var(--bg-color-light);
            padding: 1rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border-color-light);
        }

        .mermaid svg {
            max-width: 100%;
            height: auto;
            display: block;
            margin: auto;
        }

        /* --- Interactive Handshake/Wave Steps --- */
        .interactive-step {
            opacity: 0.4;
            transition: opacity 0.5s ease-in-out, transform 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
            padding: 0.75rem;
            border-left: 4px solid transparent;
            margin-bottom: 0.5rem;
            border-radius: 4px;
            background-color: #f8fafc;
            /* Default background */
        }

        .interactive-step.active {
            opacity: 1;
            border-left-color: #4299e1;
            /* Blue */
            background-color: #ebf8ff;
            transform: scale(1.02);
        }

        .interactive-step code {
            background-color: rgba(219, 234, 254, 0.8);
            /* Light blue background for code */
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 0.85em;
            border: 1px solid #bfdbfe;
        }

        .interactive-step.active code {
            background-color: rgba(255, 255, 255, 0.8);
        }

        /* --- State Tags (Copied from 传输层.html) --- */
        .state-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
            margin-left: 8px;
            border: 1px solid;
        }

        .state-closed {
            background-color: #e2e8f0;
            color: #4a5568;
            border-color: #cbd5e0;
        }

        .state-listen {
            background-color: #f0f9ff;
            color: #075985;
            border-color: #bae6fd;
        }

        /* Added Listen */
        .state-syn-sent {
            background-color: #fffbeb;
            color: #b45309;
            border-color: #fcd34d;
        }

        .state-syn-rcvd {
            background-color: #fef3c7;
            color: #92400e;
            border-color: #fde68a;
        }

        .state-established {
            background-color: #dcfce7;
            color: #166534;
            border-color: #86efac;
        }

        .state-fin-wait-1 {
            background-color: #ffedd5;
            color: #9a3412;
            border-color: #fed7aa;
        }

        .state-fin-wait-2 {
            background-color: #fee2e2;
            color: #991b1b;
            border-color: #fecaca;
        }

        .state-close-wait {
            background-color: #f3e8ff;
            color: #6b21a8;
            border-color: #e9d5ff;
        }

        .state-last-ack {
            background-color: #fae8ff;
            color: #86198f;
            border-color: #f5d0fe;
        }

        .state-time-wait {
            background-color: #e0e7ff;
            color: #3730a3;
            border-color: #c7d2fe;
        }

        /* --- Header Field Visualization (Copied from 传输层.html) --- */
        .header-field {
            transition: background-color 0.2s ease;
        }

        .header-info-display {
            margin-top: 10px;
            font-size: 0.9em;
            background-color: #f7fafc;
            padding: 10px;
            border-radius: 4px;
            border: 1px dashed #cbd5e0;
            min-height: 40px;
            transition: background-color 0.3s ease;
        }

        .header-info-display:empty {
            background-color: transparent;
            border-style: solid;
        }

        /* --- TCP Reliability Simulation (Copied & Prefixed from 传输层.html) --- */
        .tcpRelSim_packet,
        .tcpRelSim_ack {
            transition: all 2.8s ease-in-out, background-color 0.3s ease, border-color 0.3s ease, transform 0.3s ease;
            position: absolute;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.25rem;
            border-radius: 0.25rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            font-size: 0.7rem;
            font-weight: 500;
            min-width: 40px;
            height: 24px;
        }

        .tcpRelSim_packet {
            border: 1px solid #60a5fa;
            background-color: #dbeafe;
            color: #1e40af;
        }

        .tcpRelSim_ack {
            border: 1px solid #34d399;
            background-color: #d1fae5;
            color: #065f46;
        }

        .tcpRelSim_packet-losing {
            border-color: #ef4444 !important;
            background-color: #fee2e2 !important;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .tcpRelSim_packet-lost {
            opacity: 0;
            transform: scale(0.5) !important;
            transition: all 0.8s ease-in !important;
        }

        .tcpRelSim_packet-arrived-cue {
            border-color: #10b981 !important;
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }

        .tcpRelSim_packet-buffered {
            background-color: #fde68a;
            border-color: #facc15;
            transform: scale(0.9);
            position: static !important;
            margin: 1px;
        }

        .tcpRelSim_packet-delivered {
            background-color: #dcfce7;
            border-color: #22c55e;
            position: static !important;
            margin: 1px;
        }

        .tcpRelSim_packet-retransmitted {
            border-style: dashed;
            border-color: #f87171;
            background-color: #fef2f2;
        }

        .tcpRelSim_highlight-window {
            border: 2px solid #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
            transition: all 0.5s ease-in-out;
        }

        .tcpRelSim_buffer-slot {
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tcpRelSim_app-layer-area {
            min-height: 50px;
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            justify-content: center;
            align-items: center;
        }

        .tcpRelSim_status-text {
            min-height: 1.5em;
            transition: opacity 0.5s ease-in-out;
        }

        .tcpRelSim_rto-timer {
            font-size: 0.7rem;
            color: #6b7280;
            display: inline-block;
            margin-left: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .tcpRelSim_rto-timer.active {
            opacity: 1;
        }

        .tcpRelSim_rto-timer.expired {
            color: #ef4444;
            font-weight: bold;
            opacity: 1;
        }

        #tcpRelSim_network-path {
            position: absolute;
            bottom: 48%;
            left: 7%;
            width: 86%;
            height: 2px;
            background-image: linear-gradient(to right, #9ca3af 50%, transparent 50%);
            background-size: 10px 2px;
            z-index: 1;
        }

        /* --- TCP Flow Control Simulation (Copied & Prefixed from 传输层.html) --- */
        .tcpFlowSim_packet {
            width: 30px;
            height: 30px;
            border: 1px solid #9CA3AF;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 0.25rem;
            margin: 2px;
            transition: background-color 0.5s ease-in-out, border-color 0.5s ease-in-out, opacity 0.5s ease-in-out;
            position: absolute;
            background-color: #E5E7EB;
            color: #374151;
        }

        .tcpFlowSim_packet.tcpFlowSim_sent {
            background-color: #BFDBFE;
            border-color: #93C5FD;
        }

        .tcpFlowSim_packet.tcpFlowSim_acked {
            background-color: #A7F3D0;
            border-color: #6EE7B7;
        }

        .tcpFlowSim_packet.tcpFlowSim_received {
            background-color: #FDE68A;
            border-color: #FCD34D;
        }

        .tcpFlowSim_packet.tcpFlowSim_buffered {
            background-color: #FBCFE8;
            border-color: #F9A8D4;
        }

        .tcpFlowSim_buffer {
            display: flex;
            flex-wrap: wrap;
            border: 2px dashed #D1D5DB;
            padding: 5px;
            min-height: 50px;
            position: relative;
            background-color: #F9FAFB;
            border-radius: 0.375rem;
            margin-bottom: 10px;
            overflow: hidden;
        }

        .tcpFlowSim_window-segment {
            position: absolute;
            border: 2px solid;
            pointer-events: none;
            box-sizing: border-box;
            border-radius: 0.25rem;
            opacity: 0.8;
            transition: all 0.3s ease-in-out;
        }

        .tcpFlowSim_send-window-segment {
            border-color: #3B82F6;
            background-color: rgba(59, 130, 246, 0.15);
        }

        .tcpFlowSim_recv-window-segment {
            border-color: #F59E0B;
            background-color: rgba(245, 158, 11, 0.15);
        }

        .tcpFlowSim_control-button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-weight: 600;
            transition: background-color 0.2s;
            cursor: pointer;
            margin: 0 0.25rem;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tcpFlowSim_control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tcpFlowSim_control-button.tcpFlowSim_send {
            background-color: #3B82F6;
            color: white;
            border-color: #2563EB;
        }

        .tcpFlowSim_control-button.tcpFlowSim_send:hover:not(:disabled) {
            background-color: #2563EB;
        }

        .tcpFlowSim_control-button.tcpFlowSim_process {
            background-color: #10B981;
            color: white;
            border-color: #059669;
        }

        .tcpFlowSim_control-button.tcpFlowSim_process:hover:not(:disabled) {
            background-color: #059669;
        }

        .tcpFlowSim_control-button.tcpFlowSim_reset {
            background-color: #6B7280;
            color: white;
            border-color: #4B5563;
        }

        .tcpFlowSim_control-button.tcpFlowSim_reset:hover:not(:disabled) {
            background-color: #4B5563;
        }

        .tcpFlowSim_arrow {
            position: absolute;
            width: auto;
            height: auto;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 1.5s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
            z-index: 5;
            color: white;
            white-space: nowrap;
            min-width: 40px;
        }

        .tcpFlowSim_arrow.tcpFlowSim_data {
            background-color: #60A5FA;
        }

        .tcpFlowSim_arrow.tcpFlowSim_ack {
            background-color: #FCD34D;
            color: #78350F;
            min-width: 50px;
        }

        .tcpFlowSim_arrow.tcpFlowSim_probe {
            background-color: #F87171;
            color: white;
        }

        .tcpFlowSim_tooltip {
            position: absolute;
            background-color: #1F2937;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            z-index: 10;
            bottom: 105%;
            left: 50%;
            transform: translateX(-50%);
        }

        .tcpFlowSim_has-tooltip:hover .tcpFlowSim_tooltip {
            visibility: visible;
            opacity: 1;
        }

        #tcpFlowSim_message-area {
            height: 4.5em;
            overflow: hidden;
            position: relative;
            background-color: #E0F2FE;
            border: 1px solid #7DD3FC;
            padding: 0.75rem;
            border-radius: 0.375rem;
            color: #0369A1;
            font-weight: 500;
            line-height: 1.5;
        }

        #tcpFlowSim_message-content {
            position: absolute;
            width: calc(100% - 1.5rem);
            transition: top 0.5s ease-in-out;
            top: 0;
            text-align: center;
        }

        .tcpFlowSim_explanation code {
            background-color: rgba(17, 24, 39, 0.05);
            color: #DC2626;
            padding: 0.1em 0.3em;
            border-radius: 0.25rem;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9em;
        }

        /* --- TCP Congestion Control Simulation (Copied & Prefixed from 传输层.html) --- */
        .tcpCongestionSim_status-indicator {
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            text-align: center;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid transparent;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .tcpCongestionSim_status-slow-start {
            background-color: #e0f2fe;
            color: #0c4a6e;
            border-color: #bae6fd;
        }

        .tcpCongestionSim_status-congestion-avoidance {
            background-color: #dcfce7;
            color: #166534;
            border-color: #bbf7d0;
        }

        .tcpCongestionSim_status-fast-recovery {
            background-color: #fef9c3;
            color: #854d0e;
            border-color: #fde68a;
        }

        .tcpCongestionSim_status-timeout {
            background-color: #fee2e2;
            color: #991b1b;
            border-color: #fecaca;
        }

        .tcpCongestionSim_highlight-state-change {
            animation: tcpCongestionSim_highlight 1s ease-out;
        }

        @keyframes tcpCongestionSim_highlight {
            0% {
                box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.4);
            }

            70% {
                box-shadow: 0 0 0 7px rgba(59, 130, 246, 0);
            }

            100% {
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            }
        }

        .tcpCongestionSim_packet {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            display: inline-block;
            margin: 1px;
            background-color: #60a5fa;
            opacity: 0;
            transition: opacity 0.4s ease, transform 0.4s ease, background-color 0.3s ease;
        }

        .tcpCongestionSim_packet.tcpCongestionSim_sent {
            opacity: 1;
            transform: translateY(-10px);
        }

        .tcpCongestionSim_packet.tcpCongestionSim_ack {
            background-color: #34d399;
            transform: translateY(0px);
        }

        .tcpCongestionSim_packet.tcpCongestionSim_lost {
            background-color: #f87171;
            opacity: 0.3;
            transform: scale(0.8);
        }

        .tcpCongestionSim_packet.tcpCongestionSim_duplicate-ack {
            background-color: #fbbf24;
            transform: translateY(0px);
        }

        .tcpCongestionSim_control-button {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin: 0 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .tcpCongestionSim_control-button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .tcpCongestionSim_control-button:active {
            transform: translateY(0px);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .tcpCongestionSim_control-button:disabled {
            background-color: #d1d5db;
            color: #6b7280;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #tcpCongestionSim_start-button {
            background-color: #3b82f6;
            color: white;
        }

        #tcpCongestionSim_start-button:hover:not(:disabled) {
            background-color: #2563eb;
        }

        #tcpCongestionSim_loss-button {
            background-color: #ef4444;
            color: white;
        }

        #tcpCongestionSim_loss-button:hover:not(:disabled) {
            background-color: #dc2626;
        }

        #tcpCongestionSim_dup-ack-button {
            background-color: #f59e0b;
            color: white;
        }

        #tcpCongestionSim_dup-ack-button:hover:not(:disabled) {
            background-color: #d97706;
        }

        #tcpCongestionSim_reset-button {
            background-color: #6b7280;
            color: white;
        }

        #tcpCongestionSim_reset-button:hover:not(:disabled) {
            background-color: #4b5563;
        }

        .tcpCongestionSim_explanation {
            background-color: #f9fafb;
            border-left: 5px solid #3b82f6;
            padding: 12px 16px;
            margin-top: 15px;
            font-size: 0.9rem;
            color: #374151;
            border-radius: 6px;
            line-height: 1.7;
        }

        .tcpCongestionSim_explanation strong {
            color: #1d4ed8;
            font-weight: 600;
        }

        .tcpCongestionSim_explanation .tcpCongestionSim_interview-point {
            color: #be123c;
            font-weight: 700;
        }

        .tcpCongestionSim_explanation .tcpCongestionSim_phase-goal {
            color: #059669;
            font-style: italic;
            display: block;
            margin-top: 5px;
        }

        /* --- TCP HOL Blocking Simulation (Copied & Prefixed from 传输层.html) --- */
        .tcpHolSim_packet,
        .tcpHolSim_ack {
            transition: all 2.8s ease-in-out, background-color 0.3s ease, border-color 0.3s ease, transform 0.3s ease;
            position: absolute;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.25rem;
            border-radius: 0.25rem;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            font-size: 0.7rem;
            font-weight: 500;
            min-width: 40px;
            height: 24px;
        }

        .tcpHolSim_packet {
            border: 1px solid #60a5fa;
            background-color: #dbeafe;
            color: #1e40af;
        }

        .tcpHolSim_ack {
            border: 1px solid #34d399;
            background-color: #d1fae5;
            color: #065f46;
        }

        .tcpHolSim_packet-losing {
            border-color: #ef4444 !important;
            background-color: #fee2e2 !important;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }

        .tcpHolSim_packet-lost {
            opacity: 0;
            transform: scale(0.5) !important;
            transition: all 0.8s ease-in !important;
        }

        .tcpHolSim_packet-arrived-cue {
            border-color: #10b981 !important;
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.5);
        }

        .tcpHolSim_packet-buffered {
            background-color: #fde68a;
            border-color: #facc15;
            transform: scale(0.9);
            position: static !important;
            margin: 1px;
        }

        .tcpHolSim_packet-delivered {
            background-color: #dcfce7;
            border-color: #22c55e;
            position: static !important;
            margin: 1px;
        }

        .tcpHolSim_packet-retransmitted {
            border-style: dashed;
            border-color: #f87171;
            background-color: #fef2f2;
        }

        .tcpHolSim_highlight-window {
            border: 2px solid #3b82f6;
            background-color: rgba(59, 130, 246, 0.1);
            transition: all 0.5s ease-in-out;
        }

        .tcpHolSim_buffer-slot {
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 40px;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            background-color: #e5e7eb;
            color: #6b7280;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .tcpHolSim_app-layer-area {
            min-height: 50px;
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            justify-content: center;
            align-items: center;
        }

        .tcpHolSim_status-text {
            min-height: 1.5em;
            transition: opacity 0.5s ease-in-out;
        }

        .tcpHolSim_rto-timer {
            font-size: 0.7rem;
            color: #6b7280;
            display: inline-block;
            margin-left: 4px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .tcpHolSim_rto-timer.active {
            opacity: 1;
        }

        .tcpHolSim_rto-timer.expired {
            color: #ef4444;
            font-weight: bold;
            opacity: 1;
        }

        #tcpHolSim_network-path {
            position: absolute;
            bottom: 48%;
            left: 7%;
            width: 86%;
            height: 2px;
            background-image: linear-gradient(to right, #9ca3af 50%, transparent 50%);
            background-size: 10px 2px;
            z-index: 1;
        }
    </style>

</head>

<body class="bg-gray-100">
    <div class="page-container">

        <aside class="local-side-nav">
            <h4 class="head4">网络基础</h4>
            <ul id="local-toc">
                <li><a href="#intro" class="active"><span class="material-icons nav-icon">lan</span>简介</a></li>
                <li><a href="#tcp-ip-osi"><span class="material-icons nav-icon">layers</span>TCP/IP & OSI</a></li>
                <li><a href="#tcp-connection"><span class="material-icons nav-icon">handshake</span>TCP 连接管理</a></li>
                <li><a href="#tcp-reliability"><span class="material-icons nav-icon">verified_user</span>TCP 可靠性</a>
                </li>
                <li><a href="#tcp-flow-control"><span class="material-icons nav-icon">traffic</span>TCP 流量控制</a></li>
                <li><a href="#tcp-congestion-control"><span class="material-icons nav-icon">speed</span>TCP 拥塞控制</a>
                </li>
                <li><a href="#tcp-hol"><span class="material-icons nav-icon">block</span>TCP 队头阻塞</a></li>
                <li><a href="#udp"><span class="material-icons nav-icon">rocket_launch</span>UDP</a></li>
                <li><a href="#quic"><span class="material-icons nav-icon">bolt</span>QUIC</a></li>
                <li><a href="#dns"><span class="material-icons nav-icon">dns</span>DNS 解析</a></li>
                <li><a href="#kernel-user"><span class="material-icons nav-icon">memory</span>用户态/内核态</a></li>
            </ul>
            <a href="../../index.html" class="back-link"> &larr; 返回大纲目录
            </a>
        </aside>

        <main class="content-main">
            <article>
                <section id="intro" class="content-section fade-in-section" style="animation-delay: 0s;">
                    <h1 class="head1 flex items-center gap-2">
                        <span class="material-icons text-3xl text-blue-600">lan</span>(一) 网络基础
                    </h1>
                    <p>网络基础是前端和全栈开发面试中的重要环节，考察对网络协议、数据传输和网络通信原理的理解。本节梳理了 TCP/IP 模型、TCP/UDP 协议细节、QUIC、DNS 等核心知识点。</p>
                    <p class="mt-4 bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md text-sm">💡
                        <strong>提示:</strong> 点击左侧导航可以快速跳转到相应主题。括号内标注了知识点的重要程度和难度级别。部分章节包含交互式模拟。
                    </p>
                </section>

                <section id="tcp-ip-osi" class="content-section fade-in-section" style="animation-delay: 0.05s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">layers</span>TCP/IP 与 OSI 模型
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">分层模型概述</h3>
                        <p>网络协议模型将复杂的网络通信过程划分为不同的层次，每层负责特定的功能，下层为上层提供服务。这种分层结构有助于标准化、模块化和简化网络设计与实现。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">OSI 七层模型 (理论模型)</h3>
                        <p>OSI (Open Systems Interconnection) 模型是一个理论上完善但实际应用较少的七层参考模型：</p>
                        <ol class="list-decimal list-inside space-y-1 text-sm">
                            <li><strong>物理层 (Physical Layer):</strong> 负责传输原始比特流，定义物理接口、电压、线缆等。</li>
                            <li><strong>数据链路层 (Data Link Layer):</strong> 在物理链路上提供可靠的数据传输（帧），进行物理寻址 (MAC)、错误检测和流量控制。
                            </li>
                            <li><strong>网络层 (Network Layer):</strong> 负责逻辑寻址 (IP地址)、路由选择和分组转发，实现不同网络间的通信。</li>
                            <li><strong>传输层 (Transport Layer):</strong> 提供端到端的通信服务，进行端口寻址、分段/重组、连接管理、可靠传输 (TCP) 或不可靠传输
                                (UDP)。</li>
                            <li><strong>会话层 (Session Layer):</strong> 建立、管理和终止会话（连接）。</li>
                            <li><strong>表示层 (Presentation Layer):</strong> 处理数据格式转换、加密/解密、压缩/解压缩。</li>
                            <li><strong>应用层 (Application Layer):</strong> 为应用程序提供网络服务接口，如 HTTP, FTP, DNS 等。</li>
                        </ol>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">TCP/IP 四层/五层模型 (事实标准)</h3>
                        <p>TCP/IP 模型是互联网实际使用的协议栈模型，通常描述为四层或五层：</p>
                        <div class="mermaid text-center my-4 p-2 border rounded bg-white shadow-sm">
                            graph TD
                            subgraph "OSI 模型 (7层)"
                            A[应用层] --> B[表示层] --> C[会话层] --> D[传输层] --> E[网络层] --> F[数据链路层] --> G[物理层]
                            end
                            subgraph "TCP/IP 模型 (4层)"
                            H[应用层] --> I[传输层] --> J[网际层/网络层] --> K[网络接口层/链路层]
                            end
                            subgraph "TCP/IP 模型 (5层)"
                            L[应用层] --> M[传输层] --> N[网络层] --> O[数据链路层] --> P[物理层]
                            end

                            style A fill:#fecaca, stroke:#b91c1c
                            style B fill:#fee2e2, stroke:#b91c1c
                            style C fill:#ffedd5, stroke:#c2410c
                            style D fill:#fef3c7, stroke:#a16207
                            style E fill:#dcfce7, stroke:#15803d
                            style F fill:#dbeafe, stroke:#1d4ed8
                            style G fill:#e0e7ff, stroke:#3730a3

                            style H fill:#fecaca, stroke:#b91c1c
                            style I fill:#fef3c7, stroke:#a16207
                            style J fill:#dcfce7, stroke:#15803d
                            style K fill:#dbeafe, stroke:#1d4ed8

                            style L fill:#fecaca, stroke:#b91c1c
                            style M fill:#fef3c7, stroke:#a16207
                            style N fill:#dcfce7, stroke:#15803d
                            style O fill:#dbeafe, stroke:#1d4ed8
                            style P fill:#e0e7ff, stroke:#3730a3
                        </div>
                        <ul class="list-disc list-inside space-y-1 text-sm">
                            <li><strong>应用层 (Application Layer):</strong> 对应 OSI 应用层、表示层、会话层。负责应用程序间的通信 (HTTP, DNS, FTP
                                等)。</li>
                            <li><strong>传输层 (Transport Layer):</strong> 对应 OSI 传输层。负责端到端的数据传输 (TCP, UDP)。</li>
                            <li><strong>网络层/网际层 (Internet Layer):</strong> 对应 OSI 网络层。负责数据包的路由和转发 (IP, ICMP, ARP)。</li>
                            <li><strong>网络接口层/链路层 (Network Interface/Link Layer):</strong> 对应 OSI
                                数据链路层和物理层。负责物理网络接口和帧的传输 (Ethernet, Wi-Fi)。(五层模型会将其拆分为数据链路层和物理层)</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">对应关系与总结</h3>
                        <p>TCP/IP 模型是 OSI 模型的一个简化和实践版本。理解分层思想是关键：每层专注自身功能，通过接口与上下层交互，实现了网络的模块化和标准化。</p>
                    </div>
                </section>

                <section id="tcp-connection" class="content-section fade-in-section" style="animation-delay: 0.1s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">handshake</span>TCP 连接管理
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">TCP 是什么？</h3>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li>全称: Transmission Control Protocol (传输控制协议)，属于 <b>传输层</b> 协议。</li>
                            <li>核心特点: 可靠、面向连接、字节流、全双工通信。</li>
                            <li>主要目标: 在不可靠的 IP 网络（底层可能丢包、乱序）上提供 可靠的数据传输服务。</li>
                            <li>应用场景: HTTP/HTTPS, FTP, SMTP, SSH 等要求数据完整性和顺序性的应用。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">TCP 报文段结构</h3>
                        <p class="text-sm text-gray-600 mb-3"> TCP 头部包含了实现其可靠性、流量控制等功能的关键字段。标准头部最小为 20 字节（5 个 32
                            位字）。点击下方字段查看说明： </p>
                        <div id="tcp-header-vis"
                            class="border border-gray-300 rounded overflow-hidden shadow-md select-none">
                            <div class="flex w-full">
                                <div class="header-field flex-1 p-2 text-center border-r border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="源端口 (16位): 标识发送方应用程序端口号。"> 源端口 (16) </div>
                                <div class="header-field flex-1 p-2 text-center border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="目的端口 (16位): 标识接收方应用程序端口号。"> 目的端口 (16) </div>
                            </div>
                            <div class="flex w-full">
                                <div class="header-field flex-auto p-2 text-center border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="序列号 (SEQ, 32位): 用于标识TCP报文段中数据部分的第一个字节的序号。确保数据按序到达和重传。"> 序列号 (SEQ) (32)
                                </div>
                            </div>
                            <div class="flex w-full">
                                <div class="header-field flex-auto p-2 text-center border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="确认号 (ACK, 32位): 期望收到的下一个字节的序号。只有当ACK标志位为1时才有效。"> 确认号 (ACK) (32) </div>
                            </div>
                            <div class="flex w-full">
                                <div class="header-field w-[12.5%] p-2 text-center border-r border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="数据偏移 (4位): TCP头部的长度，以4字节为单位。指示数据部分的起始位置。"> 偏移(4) </div>
                                <div class="header-field w-[18.75%] p-2 text-center border-r border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="保留 (6位): 未使用，必须为0。"> 保留(6) </div>
                                <div class="header-field w-[18.75%] p-2 text-center border-r border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="标志位 (6位): URG(紧急)/ACK(确认)/PSH(推送)/RST(复位)/SYN(同步)/FIN(结束)。控制TCP连接状态。">
                                    标志位(6) </div>
                                <div class="header-field w-1/2 p-2 text-center border-b border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="窗口大小 (Window, 16位): 用于流量控制，指示接收方当前可用的缓冲区大小。"> 窗口 (16) </div>
                            </div>
                            <div class="flex w-full">
                                <div class="header-field flex-1 p-2 text-center border-r border-gray-400 bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="校验和 (16位): 用于检测TCP头部和数据部分在传输过程中是否出错。"> 校验和 (16) </div>
                                <div class="header-field flex-1 p-2 text-center bg-blue-100 hover:bg-blue-300 cursor-pointer text-sm font-mono"
                                    data-info="紧急指针 (UrgPtr, 16位): 只有URG标志位为1时有效，指示紧急数据在报文段中的结束位置。"> 紧急指针 (16) </div>
                            </div>
                            <div class="header-field w-full p-2 text-center bg-yellow-100 hover:bg-yellow-300 cursor-pointer text-gray-700 text-sm font-mono border-t border-gray-400"
                                data-info="可选项 (长度可变): 如最大报文段长度(MSS), 窗口缩放因子, 时间戳, 选择性确认(SACK)等。头部总长度(Data Offset)会指示是否包含可选项。">
                                可选项 (Options) (变长, 32位对齐) </div>
                            <div
                                class="w-full p-4 text-center bg-green-100 text-gray-700 text-sm border-t border-gray-400">
                                数据 (Payload) - 可变长度 </div>
                        </div>
                        <div id="tcp-header-info" class="header-info-display"> 点击上方字段查看详细信息...</div>
                    </div>
                    <div class="content-card mb-6 p-4 border border-green-300 rounded-lg bg-green-50">
                        <h4 class="font-medium text-lg mb-3 text-green-800">🤝 三次握手 (建立连接)</h4>
                        <p class="text-sm text-gray-600 mb-4">确保双方都具备收发能力，并同步初始序列号 (ISN)。</p>
                        <div class="flex flex-col md:flex-row gap-4 items-start">
                            <div class="w-full md:w-2/5 space-y-2">
                                <div id="handshake-step-1" class="interactive-step">
                                    <p><strong>步骤 1:</strong> 客户端 <span class="state-tag state-closed">CLOSED</span> →
                                        服务器 <span class="state-tag state-listen">LISTEN</span></p>
                                    <p class="text-sm">客户端发送 SYN 包 (<code>SYN=1, Seq=x</code>) 请求建立连接，进入 <span
                                            class="state-tag state-syn-sent">SYN_SENT</span> 状态。</p>
                                </div>
                                <div id="handshake-step-2" class="interactive-step">
                                    <p><strong>步骤 2:</strong> 服务器 <span class="state-tag state-listen">LISTEN</span> →
                                        客户端 <span class="state-tag state-syn-sent">SYN_SENT</span></p>
                                    <p class="text-sm">服务器收到 SYN，回复 SYN+ACK 包
                                        (<code>SYN=1, ACK=1, Seq=y, Ack=x+1</code>)，进入 <span
                                            class="state-tag state-syn-rcvd">SYN_RCVD</span> 状态。</p>
                                </div>
                                <div id="handshake-step-3" class="interactive-step">
                                    <p><strong>步骤 3:</strong> 客户端 <span class="state-tag state-syn-sent">SYN_SENT</span>
                                        → 服务器 <span class="state-tag state-syn-rcvd">SYN_RCVD</span></p>
                                    <p class="text-sm">客户端收到 SYN+ACK，发送 ACK 包 (<code>ACK=1, Ack=y+1</code>)，进入 <span
                                            class="state-tag state-established">ESTABLISHED</span> 状态。服务器收到 ACK 后也进入
                                        <span class="state-tag state-established">ESTABLISHED</span> 状态。连接建立！
                                    </p>
                                </div>
                            </div>
                            <div class="w-full md:w-3/5 flex flex-col items-center">
                                <div id="mermaid-handshake-diagram"
                                    class="mermaid mb-4 border rounded p-2 bg-white shadow-sm w-full">
                                </div>
                                <button id="next-handshake-step"
                                    class="button button-secondary bg-green-500 hover:bg-green-600 text-white">
                                    <i class="fas fa-play mr-1"></i> 下一步 (握手)
                                </button>
                            </div>
                        </div>
                        <div class="mt-6 p-4 border border-yellow-300 rounded-lg bg-yellow-50">
                            <h5 class="font-semibold text-yellow-800 mb-2"><i
                                    class="fas fa-exclamation-triangle mr-1"></i> 为什么必须是三次握手？</h5>
                            <p class="text-sm text-gray-700">如果只有两次握手（客户端发 SYN，服务器回 SYN+ACK 就建立连接）：</p>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-700 mt-2">
                                <li><strong>无法防止已失效的连接请求：</strong> 客户端第一次发的 SYN
                                    可能因网络延迟，在连接释放后才到达服务器。如果是两次握手，服务器会立即建立连接并等待数据，造成资源浪费（半连接）。</li>
                                <li><strong>服务器无法确认客户端的接收能力：</strong> 第三次握手是客户端对服务器 SYN 的确认，证明客户端能收到服务器的消息。</li>
                                <li><strong>易受 SYN Flood 攻击：</strong> 攻击者伪造大量 IP 发送 SYN，服务器回复 SYN+ACK 并等待最终
                                    ACK，耗尽资源。三次握手虽然不能完全杜绝，但增加了攻击成本。</li>
                            </ul>
                            <p class="text-sm font-medium text-gray-800 mt-2">🎯 核心：三次握手是确保双方都确认对方收发能力、同步初始序列号的最小可靠步骤。
                            </p>
                        </div>
                    </div>

                    <div class="content-card mb-6 p-4 border border-red-300 rounded-lg bg-red-50">
                        <h4 class="font-medium text-lg mb-3 text-red-800">👋 四次挥手 (断开连接)</h4>
                        <p class="text-sm text-gray-600 mb-4">由于 TCP 是全双工，连接的关闭需要双方各自独立地关闭发送通道。</p>
                        <div class="flex flex-col md:flex-row gap-4 items-start">
                            <div class="w-full md:w-2/5 space-y-2">
                                <div id="wave-step-1" class="interactive-step">
                                    <p><strong>步骤 1:</strong> 客户端 <span
                                            class="state-tag state-established">ESTABLISHED</span> → 服务器 <span
                                            class="state-tag state-established">ESTABLISHED</span></p>
                                    <p class="text-sm">客户端主动关闭，发送 FIN 包 (<code>FIN=1, Seq=u</code>)，表示不再发送数据，进入 <span
                                            class="state-tag state-fin-wait-1">FIN_WAIT_1</span> 状态。</p>
                                </div>
                                <div id="wave-step-2" class="interactive-step">
                                    <p><strong>步骤 2:</strong> 服务器 <span
                                            class="state-tag state-established">ESTABLISHED</span> → 客户端 <span
                                            class="state-tag state-fin-wait-1">FIN_WAIT_1</span></p>
                                    <p class="text-sm">服务器收到 FIN，回复 ACK 包 (<code>ACK=1, Ack=u+1</code>)，表示收到关闭请求。客户端进入
                                        <span class="state-tag state-fin-wait-2">FIN_WAIT_2</span>。服务器进入 <span
                                            class="state-tag state-close-wait">CLOSE_WAIT</span>，此时服务器仍可发送数据。
                                    </p>
                                </div>
                                <div id="wave-step-3" class="interactive-step">
                                    <p><strong>步骤 3:</strong> 服务器 <span
                                            class="state-tag state-close-wait">CLOSE_WAIT</span> → 客户端 <span
                                            class="state-tag state-fin-wait-2">FIN_WAIT_2</span></p>
                                    <p class="text-sm">服务器数据发送完毕，也发送 FIN 包 (<code>FIN=1, Seq=v</code>)，表示自己也要关闭连接，进入
                                        <span class="state-tag state-last-ack">LAST_ACK</span> 状态。
                                    </p>
                                </div>
                                <div id="wave-step-4" class="interactive-step">
                                    <p><strong>步骤 4:</strong> 客户端 <span
                                            class="state-tag state-fin-wait-2">FIN_WAIT_2</span> → 服务器 <span
                                            class="state-tag state-last-ack">LAST_ACK</span></p>
                                    <p class="text-sm">客户端收到 FIN，发送 ACK 包 (<code>ACK=1, Ack=v+1</code>)，进入 <span
                                            class="state-tag state-time-wait">TIME_WAIT</span> 状态（等待 2*MSL）。服务器收到 ACK
                                        后进入 <span class="state-tag state-closed">CLOSED</span> 状态。客户端等待结束后也进入 <span
                                            class="state-tag state-closed">CLOSED</span>。</p>
                                </div>
                            </div>
                            <div class="w-full md:w-3/5 flex flex-col items-center">
                                <div id="mermaid-wave-diagram"
                                    class="mermaid mb-4 border rounded p-2 bg-white shadow-sm w-full">
                                </div>
                                <button id="next-wave-step"
                                    class="button button-secondary bg-red-500 hover:bg-red-600 text-white">
                                    <i class="fas fa-play mr-1"></i> 下一步 (挥手)
                                </button>
                            </div>
                        </div>
                        <div class="mt-6 p-4 border border-purple-300 rounded-lg bg-purple-50">
                            <h5 class="font-semibold text-purple-800 mb-2"><i class="fas fa-hourglass-half mr-1"></i>
                                TIME_WAIT 状态 (2*MSL) 的意义？</h5>
                            <p class="text-sm text-gray-700">客户端最后发送 ACK 后进入 TIME_WAIT 状态，等待 2 倍的最大报文段生存时间（Maximum
                                Segment Lifetime）。</p>
                            <ul class="list-disc list-inside space-y-1 text-sm text-gray-700 mt-2">
                                <li><strong>确保最后的 ACK 到达服务器：</strong> 如果这个 ACK 丢失，服务器会超时重传 FIN。客户端在 TIME_WAIT
                                    状态可以响应这个重传的 FIN，再次发送 ACK，确保服务器能正常关闭。</li>
                                <li><strong>防止已失效的连接请求报文段出现在新连接中：</strong> 等待 2*MSL
                                    可以确保本次连接中产生的所有报文段都从网络中消失，避免干扰后续使用相同端口的新连接。</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section id="tcp-reliability" class="content-section fade-in-section" style="animation-delay: 0.15s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">verified_user</span>TCP 可靠性机制
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">核心机制</h3>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li><strong>序列号 (SEQ) 与 确认号 (ACK):</strong> 每个字节都被编号，ACK 确认收到的连续字节流的最高序号+1。</li>
                            <li><strong>累积确认:</strong> ACK N 表示 N 之前的所有字节都已收到。</li>
                            <li><strong>超时重传 (RTO):</strong> 发送方维护一个重传定时器，如果在 RTO 内未收到 ACK，则重传数据段。RTO 基于 RTT (往返时延)
                                动态调整。</li>
                            <li><strong>快速重传:</strong> 收到 3 个或以上重复的 ACK 时，认为该 ACK 指示的下一个包已丢失，立即重传，无需等待 RTO 超时。</li>
                            <li><strong>选择性确认 (SACK, 可选项):</strong> 允许接收方告知发送方哪些非连续的数据块已收到，使发送方只需重传真正丢失的部分。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h4 class="head4">可靠传输模拟 (队头阻塞示例)</h4>
                        <p class="text-sm text-gray-600 mb-4">以下模拟展示了 TCP 如何处理丢包和乱序，以及队头阻塞现象。发送方窗口大小为 4。</p>
                        <div id="tcpRelSim_animation-area"
                            class="mt-6 p-4 border border-blue-200 rounded-lg bg-gradient-to-b from-blue-50 to-white relative overflow-hidden min-h-[450px] shadow-inner">
                            <div class="flex justify-between items-start mb-4 relative z-20">
                                <div class="w-2/5 border border-gray-300 rounded-lg p-3 bg-gray-50 shadow">
                                    <h5 class="font-medium text-center mb-2 text-gray-700 text-base">发送方 (Sender)</h5>
                                    <div class="text-xs mb-2 text-center text-gray-600">窗口大小 (W) = 4</div>
                                    <div id="tcpRelSim_sender-window"
                                        class="relative border border-dashed border-gray-400 p-2 rounded tcpRelSim_highlight-window min-h-[60px]">
                                        <span id="tcpRelSim_sender-window-label"
                                            class="absolute -top-2 -left-2 bg-blue-100 text-blue-700 px-1 py-0.5 text-xs rounded shadow-sm">发送窗口
                                            [1-4]</span>
                                        <div class="flex space-x-1 justify-center items-center mt-2 flex-wrap">
                                            <div id="tcpRelSim_sender-seq-1"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 1 <span class="tcpRelSim_rto-timer" id="tcpRelSim_timer-1"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpRelSim_sender-seq-2"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 2 <span class="tcpRelSim_rto-timer" id="tcpRelSim_timer-2"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpRelSim_sender-seq-3"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 3 <span class="tcpRelSim_rto-timer" id="tcpRelSim_timer-3"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpRelSim_sender-seq-4"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 4 <span class="tcpRelSim_rto-timer" id="tcpRelSim_timer-4"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpRelSim_sender-seq-5"
                                                class="p-1 border border-gray-400 rounded bg-gray-300 text-xs text-center opacity-50 shadow-sm">
                                                SEQ 5 <span class="tcpRelSim_rto-timer" id="tcpRelSim_timer-5"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpRelSim_sender-seq-6"
                                                class="p-1 border border-gray-400 rounded bg-gray-300 text-xs text-center opacity-50 shadow-sm">
                                                SEQ 6 <span class="tcpRelSim_rto-timer" id="tcpRelSim_timer-6"><i
                                                        class="fas fa-clock"></i></span> </div>
                                        </div>
                                    </div>
                                    <div id="tcpRelSim_sender-status"
                                        class="tcpRelSim_status-text text-xs text-center mt-2 text-blue-600 font-medium">
                                        准备发送...</div>
                                </div>
                                <div class="w-2/5 border border-gray-300 rounded-lg p-3 bg-gray-50 shadow">
                                    <h5 class="font-medium text-center mb-1 text-gray-700 text-base">接收方 (Receiver)</h5>
                                    <div class="border border-green-300 rounded p-2 mb-2 bg-green-50 shadow-inner">
                                        <h6 class="text-sm font-medium text-center text-green-800 mb-1">应用层 (已接收数据)</h6>
                                        <div id="tcpRelSim_app-layer" class="tcpRelSim_app-layer-area min-h-[40px]">
                                        </div>
                                    </div>
                                    <div class="border border-purple-300 rounded p-2 bg-purple-50 shadow-inner">
                                        <h6 class="text-sm font-medium text-center text-purple-800 mb-1">TCP 协议层</h6>
                                        <div class="text-xs text-center mb-2 text-gray-600">期望: <span
                                                id="tcpRelSim_expected-seq" class="font-bold text-purple-700">SEQ
                                                1</span></div>
                                        <div id="tcpRelSim_receiver-buffer"
                                            class="flex space-x-1 justify-center border border-dashed border-gray-400 p-2 rounded min-h-[60px] bg-white flex-wrap">
                                            <div class="tcpRelSim_buffer-slot">空</div>
                                            <div class="tcpRelSim_buffer-slot">空</div>
                                            <div class="tcpRelSim_buffer-slot">空</div>
                                            <div class="tcpRelSim_buffer-slot">空</div>
                                        </div>
                                    </div>
                                    <div id="tcpRelSim_receiver-status"
                                        class="tcpRelSim_status-text text-xs text-center mt-2 text-purple-600 font-medium">
                                        等待数据...</div>
                                </div>
                            </div>
                            <div id="tcpRelSim_network-path"></div>
                            <div id="tcpRelSim_channel" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                            </div>
                            <div id="tcpRelSim_explanation"
                                class="absolute bottom-14 left-1/2 transform -translate-x-1/2 w-11/12 text-center text-sm text-gray-700 bg-white bg-opacity-80 p-2 rounded shadow z-20">
                                点击 "下一步" 开始模拟。
                            </div>
                        </div>
                        <div class="mt-6 flex justify-center space-x-4">
                            <button id="tcpRelSim_next-step" class="button button-primary"> <i
                                    class="fas fa-forward mr-1"></i> 下一步 </button>
                            <button id="tcpRelSim_reset" class="button button-secondary"> <i
                                    class="fas fa-undo mr-1"></i> 重置 </button>
                        </div>
                    </div>
                </section>

                <section id="tcp-flow-control" class="content-section fade-in-section" style="animation-delay: 0.2s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">traffic</span>TCP 流量控制
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">目的与机制</h3>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li><strong>目的:</strong> 防止发送方发送速度过快，导致接收方缓冲区溢出而来不及处理。这是 <strong>端到端</strong> 的控制。</li>
                            <li><strong>机制: 滑动窗口 (Sliding Window)</strong></li>
                            <li>接收方通过 TCP 头部的 <b>窗口 (Window)</b> 字段告知发送方自己当前可用的缓冲区大小 (rwnd, Receive Window)。</li>
                            <li>发送方根据接收方的 rwnd 调整自己的发送速率，确保发送的数据量不超过接收方的处理能力。</li>
                            <li>窗口大小可以动态变化。如果接收方窗口为 0 (零窗口)，发送方会停止发送数据（除零窗口探测报文外）。</li>
                            <li><strong>与拥塞控制的区别:</strong> 流量控制关心接收方的处理能力；拥塞控制关心网络的承载能力。</li>
                        </ul>
                    </div>
                    <div class="content-card max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-lg">
                        <h4 class="head4 text-center mb-6 text-gray-800"> <i
                                class="fas fa-network-wired mr-2 text-blue-600"></i>交互式 TCP 流量控制模拟 </h4>
                        <div id="tcpFlowSim_message-area" class="mb-6 text-sm">
                            <div id="tcpFlowSim_message-content">欢迎！点击 "发送数据包" 开始模拟 TCP 流量控制。</div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <div class="border border-gray-200 rounded-lg p-4 bg-blue-50">
                                <h5 class="text-lg font-semibold mb-3 text-blue-800 flex items-center"> <i
                                        class="fas fa-paper-plane mr-2"></i>发送方 (Sender) </h5>
                                <div class="mb-2"> <span class="font-medium text-sm text-gray-700">发送缓冲区 (灰色:待发送,
                                        蓝色:已发送未确认, 绿色:已确认):</span>
                                    <div id="tcpFlowSim_sender-buffer"
                                        class="tcpFlowSim_buffer mt-1 relative h-20 tcpFlowSim_has-tooltip">
                                        <div class="tcpFlowSim_tooltip top-0 left-0 mt-1 ml-1">蓝色框表示发送窗口 (Send
                                            Window)<br>大小: <span id="tcpFlowSim_send-window-size-tooltip">0</span></div>
                                    </div>
                                </div>
                                <div class="text-sm space-y-1 text-gray-700">
                                    <p class="tcpFlowSim_has-tooltip relative inline-block">SND.NXT: <strong
                                            id="tcpFlowSim_snd-nxt" class="text-blue-600">1</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">下一个要发送的数据包的序号</span></p>
                                    <p class="tcpFlowSim_has-tooltip relative inline-block ml-4">SND.UNA: <strong
                                            id="tcpFlowSim_snd-una" class="text-blue-600">1</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">最早未被确认的数据包序号 (发送窗口左边界)</span>
                                    </p>
                                    <p class="tcpFlowSim_has-tooltip relative block mt-1">发送窗口大小: <strong
                                            id="tcpFlowSim_send-window-size" class="text-blue-600">0</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">发送方当前认为可以发送的总量
                                            (简化=<code>rwnd</code>)</span></p>
                                    <p class="tcpFlowSim_has-tooltip relative block">可用窗口大小: <strong
                                            id="tcpFlowSim_usable-window-size" class="text-blue-600">0</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">发送方还能立即发送的数据量 = 发送窗口 - (SND.NXT
                                            - SND.UNA)</span></p>
                                    <p class="tcpFlowSim_has-tooltip relative block">最新获知的 <code>rwnd</code>: <strong
                                            id="tcpFlowSim_advertised-rwnd" class="text-amber-600">0</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">从接收方ACK中得知的最新接收窗口大小</span></p>
                                </div>
                            </div>
                            <div class="border border-gray-200 rounded-lg p-4 bg-amber-50">
                                <h5 class="text-lg font-semibold mb-3 text-amber-800 flex items-center"> <i
                                        class="fas fa-inbox mr-2"></i>接收方 (Receiver) </h5>
                                <div class="mb-2"> <span class="font-medium text-sm text-gray-700">接收缓冲区 (粉色:
                                        已接收未被应用处理):</span>
                                    <div id="tcpFlowSim_receiver-buffer-container" class="relative">
                                        <div id="tcpFlowSim_receiver-buffer"
                                            class="tcpFlowSim_buffer mt-1 relative h-20 tcpFlowSim_has-tooltip">
                                            <div class="tcpFlowSim_tooltip top-0 left-0 mt-1 ml-1">橙色框表示接收窗口 (Receive
                                                Window)<br>大小 (<code>rwnd</code>): <span
                                                    id="tcpFlowSim_recv-window-size-tooltip">0</span></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="text-sm space-y-1 text-gray-700">
                                    <p class="tcpFlowSim_has-tooltip relative inline-block">RCV.NXT: <strong
                                            id="tcpFlowSim_rcv-nxt" class="text-amber-600">1</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">期望接收的下一个数据包序号 (接收窗口左边界)</span>
                                    </p>
                                    <p class="tcpFlowSim_has-tooltip relative inline-block ml-4">缓冲区总容量: <strong
                                            id="tcpFlowSim_buffer-capacity" class="text-amber-600">10</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">接收缓冲区能容纳的最大数据包数</span></p>
                                    <p class="tcpFlowSim_has-tooltip relative block mt-1">当前接收窗口 (<code>rwnd</code>):
                                        <strong id="tcpFlowSim_current-rwnd" class="text-amber-600">10</strong><span
                                            class="tcpFlowSim_tooltip bottom-full mb-1">当前实际可用缓冲区空间 = 总容量 - 已占用</span>
                                    </p>
                                </div>
                            </div>
                        </div>
                        <div class="mt-6 text-center space-x-2"> <button id="tcpFlowSim_send-packet-btn"
                                class="tcpFlowSim_control-button tcpFlowSim_send"> <i class="fas fa-arrow-right"></i>
                                发送数据包 (Send) </button> <button id="tcpFlowSim_process-packet-btn"
                                class="tcpFlowSim_control-button tcpFlowSim_process" disabled> <i
                                    class="fas fa-cogs"></i> 应用处理数据包 (Process) </button> <button
                                id="tcpFlowSim_reset-btn" class="tcpFlowSim_control-button tcpFlowSim_reset"> <i
                                    class="fas fa-redo"></i> 重置模拟 (Reset) </button> </div>
                        <div id="tcpFlowSim_transmission-channel" class="relative h-16 mt-4"> </div>
                        <div class="mt-8 p-4 border border-gray-200 rounded-lg bg-gray-50 tcpFlowSim_explanation">
                            <h5 class="font-semibold mb-2 text-gray-700"><i
                                    class="fas fa-info-circle mr-1 text-blue-500"></i> 关键概念解释 (面试要点)</h5>
                            <ul class="list-disc list-inside space-y-2 text-sm text-gray-700">
                                <li><strong>流量控制 (Flow Control) 目的:</strong> <span
                                        class="font-semibold">核心目标是防止发送方发送过快，导致接收方的缓冲区溢出，确保接收方有足够的时间处理数据。</span> 这是端到端
                                    (点对点) 的控制。</li>
                                <li><strong>滑动窗口 (Sliding Window):</strong> <span
                                        class="font-semibold">实现流量控制的核心机制。</span> 接收方根据自己缓冲区的使用情况，计算出还能接收多少数据，这个值就是
                                    <span class="font-semibold text-amber-600">接收窗口 (<code>rwnd</code>)</span>。
                                </li>
                                <li><strong><code>rwnd</code> (Receive Window):</strong> <span
                                        class="font-semibold">接收方通过 TCP 报文段头部的 "窗口" 字段，将 <code>rwnd</code> 告知发送方。</span>
                                    它动态反映了接收方的处理能力。</li>
                                <li><strong>发送窗口 (Send Window):</strong> 发送方根据自己收到的 <code>rwnd</code> 和当前网络的拥塞情况 (由<span
                                        class="font-semibold text-red-600">拥塞窗口 <code>cwnd</code></span> 反映，本动画简化处理)
                                    来共同决定自己当前可以发送多少数据。发送窗口大小 = min(<code>rwnd</code>, <code>cwnd</code>)。<span
                                        class="font-semibold">发送方任何时刻已发送但未确认的数据量不能超过发送窗口的大小。</span></li>
                                <li><strong>SND.UNA / SND.NXT / RCV.NXT:</strong> 这些指针共同定义了窗口的位置和状态。<code>SND.UNA</code>
                                    是发送窗口的左边界 (已确认)，<code>SND.NXT</code> 是下一个要发送的序号，(<code>SND.NXT</code> -
                                    <code>SND.UNA</code>) 是已发送未确认的数据量。<code>RCV.NXT</code> 是接收窗口的左边界 (期望接收)。
                                </li>
                                <li><strong>可用窗口 (Usable Window):</strong> 发送方<span
                                        class="font-semibold">实际还能立即发送</span>的数据量，等于 `发送窗口大小 - (<code>SND.NXT</code> -
                                    <code>SND.UNA</code>)`。
                                </li>
                                <li><strong>零窗口 (Zero Window):</strong> 当接收方缓冲区满时，它会通告 <code>rwnd = 0</code>。<span
                                        class="font-semibold">发送方收到零窗口通知后，必须停止发送数据</span> (除了零窗口探测报文)，直到收到一个
                                    <code>rwnd > 0</code> 的 ACK。
                                </li>
                                <li><strong>零窗口探测 (Zero Window Probe):</strong> <span
                                        class="font-semibold">为了打破发送方因等待窗口更新而可能产生的死锁</span>，发送方在收到零窗口后会启动一个定时器，周期性地发送一个小的探测报文
                                    (通常只包含 1 字节数据或仅是头部)。接收方收到探测报文后，必须回复当前的 <code>rwnd</code>，即使它仍然是 0。</li>
                                <li><strong>与拥塞控制的区别:</strong> 流量控制关心的是<span class="font-semibold">接收方的处理能力
                                        (点对点)</span>，防止压垮接收方；拥塞控制关心的是<span class="font-semibold">整个网络的承载能力
                                        (端到网)</span>，防止网络拥塞。两者共同决定发送方的最终发送速率。</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section id="tcp-congestion-control" class="content-section fade-in-section"
                    style="animation-delay: 0.25s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">speed</span>TCP 拥塞控制
                        <span class="level-tag level-tag-high">高频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">目的与机制</h3>
                        <p class="text-sm text-gray-600 mb-3">防止过多数据注入网络导致路由器或链路过载。TCP 通过维护一个 <b>拥塞窗口 (cwnd, Congestion
                                Window)</b> 来动态调整发送速率。实际发送窗口 = min(cwnd, rwnd)。</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 text-sm">
                            <div class="p-3 border rounded bg-white shadow-sm">
                                <h4 class="font-medium text-blue-800 mb-1">慢启动 (Slow Start)</h4>
                                <p>连接初始或超时重传后，cwnd 设为 1 MSS。每收到一个 ACK，cwnd 增加 1 MSS (指数增长)。</p>
                            </div>
                            <div class="p-3 border rounded bg-white shadow-sm">
                                <h4 class="font-medium text-blue-800 mb-1">拥塞避免 (Congestion Avoidance)</h4>
                                <p>当 cwnd 达到慢启动阈值 (ssthresh) 后，增长变为线性：每个 RTT 增加 1 MSS。</p>
                            </div>
                            <div class="p-3 border rounded bg-white shadow-sm">
                                <h4 class="font-medium text-blue-800 mb-1">快速重传/恢复</h4>
                                <p>收到 3 个重复 ACK 时，ssthresh 设为 cwnd/2，cwnd 设为 ssthresh + 3 MSS (或直接减半)，进入拥塞避免，避免完全慢启动。
                                </p>
                            </div>
                            <div class="p-3 border rounded bg-white shadow-sm">
                                <h4 class="font-medium text-blue-800 mb-1">超时重传</h4>
                                <p>发生 RTO 超时，认为网络严重拥塞。ssthresh 设为 cwnd/2，cwnd 直接降为 1 MSS，重新进入慢启动。</p>
                            </div>
                        </div>
                    </div>
                    <div class="content-card max-w-[80vw] mx-auto bg-white p-6 rounded-lg shadow-md">
                        <h4 class="head4 text-center mb-6 text-gray-800"> <i
                                class="fas fa-traffic-light mr-1 text-blue-500"></i>交互式 TCP 拥塞控制模拟 </h4>
                        <p class="text-sm text-gray-600 mb-3"> 模拟 TCP 如何根据网络反馈（ACK、丢包、重复 ACK）动态调整拥塞窗口 (cwnd) 和慢启动阈值
                            (ssthresh)。 </p>
                        <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-6 text-center items-center">
                            <div class="md:col-span-2"> <span
                                    class="text-sm font-medium text-gray-500 block mb-1">当前状态</span>
                                <div id="tcpCongestionSim_status-indicator"
                                    class="tcpCongestionSim_status-indicator tcpCongestionSim_status-slow-start mx-auto">
                                </div>
                            </div>
                            <div> <span class="text-sm font-medium text-gray-500">拥塞窗口 (cwnd)</span>
                                <div id="tcpCongestionSim_cwnd-value" class="text-xl font-semibold text-blue-600 mt-1">1
                                    MSS</div>
                            </div>
                            <div> <span class="text-sm font-medium text-gray-500">慢启动阈值 (ssthresh)</span>
                                <div id="tcpCongestionSim_ssthresh-value"
                                    class="text-xl font-semibold text-green-600 mt-1">64 MSS</div>
                            </div>
                            <div> <span class="text-sm font-medium text-gray-500">轮次 (RTT)</span>
                                <div id="tcpCongestionSim_rtt-counter" class="text-xl font-semibold text-gray-600 mt-1">
                                    0</div>
                            </div>
                        </div>
                        <div class="mb-6 p-4 border rounded-md bg-gray-50 min-h-[60px]">
                            <h5 class="text-sm font-medium text-gray-600 mb-2 text-center">数据包窗口 (大小 = cwnd, 最多显示 30 个)
                            </h5>
                            <div id="tcpCongestionSim_packet-area"
                                class="flex flex-wrap justify-center items-center gap-1"></div>
                        </div>
                        <div class="flex flex-wrap justify-center items-center mb-6 gap-3"> <button
                                id="tcpCongestionSim_start-button" class="tcpCongestionSim_control-button">开始/下一步
                                (ACK)</button> <button id="tcpCongestionSim_loss-button"
                                class="tcpCongestionSim_control-button bg-red-500 hover:bg-red-600">模拟丢包 (超时)</button>
                            <button id="tcpCongestionSim_dup-ack-button"
                                class="tcpCongestionSim_control-button bg-yellow-500 hover:bg-yellow-600">模拟重复ACK (<span
                                    id="tcpCongestionSim_dup-ack-display">0</span>/3)</button> <button
                                id="tcpCongestionSim_reset-button"
                                class="tcpCongestionSim_control-button bg-gray-500 hover:bg-gray-600">重置</button>
                        </div>
                        <div class="mt-8 h-64"> <canvas id="tcpCongestionSim_congestionChart"></canvas> </div>
                        <div id="tcpCongestionSim_explanation-area" class="tcpCongestionSim_explanation"> 点击 "开始/下一步"
                            按钮启动模拟。初始状态为慢启动，cwnd = 1 MSS。 </div>
                    </div>
                </section>

                <section id="tcp-hol" class="content-section fade-in-section" style="animation-delay: 0.3s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">block</span>TCP 队头阻塞 (Head-of-Line
                        Blocking)
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">原理</h3>
                        <p class="text-sm text-gray-700">由于 TCP 必须保证字节流的 <b>严格有序交付</b>，如果一个 TCP
                            报文段丢失，即使后续的报文段已经到达接收方，接收方的 TCP 协议栈也必须缓存它们，<b>等待丢失的报文段被成功重传</b>
                            后，才能按顺序将数据交付给应用层。这个等待过程就造成了队头阻塞。</p>
                        <p class="text-sm text-gray-700 mt-2">这是 HTTP/1.x 性能瓶颈的主要原因之一（即使使用多连接也受限于连接数），也是 HTTP/2 和 HTTP/3
                            (QUIC) 试图解决的核心问题。</p>
                    </div>
                    <div class="content-card">
                        <h4 class="head4">队头阻塞模拟</h4>
                        <p class="text-sm text-gray-600 mb-4">以下模拟展示了当 SEQ 2 丢失后，后续到达的 SEQ 3 和 SEQ 4 无法立即交付给应用层，必须等待 SEQ
                            2 重传成功后才能按序交付的过程。</p>
                        <div id="tcpHolSim_animation-area"
                            class="mt-6 p-4 border border-blue-200 rounded-lg bg-gradient-to-b from-blue-50 to-white relative overflow-hidden min-h-[450px] shadow-inner">
                            <div class="flex justify-between items-start mb-4 relative z-20">
                                <div class="w-2/5 border border-gray-300 rounded-lg p-3 bg-gray-50 shadow">
                                    <h5 class="font-medium text-center mb-2 text-gray-700 text-base">发送方 (Sender)</h5>
                                    <div class="text-xs mb-2 text-center text-gray-600">窗口大小 (W) = 4</div>
                                    <div id="tcpHolSim_sender-window"
                                        class="relative border border-dashed border-gray-400 p-2 rounded tcpHolSim_highlight-window min-h-[60px]">
                                        <span id="tcpHolSim_sender-window-label"
                                            class="absolute -top-2 -left-2 bg-blue-100 text-blue-700 px-1 py-0.5 text-xs rounded shadow-sm">发送窗口
                                            [1-4]</span>
                                        <div class="flex space-x-1 justify-center items-center mt-2 flex-wrap">
                                            <div id="tcpHolSim_sender-seq-1"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 1 <span class="tcpHolSim_rto-timer" id="tcpHolSim_timer-1"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpHolSim_sender-seq-2"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 2 <span class="tcpHolSim_rto-timer" id="tcpHolSim_timer-2"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpHolSim_sender-seq-3"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 3 <span class="tcpHolSim_rto-timer" id="tcpHolSim_timer-3"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpHolSim_sender-seq-4"
                                                class="p-1 border border-gray-400 rounded bg-white text-xs text-center relative shadow-sm">
                                                SEQ 4 <span class="tcpHolSim_rto-timer" id="tcpHolSim_timer-4"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpHolSim_sender-seq-5"
                                                class="p-1 border border-gray-400 rounded bg-gray-300 text-xs text-center opacity-50 shadow-sm">
                                                SEQ 5 <span class="tcpHolSim_rto-timer" id="tcpHolSim_timer-5"><i
                                                        class="fas fa-clock"></i></span> </div>
                                            <div id="tcpHolSim_sender-seq-6"
                                                class="p-1 border border-gray-400 rounded bg-gray-300 text-xs text-center opacity-50 shadow-sm">
                                                SEQ 6 <span class="tcpHolSim_rto-timer" id="tcpHolSim_timer-6"><i
                                                        class="fas fa-clock"></i></span> </div>
                                        </div>
                                    </div>
                                    <div id="tcpHolSim_sender-status"
                                        class="tcpHolSim_status-text text-xs text-center mt-2 text-blue-600 font-medium">
                                        准备发送...</div>
                                </div>
                                <div class="w-2/5 border border-gray-300 rounded-lg p-3 bg-gray-50 shadow">
                                    <h5 class="font-medium text-center mb-1 text-gray-700 text-base">接收方 (Receiver)</h5>
                                    <div class="border border-green-300 rounded p-2 mb-2 bg-green-50 shadow-inner">
                                        <h6 class="text-sm font-medium text-center text-green-800 mb-1">应用层 (已接收数据)</h6>
                                        <div id="tcpHolSim_app-layer" class="tcpHolSim_app-layer-area min-h-[40px]">
                                        </div>
                                    </div>
                                    <div class="border border-purple-300 rounded p-2 bg-purple-50 shadow-inner">
                                        <h6 class="text-sm font-medium text-center text-purple-800 mb-1">TCP 协议层</h6>
                                        <div class="text-xs text-center mb-2 text-gray-600">期望: <span
                                                id="tcpHolSim_expected-seq" class="font-bold text-purple-700">SEQ
                                                1</span></div>
                                        <div id="tcpHolSim_receiver-buffer"
                                            class="flex space-x-1 justify-center border border-dashed border-gray-400 p-2 rounded min-h-[60px] bg-white flex-wrap">
                                            <div class="tcpHolSim_buffer-slot">空</div>
                                            <div class="tcpHolSim_buffer-slot">空</div>
                                            <div class="tcpHolSim_buffer-slot">空</div>
                                            <div class="tcpHolSim_buffer-slot">空</div>
                                        </div>
                                    </div>
                                    <div id="tcpHolSim_receiver-status"
                                        class="tcpHolSim_status-text text-xs text-center mt-2 text-purple-600 font-medium">
                                        等待数据...</div>
                                </div>
                            </div>
                            <div id="tcpHolSim_network-path"></div>
                            <div id="tcpHolSim_channel" class="absolute top-0 left-0 w-full h-full pointer-events-none">
                            </div>
                            <div id="tcpHolSim_explanation"
                                class="absolute bottom-14 left-1/2 transform -translate-x-1/2 w-11/12 text-center text-sm text-gray-700 bg-white bg-opacity-80 p-2 rounded shadow z-20">
                                点击 "下一步" 开始模拟。 </div>
                        </div>
                        <div class="mt-6 flex justify-center space-x-4">
                            <button id="tcpHolSim_next-step" class="button button-primary"> <i
                                    class="fas fa-forward mr-1"></i> 下一步 </button>
                            <button id="tcpHolSim_reset" class="button button-secondary"> <i
                                    class="fas fa-undo mr-1"></i> 重置 </button>
                        </div>
                    </div>
                </section>

                <section id="udp" class="content-section fade-in-section" style="animation-delay: 0.35s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">rocket_launch</span>UDP: 用户数据报协议
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">UDP 是什么？</h3>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li>全称: <b>User Datagram Protocol</b> (用户数据报协议)，属于 <b>传输层</b> 协议。</li>
                            <li>核心特点: <b>无连接、不可靠、尽最大努力交付、面向报文、头部开销小</b>。</li>
                            <li>主要目标: 提供一种简单的、低开销的数据报传输服务，不保证可靠性和顺序。</li>
                            <li>应用场景: DNS, DHCP, SNMP, TFTP, 实时音视频 (RTP), 在线游戏等对实时性要求高、能容忍少量丢包的应用。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">UDP 报文格式</h3>
                        <p class="text-sm text-gray-600 mb-3"> UDP 头部非常简洁，只有 8 个字节（4 个 16 位字）。点击下方字段查看说明： </p>
                        <div id="udp-header-vis"
                            class="border border-gray-300 rounded overflow-hidden shadow-md select-none">
                            <div class="flex w-full">
                                <div class="header-field flex-1 p-2 text-center border-r border-b border-gray-400 bg-purple-100 hover:bg-purple-300 cursor-pointer text-sm font-mono"
                                    data-info="源端口 (16位): 标识发送方应用程序端口号 (可选)。"> 源端口 (16) </div>
                                <div class="header-field flex-1 p-2 text-center border-b border-gray-400 bg-purple-100 hover:bg-purple-300 cursor-pointer text-sm font-mono"
                                    data-info="目的端口 (16位): 标识接收方应用程序端口号。"> 目的端口 (16) </div>
                            </div>
                            <div class="flex w-full">
                                <div class="header-field flex-1 p-2 text-center border-r border-gray-400 bg-purple-100 hover:bg-purple-300 cursor-pointer text-sm font-mono"
                                    data-info="长度 (16位): UDP头部+数据的总长度(字节)。最小为8。"> 长度 (16) </div>
                                <div class="header-field flex-1 p-2 text-center bg-purple-100 hover:bg-purple-300 cursor-pointer text-sm font-mono"
                                    data-info="校验和 (16位): 用于检测UDP头部和数据在传输中是否出错 (可选, IPv4中可为0)。"> 校验和 (16) </div>
                            </div>
                            <div
                                class="w-full p-4 text-center bg-green-100 text-gray-700 text-sm border-t border-gray-400">
                                数据 (Payload) - 可变长度 </div>
                        </div>
                        <div id="udp-header-info" class="header-info-display"> 点击上方字段查看详细信息...</div>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">UDP vs TCP 对比</h3>
                        <div class="overflow-x-auto">
                            <table>
                                <thead class="bg-purple-100 text-purple-800">
                                    <tr>
                                        <th>特性</th>
                                        <th>TCP</th>
                                        <th>UDP</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>连接性</td>
                                        <td>面向连接 (需要三次握手)</td>
                                        <td>无连接</td>
                                    </tr>
                                    <tr>
                                        <td>可靠性</td>
                                        <td>可靠 (重传、确认、排序)</td>
                                        <td>不可靠 (尽力而为)</td>
                                    </tr>
                                    <tr>
                                        <td>传输单位</td>
                                        <td>字节流</td>
                                        <td>数据报 (保留报文边界)</td>
                                    </tr>
                                    <tr>
                                        <td>头部开销</td>
                                        <td>较大 (20字节起, 可选部更长)</td>
                                        <td>小 (固定8字节)</td>
                                    </tr>
                                    <tr>
                                        <td>流量控制</td>
                                        <td>有 (滑动窗口)</td>
                                        <td>无</td>
                                    </tr>
                                    <tr>
                                        <td>拥塞控制</td>
                                        <td>有</td>
                                        <td>无</td>
                                    </tr>
                                    <tr>
                                        <td>传输效率</td>
                                        <td>相对较低 (因开销和控制机制)</td>
                                        <td>相对较高 (开销小)</td>
                                    </tr>
                                    <tr>
                                        <td>应用场景</td>
                                        <td>HTTP, FTP, Email, 文件传输</td>
                                        <td>DNS, VoIP, 视频流, 游戏, DHCP</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section id="quic" class="content-section fade-in-section" style="animation-delay: 0.4s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">bolt</span>QUIC: 快速 UDP 互联网连接
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">QUIC 是什么？</h3>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li>全称: <b>Quick UDP Internet Connections</b> (快速 UDP 互联网连接)。</li>
                            <li>定位: 定义为 <b>传输层协议 (RFC 9000)</b>，但通常在 <b>用户态</b> 实现，并 <b>基于 UDP</b> 进行传输。</li>
                            <li>核心目标: 结合 TCP 的可靠性和 UDP 的低延迟，并解决 TCP 的一些固有问题（如队头阻塞），同时内置加密。</li>
                            <li>主要特点: <b>低延迟连接建立 (0-RTT/1-RTT)、多路复用无队头阻塞、连接迁移、内置 TLS 1.3 加密、改进的拥塞控制和恢复机制</b>。</li>
                            <li>驱动力: 主要由 Google 推动，是 <b>HTTP/3 的底层传输协议</b>。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">QUIC 在协议栈中的位置</h3>
                        <div class="mermaid text-center my-4 p-2 border rounded bg-white shadow-sm">
                            graph TD
                            subgraph "应用层"
                            A["HTTP/3"]
                            end

                            subgraph "QUIC (基于 UDP 实现的传输功能)"
                            direction TB
                            B["QUIC"]
                            B -- "内置功能" --> F["✔ 可靠传输<br>✔ 多路复用<br>✔ 拥塞控制<br>✔ 流量控制<br>✔ TLS 1.3 加密 (集成)"]
                            end

                            subgraph "传输层"
                            C["UDP"]
                            end

                            subgraph "网络层"
                            D["IP"]
                            end

                            A --> B;
                            B -- "运行于" --> C;
                            C --> D;

                            style B fill:#e6fffa,stroke:#38b2ac,stroke-width:2px;
                            style F fill:#f0f9ff,stroke:#3b82f6,stroke-width:1px,stroke-dasharray: 5 5;
                            style C fill:#f0fdfa,stroke:#0d9488,stroke-width:1px;
                        </div>
                        <p class="text-sm text-gray-700">QUIC 运行在 UDP 之上，但在用户空间实现了原本 TCP 在内核空间提供的许多功能，并进行了改进。</p>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">为什么 QUIC 要基于 UDP？</h3>
                        <ul class="list-disc list-inside space-y-2 text-sm text-gray-700">
                            <li><strong>避免操作系统内核升级：</strong> 修改 TCP 需要更新操作系统内核，部署周期长、难度大。基于 UDP 意味着 QUIC
                                的实现和更新可以在应用程序层面（如浏览器、服务器软件）快速迭代。</li>
                            <li><strong>绕过中间设备僵化：</strong> 许多网络中间设备（防火墙、NAT）对 TCP 的处理逻辑已经固化，可能不支持 TCP 的新选项或修改。UDP
                                通常被视为“简单通道”，限制较少。</li>
                            <li><strong>实现更灵活的创新：</strong> 在用户态实现拥塞控制、流量控制、重传逻辑等，可以更快地试验和部署新的算法和特性。</li>
                            <li><strong>实现连接迁移：</strong> QUIC 使用 Connection ID 而非 IP+端口五元组来标识连接，当客户端网络切换（如 Wi-Fi 切换到
                                4G）导致 IP 或端口变化时，连接可以保持不断开。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">QUIC 的核心优势</h3>
                        <ul
                            class="list-disc list-inside grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-2 text-sm text-gray-700">
                            <li><strong>多路复用无队头阻塞 (Stream Multiplexing without HOL Blocking):</strong> 一条 QUIC
                                连接可以承载多个独立的逻辑流 (Stream)。每个流有自己的序号空间。如果一个流的数据包丢失，只会阻塞该流，不影响其他流的数据传输，解决了 TCP 的队头阻塞问题。</li>
                            <li><strong>更快的连接建立 (0-RTT or 1-RTT Handshake):</strong> QUIC 将传输层握手和 TLS 1.3
                                加密握手合并进行。对于首次连接，通常需要 1-RTT。对于已建立过连接的客户端，可以实现 0-RTT 连接恢复（发送加密的应用数据）。</li>
                            <li><strong>连接迁移 (Connection Migration):</strong> 使用 Connection ID 标识连接，客户端 IP
                                或端口变化时，只需向服务器发送包含旧 Connection ID 的探测包即可恢复连接，无需重新握手。</li>
                            <li><strong>强制加密 (Mandatory Encryption):</strong> QUIC 头部和大部分载荷都经过加密（使用 TLS
                                1.3），提高了通信的安全性，减少了中间设备篡改或窃听的风险。</li>
                            <li><strong>改进的拥塞控制和丢失恢复:</strong> 更精确的 RTT 测量、更丰富的 ACK 信息（确认收到的包序号范围），有助于更快、更准确地检测和恢复丢包。
                            </li>
                        </ul>
                    </div>
                </section>

                <section id="dns" class="content-section fade-in-section" style="animation-delay: 0.45s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">dns</span>DNS 解析
                        <span class="level-tag level-tag-medium">中频</span>
                        <span class="level-tag level-tag-base">基础</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">基本过程</h3>
                        <p>DNS (Domain Name System) 负责将人类可读的域名（如 www.google.com）解析为机器可读的 IP 地址（如
                            172.217.160.142）。基本解析过程涉及一系列查询：</p>
                        <ol class="list-decimal list-inside space-y-1 text-sm">
                            <li><strong>浏览器缓存:</strong> 浏览器首先检查自身缓存中是否有该域名的记录。</li>
                            <li><strong>操作系统缓存:</strong> 如果浏览器缓存未命中，则检查操作系统的 DNS 缓存（如 Windows 的 DNS Client 服务缓存）。</li>
                            <li><strong>Hosts 文件:</strong> 接着检查本地的 Hosts 文件是否有该域名的映射。</li>
                            <li><strong>本地 DNS 服务器 (LDNS):</strong> 如果本地缓存和 Hosts 文件都未命中，请求会发送到配置的本地 DNS 服务器（通常由 ISP
                                或网络管理员提供）。</li>
                            <li><strong>根域名服务器 (Root Server):</strong> LDNS 向根服务器查询，根服务器返回负责顶级域名（如 .com）的 TLD 服务器地址。
                            </li>
                            <li><strong>顶级域名服务器 (TLD Server):</strong> LDNS 向 TLD 服务器查询，TLD 服务器返回负责该域名的权威域名服务器地址。</li>
                            <li><strong>权威域名服务器 (Authoritative Server):</strong> LDNS 向权威服务器查询，权威服务器返回最终的 IP 地址。</li>
                            <li><strong>缓存结果:</strong> LDNS 将查询结果缓存起来，并返回给操作系统/浏览器。</li>
                        </ol>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">递归查询 vs 迭代查询</h3>
                        <strong>递归查询 (Recursive Query):</strong> 通常发生在 <strong>用户/客户端</strong> 与
                        <strong>本地DNS服务器</strong> 之间。客户端只发起一次请求，本地
                        DNS服务器负责代替客户端层层查询，直到获取最终结果或失败，并将结果返回给客户端。"请帮我查到这个域名的IP 地址"。
                        <div class="content-card mb-4">
                            <h4 class="head4">递归查询</h4>
                            <div class="mermaid text-center my-4 p-2 border rounded bg-white shadow-sm">
                                flowchart LR
                                subgraph 查询类型
                                direction LR
                                User -- "域名?" --> LDNS(本地 DNS)
                                subgraph "递归查询 (Recursive)"
                                direction TB
                                LDNS -- "www.example.com?" --> RootDNS((根 DNS))
                                RootDNS -- ".com TLD 地址" --> LDNS
                                LDNS -- "www.example.com?" --> TLDDNS((.com TLD))
                                TLDDNS -- "example.com Auth 地址" --> LDNS
                                LDNS -- "www.example.com?" --> AuthDNS((Auth DNS))
                                AuthDNS -- "IP 地址" --> LDNS
                                end
                                LDNS -- "IP 地址" --> User
                                end

                                %% 节点样式
                                style User fill:#e0f2fe,stroke:#0ea5e9
                                style LDNS fill:#fefce8,stroke:#ca8a04
                                style RootDNS fill:#fce7f3,stroke:#db2777
                                style TLDDNS fill:#ecfdf5,stroke:#16a34a
                                style AuthDNS fill:#f1f5f9,stroke:#64748b

                                %% 边样式：删除非法字符，仅保留标准属性
                                linkStyle 0 stroke:#0ea5e9,stroke-width:2px
                                linkStyle 1 stroke:#a16207,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 2 stroke:#a16207,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 3 stroke:#a16207,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 4 stroke:#a16207,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 5 stroke:#a16207,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 6 stroke:#a16207,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 7 stroke:#0ea5e9,stroke-width:2px
                            </div>
                        </div>

                        <div class="content-card mb-4">
                            <h4 class="head4">迭代查询</h4>
                            <strong>迭代查询 (Iterative Query):</strong> 通常发生在 <strong>本地 DNS 服务器</strong> 与<strong>其他DNS
                                服务器</strong> (根、TLD、权威) 之间。本地 DNS服务器每次只询问一个服务器，该服务器返回它所知道的最佳下一步线索（或最终答案），由本地DNS
                            服务器继续发起下一次查询。"告诉我谁知道 .com 的信息？" -> "告诉我谁知道 example.com 的信息？" -> "告诉我www.example.com的 IP？"。
                            <div class="mermaid text-center my-4 p-2 border rounded bg-white shadow-sm">
                                flowchart LR
                                subgraph 查询类型
                                direction LR
                                User -- "域名?" --> LDNS(本地 DNS)
                                subgraph "迭代查询 (Iterative)"
                                direction TB
                                LDNS -- "www.example.com?" --> RootDNS((根 DNS))
                                RootDNS -- ".com TLD 地址" --> TLDDNS((.com TLD))
                                TLDDNS -- "example.com Auth 地址" --> AuthDNS((Auth DNS))
                                AuthDNS -- "IP 地址" --> LDNS
                                end
                                LDNS -- "IP 地址" --> User
                                end

                                %% 节点样式
                                style User fill:#e0f2fe,stroke:#0ea5e9
                                style LDNS fill:#fefce8,stroke:#ca8a04
                                style RootDNS fill:#fce7f3,stroke:#db2777
                                style TLDDNS fill:#ecfdf5,stroke:#16a34a
                                style AuthDNS fill:#f1f5f9,stroke:#64748b

                                %% 边样式：标准属性，无非法字符
                                linkStyle 0 stroke:#0ea5e9,stroke-width:2px
                                linkStyle 1 stroke:#a16207,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 2 stroke:#16a34a,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 3 stroke:#64748b,stroke-width:1px,stroke-dasharray:5 5
                                linkStyle 4 stroke:#0ea5e9,stroke-width:2px
                            </div>
                        </div>
                    </div>
                </section>

                <section id="kernel-user" class="content-section fade-in-section" style="animation-delay: 0.5s;">
                    <h2 class="flex items-center head2 "><span class="material-icons">memory</span>用户态与内核态
                        <span class="level-tag level-tag-low">低频</span>
                        <span class="level-tag level-tag-advanced">进阶</span>
                    </h2>
                    <div class="content-card">
                        <h3 class="head3">基本概念</h3>
                        <p class="text-sm text-gray-700">现代操作系统为了保护系统安全和稳定，通常将 CPU 的执行状态分为两个级别：</p>
                        <ul class="list-disc list-inside space-y-2 text-sm text-gray-700 mt-2">
                            <li><strong>内核态 (Kernel Mode / Supervisor Mode):</strong>
                                <ul class="list-['-_'] list-inside ml-4 mt-1">
                                    <li>CPU 可以执行 <b>所有指令</b>，访问 <b>所有内存和硬件资源</b>。</li>
                                    <li>操作系统的核心代码（内核）运行在此模式下。</li>
                                    <li>拥有最高权限，负责管理系统资源（进程调度、内存管理、设备驱动等）。</li>
                                </ul>
                            </li>
                            <li><strong>用户态 (User Mode):</strong>
                                <ul class="list-['-_'] list-inside ml-4 mt-1">
                                    <li>CPU 只能执行 <b>受限的指令集</b>，不能直接访问硬件或内核数据。</li>
                                    <li>普通的应用程序运行在此模式下。</li>
                                    <li>权限较低，需要通过 <b>系统调用 (System Call)</b> 的方式请求内核提供服务（如读写文件、网络通信、创建进程等）。</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">为什么需要区分？</h3>
                        <ul class="list-disc list-inside space-y-1 text-sm text-gray-700">
                            <li><strong>安全性:</strong> 限制用户程序直接操作硬件和关键内存区域，防止恶意或错误代码破坏系统。</li>
                            <li><strong>稳定性:</strong> 用户态程序的崩溃通常不会影响操作系统内核的运行；而内核态代码的错误可能导致整个系统崩溃。</li>
                            <li><strong>资源管理:</strong> 内核统一管理和调度系统资源，避免用户程序之间的冲突和资源滥用。</li>
                        </ul>
                    </div>
                    <div class="content-card">
                        <h3 class="head3">与 TCP/QUIC 的关系</h3>
                        <ul class="list-disc list-inside space-y-2 text-sm text-gray-700">
                            <li><strong>TCP 通常在内核态实现:</strong> TCP 协议栈是操作系统网络核心的一部分。应用程序通过 Socket API (系统调用) 请求内核进行 TCP
                                连接建立、数据收发等操作。
                                <ul class="list-['-_'] list-inside ml-4 mt-1 text-xs text-gray-600">
                                    <li>优点: 性能可能更高（内核直接操作），由操作系统统一维护。</li>
                                    <li>缺点: 更新和演进困难，依赖操作系统升级。</li>
                                </ul>
                            </li>
                            <li><strong>QUIC 通常在用户态实现:</strong> QUIC 库作为应用程序的一部分或依赖库运行。它使用 UDP Socket (系统调用)
                                发送和接收数据包，然后在用户态完成 QUIC 协议的逻辑（握手、加密、重传、拥塞控制等）。
                                <ul class="list-['-_'] list-inside ml-4 mt-1 text-xs text-gray-600">
                                    <li>优点: 协议可以快速迭代和部署，不依赖内核；应用层可以更灵活地控制传输行为。</li>
                                    <li>缺点: 可能存在用户态/内核态切换开销；需要应用自己管理协议栈。</li>
                                </ul>
                            </li>
                        </ul>
                        <p class="text-sm font-medium text-gray-800 mt-3">🎯 核心：QUIC 选择在用户态实现，是为了绕开内核更新的限制，实现协议的快速演进和部署。
                        </p>
                    </div>
                </section>

            </article>
        </main>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>


    <script>
        /**
 * JavaScript for 01-Network-Basics.html
 * Handles:
 * - Table of Contents (TOC) highlighting on scroll
 * - Section fade-in animations
 * - Mermaid diagram rendering
 * - Interactive TCP/UDP header field display
 * - Interactive simulations:
 * - TCP Handshake & Wave (Mermaid update)
 * - TCP Reliability / HOL Blocking (Packet animation)
 * - TCP Flow Control (Packet animation & window visualization)
 * - TCP Congestion Control (Chart update & packet visualization)
 */

        // --- Initialize Mermaid ---
        // Initialize Mermaid without starting automatically, as we render manually
        mermaid.initialize({
            startOnLoad: false,
            theme: 'neutral'
        });


        // --- DOMContentLoaded Listener ---
        document.addEventListener('DOMContentLoaded', () => {

            // --- TOC Highlighting & Fade-in ---
            const sections = document.querySelectorAll('main section[id], main li[id]'); // Observe sections and list items with IDs for TOC
            const tocLinks = document.querySelectorAll('#local-toc a');
            const mainContentSections = document.querySelectorAll('main > article > section.content-section'); // Target sections for fade-in

            // TOC Highlighting Logic
            const tocObserverOptions = {
                root: null,
                rootMargin: '-20% 0px -60% 0px', // Prioritize sections near the top
                threshold: 0
            };
            let lastActiveTocLink = null;

            const tocObserverCallback = (entries) => {
                let bestVisibleEntry = null;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Find the best visible entry (closest to the top edge of the intersection area)
                        if (!bestVisibleEntry || entry.boundingClientRect.top < bestVisibleEntry.boundingClientRect.top) {
                            bestVisibleEntry = entry;
                        }
                    }
                });

                if (bestVisibleEntry) {
                    const id = bestVisibleEntry.target.getAttribute('id');
                    // Find the corresponding link in the TOC
                    const activeLink = document.querySelector(`#local-toc a[href="#${id}"]`);

                    if (activeLink && activeLink !== lastActiveTocLink) {
                        // Remove active class from the previously active link
                        if (lastActiveTocLink) {
                            lastActiveTocLink.classList.remove('active');
                        }
                        // Add active class to the new active link
                        activeLink.classList.add('active');
                        lastActiveTocLink = activeLink; // Update the last active link
                    }
                }
            };

            const tocObserver = new IntersectionObserver(tocObserverCallback, tocObserverOptions);
            sections.forEach(section => tocObserver.observe(section)); // Observe all relevant elements

            // Initial active link check based on hash or default to first
            const currentHash = window.location.hash;
            if (currentHash) {
                const initialActiveLink = document.querySelector(`#local-toc a[href="${currentHash}"]`);
                if (initialActiveLink) {
                    tocLinks.forEach(link => link.classList.remove('active')); // Clear default
                    initialActiveLink.classList.add('active');
                    lastActiveTocLink = initialActiveLink;
                }
            } else if (tocLinks.length > 0 && !lastActiveTocLink) {
                // Default to the first link if no hash or matching link found
                tocLinks[0].classList.add('active');
                lastActiveTocLink = tocLinks[0];
            }

            // Fade-in Animation Logic for Sections
            const fadeObserverOptions = { root: null, rootMargin: '0px', threshold: 0.1 };
            const fadeObserverCallback = (entries, observer) => {
                entries.forEach((entry, index) => { // Use index for consistent delay
                    if (entry.isIntersecting) {
                        entry.target.style.animationDelay = `${index * 0.05}s`;
                        entry.target.classList.add('fade-in-section');
                        observer.unobserve(entry.target); // Stop observing once faded in
                    }
                });
            };
            const fadeObserver = new IntersectionObserver(fadeObserverCallback, fadeObserverOptions);
            mainContentSections.forEach(section => fadeObserver.observe(section));

            // --- Interactive Header Field Display ---
            function displayHeaderInfo(containerId, infoDivId) {
                const container = document.getElementById(containerId);
                const infoDiv = document.getElementById(infoDivId);
                if (!container || !infoDiv) {
                    console.warn(`Header display setup failed: Missing elements for ${containerId} or ${infoDivId}`);
                    return;
                }

                let lastClickedField = null;

                container.querySelectorAll('.header-field').forEach(field => {
                    field.addEventListener('click', () => {
                        const info = field.getAttribute('data-info');
                        infoDiv.textContent = info || '暂无详细信息。';
                        infoDiv.style.backgroundColor = '#e2e8f0'; // Indicate update

                        // Reset background color for all fields except the clicked one
                        container.querySelectorAll('.header-field').forEach(f => {
                            if (f !== field) {
                                // Determine original background color (tricky, might need default classes)
                                let defaultBg = '';
                                if (f.classList.contains('bg-blue-100')) defaultBg = '#DBEAFE'; // Tailwind blue-100
                                else if (f.classList.contains('bg-purple-100')) defaultBg = '#F3E8FF'; // Tailwind purple-100
                                else if (f.classList.contains('bg-yellow-100')) defaultBg = '#FEF9C3'; // Tailwind yellow-100
                                // Add more default colors if needed
                                f.style.backgroundColor = defaultBg;
                            }
                        });

                        // Highlight clicked field
                        field.style.backgroundColor = '#63b3ed'; // Highlight blue (Tailwind blue-400 approx)
                        lastClickedField = field; // Remember last clicked

                        setTimeout(() => { infoDiv.style.backgroundColor = ''; }, 300); // Fade back info bg
                    });
                });
            }

            displayHeaderInfo('tcp-header-vis', 'tcp-header-info');
            displayHeaderInfo('udp-header-vis', 'udp-header-info');

            // --- Mermaid Rendering Function ---
            /**
             * Renders a Mermaid diagram definition into a given container.
             * @param {HTMLElement} container - The DOM element to render the diagram into.
             * @param {string} definition - The Mermaid diagram definition string.
             * @param {string} idSuffix - A unique suffix for the generated SVG ID to prevent conflicts.
             */
            async function renderMermaid(container, definition, idSuffix) {
                if (!container || typeof definition !== 'string' || typeof idSuffix !== 'string') {
                    console.error("renderMermaid: Invalid arguments.", { container, definition, idSuffix });
                    if (container) container.innerHTML = "Error: Invalid input for rendering.";
                    return;
                }
                if (!container.id) {
                    console.warn("Mermaid container is missing an ID. Assigning a temporary one.");
                    container.id = `mermaid-temp-${idSuffix}-${Math.random().toString(16).slice(2)}`;
                }
                const svgId = `mermaid-svg-${container.id}-${idSuffix}`;

                try {
                    if (typeof mermaid === 'undefined' || typeof mermaid.render !== 'function') {
                        throw new Error("Mermaid library or mermaid.render function is not available.");
                    }
                    const { svg, bindFunctions } = await mermaid.render(svgId, definition);
                    container.innerHTML = svg;
                    if (bindFunctions) bindFunctions(container);
                } catch (error) {
                    console.error(`Mermaid rendering error for ${svgId}:`, error);
                    container.innerHTML = `<div class="text-red-500 p-4 border border-red-300 rounded bg-red-50">Error rendering diagram. Check console.</div>`;
                }
            }

            // --- TCP Handshake & Wave Simulation ---
            const handshakeDiagramDefs = [
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: CLOSED
Note right of S: LISTEN`,
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: CLOSED
Note right of S: LISTEN
C->>S: SYN (Seq=x)
Note left of C: SYN_SENT`,
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: CLOSED
Note right of S: LISTEN
C->>S: SYN (Seq=x)
Note left of C: SYN_SENT
S-->>C: SYN+ACK (Seq=y, Ack=x+1)
Note right of S: SYN_RCVD`,
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: CLOSED
Note right of S: LISTEN
C->>S: SYN (Seq=x)
Note left of C: SYN_SENT
S-->>C: SYN+ACK (Seq=y, Ack=x+1)
Note right of S: SYN_RCVD
C->>S: ACK (Ack=y+1)
Note left of C: ESTABLISHED
Note right of S: ESTABLISHED`
            ];
            const waveDiagramDefs = [
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: ESTABLISHED
Note right of S: ESTABLISHED`,
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: ESTABLISHED
Note right of S: ESTABLISHED
C->>S: FIN (Seq=u)
Note left of C: FIN_WAIT_1`,
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: ESTABLISHED
Note right of S: ESTABLISHED
C->>S: FIN (Seq=u)
Note left of C: FIN_WAIT_1
S-->>C: ACK (Ack=u+1)
Note left of C: FIN_WAIT_2
Note right of S: CLOSE_WAIT`,
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: ESTABLISHED
Note right of S: ESTABLISHED
C->>S: FIN (Seq=u)
Note left of C: FIN_WAIT_1
S-->>C: ACK (Ack=u+1)
Note left of C: FIN_WAIT_2
Note right of S: CLOSE_WAIT
Note right of S: Server may still send data...
S->>C: FIN (Seq=v)
Note right of S: LAST_ACK`,
                `sequenceDiagram
participant C as Client
participant S as Server
Note left of C: ESTABLISHED
Note right of S: ESTABLISHED
C->>S: FIN (Seq=u)
Note left of C: FIN_WAIT_1
S-->>C: ACK (Ack=u+1)
Note left of C: FIN_WAIT_2
Note right of S: CLOSE_WAIT
Note right of S: Server may still send data...
S->>C: FIN (Seq=v)
Note right of S: LAST_ACK
C-->>S: ACK (Ack=v+1)
Note left of C: TIME_WAIT (2*MSL)
Note right of S: CLOSED
Note left of C: ...after 2*MSL... CLOSED`
            ];

            let currentHandshakeStep = 0;
            const handshakeSteps = [
                document.getElementById('handshake-step-1'),
                document.getElementById('handshake-step-2'),
                document.getElementById('handshake-step-3')
            ].filter(el => el !== null);
            const nextHandshakeBtn = document.getElementById('next-handshake-step');
            const handshakeDiagramContainer = document.getElementById('mermaid-handshake-diagram');

            let currentWaveStep = 0;
            const waveSteps = [
                document.getElementById('wave-step-1'),
                document.getElementById('wave-step-2'),
                document.getElementById('wave-step-3'),
                document.getElementById('wave-step-4')
            ].filter(el => el !== null);
            const nextWaveBtn = document.getElementById('next-wave-step');
            const waveDiagramContainer = document.getElementById('mermaid-wave-diagram');

            function showHandshakeStep(stepIndexToShow) {
                handshakeSteps.forEach((step, index) => {
                    if (step) step.classList.toggle('active', index === (stepIndexToShow - 1));
                });
                if (handshakeDiagramContainer && handshakeDiagramDefs[stepIndexToShow]) {
                    renderMermaid(handshakeDiagramContainer, handshakeDiagramDefs[stepIndexToShow], `h${stepIndexToShow}`);
                }
            }

            function showWaveStep(stepIndexToShow) {
                waveSteps.forEach((step, index) => {
                    if (step) step.classList.toggle('active', index === (stepIndexToShow - 1));
                });
                if (waveDiagramContainer && waveDiagramDefs[stepIndexToShow]) {
                    renderMermaid(waveDiagramContainer, waveDiagramDefs[stepIndexToShow], `w${stepIndexToShow}`);
                }
            }

            if (nextHandshakeBtn && handshakeSteps.length > 0 && handshakeDiagramContainer) {
                renderMermaid(handshakeDiagramContainer, handshakeDiagramDefs[0], 'h0'); // Initial render
                nextHandshakeBtn.addEventListener('click', () => {
                    currentHandshakeStep = (currentHandshakeStep % handshakeSteps.length) + 1;
                    showHandshakeStep(currentHandshakeStep);
                    nextHandshakeBtn.innerHTML = (currentHandshakeStep === handshakeSteps.length)
                        ? '<i class="fas fa-redo mr-1"></i> 重置 (握手)'
                        : '<i class="fas fa-play mr-1"></i> 下一步 (握手)';
                });
            }

            if (nextWaveBtn && waveSteps.length > 0 && waveDiagramContainer) {
                renderMermaid(waveDiagramContainer, waveDiagramDefs[0], 'w0'); // Initial render
                nextWaveBtn.addEventListener('click', () => {
                    currentWaveStep = (currentWaveStep % waveSteps.length) + 1;
                    showWaveStep(currentWaveStep);
                    nextWaveBtn.innerHTML = (currentWaveStep === waveSteps.length)
                        ? '<i class="fas fa-redo mr-1"></i> 重置 (挥手)'
                        : '<i class="fas fa-play mr-1"></i> 下一步 (挥手)';
                });
            }

            // Render static Mermaid diagrams on the page
            try {
                mermaid.run();
            } catch (e) {
                console.error("Error running Mermaid on static elements:", e);
            }

            // --- TCP Reliability / HOL Blocking Simulation (tcpHolSim_) ---
            const tcpHolSim_elements = {
                animationArea: document.getElementById('tcpHolSim_animation-area'),
                channel: document.getElementById('tcpHolSim_channel'),
                senderWindow: document.getElementById('tcpHolSim_sender-window'),
                senderWindowLabel: document.getElementById('tcpHolSim_sender-window-label'),
                receiverBuffer: document.getElementById('tcpHolSim_receiver-buffer'),
                appLayer: document.getElementById('tcpHolSim_app-layer'),
                nextStepBtn: document.getElementById('tcpHolSim_next-step'),
                resetBtn: document.getElementById('tcpHolSim_reset'),
                explanation: document.getElementById('tcpHolSim_explanation'),
                expectedSeqEl: document.getElementById('tcpHolSim_expected-seq'),
                senderStatus: document.getElementById('tcpHolSim_sender-status'),
                receiverStatus: document.getElementById('tcpHolSim_receiver-status'),
                networkPath: document.getElementById('tcpHolSim_network-path'),
                senderSeqElements: {},
                senderRtoTimers: {},
                bufferSlots: document.querySelectorAll('#tcpHolSim_receiver-buffer .tcpHolSim_buffer-slot')
            };
            const TCPHOLSIM_MAX_SEQ = 6;
            for (let i = 1; i <= TCPHOLSIM_MAX_SEQ; i++) {
                tcpHolSim_elements.senderSeqElements[i] = document.getElementById(`tcpHolSim_sender-seq-${i}`);
                tcpHolSim_elements.senderRtoTimers[i] = document.getElementById(`tcpHolSim_timer-${i}`);
            }

            let tcpHolSim_state = {
                currentStep: 0,
                packets: {},
                acks: {},
                receiverBufferContent: {},
                deliveredToAppSeq: new Set(),
                expectedSeqNum: 1,
                senderWindowStart: 1,
                senderWindowSize: 4,
                rtoTimersActive: {},
                animationInProgress: false,
                senderStartX: 50, // Default positions, will be recalculated
                senderStartY: 150,
                receiverEndX: 350,
                receiverEndY: 150,
                ackReturnY: 200,
                appLayerY: 100
            };

            function tcpHolSim_calculatePositions() {
                requestAnimationFrame(() => {
                    const senderBox = tcpHolSim_elements.senderSeqElements[1]?.getBoundingClientRect();
                    const receiverBox = tcpHolSim_elements.receiverBuffer?.getBoundingClientRect();
                    const channelBox = tcpHolSim_elements.animationArea?.getBoundingClientRect();
                    const pathBox = tcpHolSim_elements.networkPath?.getBoundingClientRect();
                    const appBox = tcpHolSim_elements.appLayer?.getBoundingClientRect();

                    if (!senderBox || !receiverBox || !channelBox || !pathBox || !appBox) {
                        console.warn("tcpHolSim: Could not calculate positions, elements missing.");
                        return;
                    }

                    tcpHolSim_state.senderStartX = senderBox.left - channelBox.left + senderBox.width / 2;
                    tcpHolSim_state.receiverEndX = receiverBox.left - channelBox.left + receiverBox.width / 2;
                    tcpHolSim_state.receiverEndY = pathBox.top - channelBox.top - 15;
                    tcpHolSim_state.senderStartY = tcpHolSim_state.receiverEndY;
                    tcpHolSim_state.ackReturnY = pathBox.top - channelBox.top + 15;
                    tcpHolSim_state.appLayerY = appBox.top - channelBox.top + appBox.height / 2;
                });
            }

            // (Include all helper functions from 传输层.html for the tcpRelSim_, prefixed with tcpHolSim_)
            // e.g., tcpHolSim_createPacketElement, tcpHolSim_createAckElement, tcpHolSim_moveElement, etc.
            // ... (implementation of helper functions adapted with tcpHolSim_ prefix) ...
            // --- Helper Functions (Adapted with tcpHolSim_ prefix) ---

            function tcpHolSim_createPacketElement(seqNum, isRetransmit = false) {
                const uniqueIdPart = `${seqNum}-${isRetransmit ? 'retransmit' : 'orig'}-${Date.now()}`;
                const packetId = `tcpHolSim_packet-${uniqueIdPart}`;
                const packet = document.createElement('div');
                packet.id = packetId;
                packet.className = 'tcpHolSim_packet p-1 border border-blue-500 rounded bg-blue-100 text-xs text-center shadow-md min-w-[40px]';
                packet.textContent = `SEQ ${seqNum}`;
                if (isRetransmit) {
                    packet.classList.add('tcpHolSim_packet-retransmitted');
                    packet.textContent += ' (重传)';
                }
                packet.style.position = 'absolute'; // Ensure absolute positioning initially
                packet.style.left = `${tcpHolSim_state.senderStartX}px`;
                packet.style.top = `${tcpHolSim_state.senderStartY}px`;
                tcpHolSim_elements.channel.appendChild(packet);
                tcpHolSim_state.packets[packetId] = { element: packet, seq: seqNum, state: 'sending', isRetransmit, id: packetId };
                return packet;
            }

            function tcpHolSim_createAckElement(ackNum, isDuplicate = false) {
                const uniqueIdPart = `${ackNum}-${isDuplicate ? 'dup' : 'orig'}-${Date.now()}`;
                const ackId = `tcpHolSim_ack-${uniqueIdPart}`;
                const ack = document.createElement('div');
                ack.id = ackId;
                ack.className = 'tcpHolSim_ack p-1 border border-green-500 rounded bg-green-100 text-xs text-center shadow min-w-[40px]';
                ack.textContent = `ACK ${ackNum}`;
                if (isDuplicate) {
                    ack.classList.remove('border-green-500', 'bg-green-100');
                    ack.classList.add('border-orange-500', 'bg-orange-100');
                    ack.textContent += ' (重复)';
                }
                ack.style.position = 'absolute'; // Ensure absolute positioning initially
                ack.style.left = `${tcpHolSim_state.receiverEndX}px`;
                ack.style.top = `${tcpHolSim_state.ackReturnY}px`;
                tcpHolSim_elements.channel.appendChild(ack);
                tcpHolSim_state.acks[ackId] = { element: ack, ack: ackNum, state: 'sending', isDuplicate, id: ackId };
                return ack;
            }

            function tcpHolSim_moveElement(element, targetX, targetY, callback) {
                if (!element || !element.style || !element.parentElement) {
                    console.warn("tcpHolSim: Attempted to move an invalid or detached element:", element);
                    if (callback) requestAnimationFrame(callback);
                    return;
                }
                element.style.position = 'absolute';
                void element.offsetWidth; // Force reflow

                const elementWidth = element.offsetWidth || 40;
                const elementHeight = element.offsetHeight || 24;
                element.style.left = `${targetX - elementWidth / 2}px`;
                element.style.top = `${targetY - elementHeight / 2}px`;

                const transitionEndHandler = (event) => {
                    if (event.target === element && (event.propertyName === 'left' || event.propertyName === 'top')) {
                        element.removeEventListener('transitionend', transitionEndHandler);
                        if (callback) requestAnimationFrame(callback);
                    }
                };
                element.addEventListener('transitionend', transitionEndHandler);

                // Fallback timer
                setTimeout(() => {
                    element.removeEventListener('transitionend', transitionEndHandler);
                    // Check if callback already executed? Hard to do reliably.
                    // If element still exists and callback hasn't run, maybe run it?
                    // For simplicity, we might rely on the transitionend event primarily.
                }, 3000); // Slightly longer than animation
            }

            function tcpHolSim_applyArrivalCue(element) {
                if (!element) return;
                element.classList.add('tcpHolSim_packet-arrived-cue');
                setTimeout(() => {
                    if (element) element.classList.remove('tcpHolSim_packet-arrived-cue');
                }, 500);
            }

            function tcpHolSim_applyLosingCue(element, callback) {
                if (!element) return;
                element.classList.add('tcpHolSim_packet-losing');
                setTimeout(() => {
                    if (element) element.classList.remove('tcpHolSim_packet-losing');
                    if (callback) callback();
                }, 500);
            }

            function tcpHolSim_updateExplanation(text) { if (tcpHolSim_elements.explanation) tcpHolSim_elements.explanation.textContent = text; }
            function tcpHolSim_updateSenderStatus(text) { if (tcpHolSim_elements.senderStatus) { tcpHolSim_elements.senderStatus.style.opacity = 0; setTimeout(() => { tcpHolSim_elements.senderStatus.textContent = text; tcpHolSim_elements.senderStatus.style.opacity = 1; }, 300); } }
            function tcpHolSim_updateReceiverStatus(text) { if (tcpHolSim_elements.receiverStatus) { tcpHolSim_elements.receiverStatus.style.opacity = 0; setTimeout(() => { tcpHolSim_elements.receiverStatus.textContent = text; tcpHolSim_elements.receiverStatus.style.opacity = 1; }, 300); } }

            function tcpHolSim_updateExpectedSeq(seqNum) {
                tcpHolSim_state.expectedSeqNum = seqNum;
                if (tcpHolSim_elements.expectedSeqEl) {
                    tcpHolSim_elements.expectedSeqEl.textContent = `SEQ ${seqNum}`;
                    tcpHolSim_elements.expectedSeqEl.classList.add('transition', 'duration-300', 'transform', 'scale-110');
                    setTimeout(() => tcpHolSim_elements.expectedSeqEl.classList.remove('scale-110'), 300);
                }
            }

            function tcpHolSim_updateSenderWindowVisual() {
                const windowEnd = tcpHolSim_state.senderWindowStart + tcpHolSim_state.senderWindowSize - 1;
                if (tcpHolSim_elements.senderWindowLabel) tcpHolSim_elements.senderWindowLabel.textContent = `发送窗口 [${tcpHolSim_state.senderWindowStart}-${windowEnd}]`;
                for (let i = 1; i <= TCPHOLSIM_MAX_SEQ; i++) {
                    const el = tcpHolSim_elements.senderSeqElements[i];
                    if (el) {
                        const isInWindow = (i >= tcpHolSim_state.senderWindowStart && i <= windowEnd);
                        const isAcked = (i < tcpHolSim_state.senderWindowStart);
                        el.classList.remove('opacity-50', 'bg-green-200', 'border-green-400', 'bg-gray-300', 'bg-white');
                        if (isAcked) {
                            el.classList.add('opacity-50', 'bg-green-200', 'border-green-400');
                        } else if (isInWindow) {
                            el.classList.add('bg-white');
                        } else {
                            el.classList.add('opacity-50', 'bg-gray-300');
                        }
                    }
                }
            }

            function tcpHolSim_addToReceiverBuffer(packetId) {
                const packetInfo = tcpHolSim_state.packets[packetId];
                if (!packetInfo || !packetInfo.element) return;
                const packetElement = packetInfo.element;
                packetElement.classList.remove('tcpHolSim_packet-arrived-cue');
                packetElement.classList.add('tcpHolSim_packet-buffered');
                tcpHolSim_state.receiverBufferContent[packetInfo.seq] = packetId;
                packetInfo.state = 'buffered';
                tcpHolSim_updateReceiverBufferVisualOrder();
            }

            function tcpHolSim_updateReceiverBufferVisualOrder() {
                const sortedKeys = Object.keys(tcpHolSim_state.receiverBufferContent).map(Number).sort((a, b) => a - b);
                tcpHolSim_elements.bufferSlots.forEach(slot => {
                    slot.innerHTML = '';
                    slot.classList.add('bg-gray-200');
                    slot.textContent = '空';
                });
                sortedKeys.forEach((seqNum, index) => {
                    if (index < tcpHolSim_elements.bufferSlots.length) {
                        const packetId = tcpHolSim_state.receiverBufferContent[seqNum];
                        const packetEl = tcpHolSim_state.packets[packetId]?.element;
                        if (packetEl) {
                            packetEl.style.position = 'static';
                            tcpHolSim_elements.bufferSlots[index].innerHTML = '';
                            tcpHolSim_elements.bufferSlots[index].appendChild(packetEl);
                            tcpHolSim_elements.bufferSlots[index].classList.remove('bg-gray-200');
                        }
                    }
                });
            }

            function tcpHolSim_deliverSequenceToApp(onCompleteCallback) {
                let deliveredSomething = false;
                let deliveryChainComplete = true;

                while (tcpHolSim_state.receiverBufferContent[tcpHolSim_state.expectedSeqNum]) {
                    deliveryChainComplete = false;
                    const currentExpectedSeq = tcpHolSim_state.expectedSeqNum; // Capture current value
                    const packetIdToDeliver = tcpHolSim_state.receiverBufferContent[currentExpectedSeq];
                    const packetElement = tcpHolSim_state.packets[packetIdToDeliver]?.element;
                    const packetInfo = tcpHolSim_state.packets[packetIdToDeliver];

                    if (!packetElement || !packetInfo) {
                        console.error(`tcpHolSim: Packet data not found for SEQ ${currentExpectedSeq} in buffer.`);
                        delete tcpHolSim_state.receiverBufferContent[currentExpectedSeq];
                        tcpHolSim_state.expectedSeqNum++;
                        continue;
                    }

                    const slot = packetElement.parentElement;
                    if (!slot || !slot.classList.contains('tcpHolSim_buffer-slot')) {
                        console.error(`tcpHolSim: Packet SEQ ${currentExpectedSeq} is not in a buffer slot.`);
                        delete tcpHolSim_state.receiverBufferContent[currentExpectedSeq];
                        tcpHolSim_state.expectedSeqNum++;
                        continue;
                    }
                    const slotRect = slot.getBoundingClientRect();
                    const channelRect = tcpHolSim_elements.animationArea.getBoundingClientRect();
                    const startX = slotRect.left - channelRect.left + slotRect.width / 2;
                    const startY = slotRect.top - channelRect.top + slotRect.height / 2;

                    packetElement.style.position = 'absolute';
                    packetElement.style.left = `${startX - packetElement.offsetWidth / 2}px`;
                    packetElement.style.top = `${startY - packetElement.offsetHeight / 2}px`;
                    tcpHolSim_elements.channel.appendChild(packetElement);
                    slot.innerHTML = '空';
                    slot.classList.add('bg-gray-200');

                    packetElement.classList.remove('tcpHolSim_packet-buffered');
                    packetElement.style.transform = 'scale(1)';

                    // Remove from buffer state *before* starting animation
                    delete tcpHolSim_state.receiverBufferContent[currentExpectedSeq];

                    tcpHolSim_moveElement(packetElement, tcpHolSim_state.receiverEndX, tcpHolSim_state.appLayerY, () => {
                        packetElement.style.position = 'static';
                        packetElement.classList.add('tcpHolSim_packet-delivered');
                        tcpHolSim_elements.appLayer.appendChild(packetElement);
                        tcpHolSim_state.deliveredToAppSeq.add(currentExpectedSeq);
                        if (packetInfo) packetInfo.state = 'delivered';
                        tcpHolSim_sortAppLayer();

                        // Update expected seq *after* delivery animation
                        // Check if the expected number is still the one we just delivered
                        if (tcpHolSim_state.expectedSeqNum === currentExpectedSeq) {
                            tcpHolSim_updateExpectedSeq(currentExpectedSeq + 1);
                        } else {
                            console.warn(`tcpHolSim: Expected sequence number changed during delivery animation of ${currentExpectedSeq}. Now expects ${tcpHolSim_state.expectedSeqNum}`);
                        }

                        deliveredSomething = true;
                        // Check next packet after a short delay
                        setTimeout(() => tcpHolSim_deliverSequenceToApp(onCompleteCallback), 100);
                    });

                    return true; // Indicate delivery was initiated
                }

                if (deliveryChainComplete && onCompleteCallback) {
                    setTimeout(onCompleteCallback, 50);
                }
                return deliveredSomething;
            }

            function tcpHolSim_sortAppLayer() {
                const appPackets = Array.from(tcpHolSim_elements.appLayer.children);
                appPackets.sort((a, b) => {
                    const seqA = parseInt(a.textContent.match(/SEQ (\d+)/)?.[1] || '0');
                    const seqB = parseInt(b.textContent.match(/SEQ (\d+)/)?.[1] || '0');
                    return seqA - seqB;
                });
                appPackets.forEach(p => tcpHolSim_elements.appLayer.appendChild(p));
            }

            function tcpHolSim_startRtoTimerVisual(seqNum) { const timerEl = tcpHolSim_elements.senderRtoTimers[seqNum]; if (timerEl) { timerEl.classList.remove('expired'); timerEl.classList.add('active'); tcpHolSim_state.rtoTimersActive[seqNum] = true; } }
            function tcpHolSim_expireRtoTimerVisual(seqNum) { const timerEl = tcpHolSim_elements.senderRtoTimers[seqNum]; if (timerEl && tcpHolSim_state.rtoTimersActive[seqNum]) { timerEl.classList.add('expired'); } }
            function tcpHolSim_resetRtoTimerVisual(seqNum) { const timerEl = tcpHolSim_elements.senderRtoTimers[seqNum]; if (timerEl) { timerEl.classList.remove('active', 'expired'); tcpHolSim_state.rtoTimersActive[seqNum] = false; } }

            // Define tcpHolSim_steps array (copy and adapt steps from 传输层.html, using tcpHolSim_ prefix)
            const tcpHolSim_steps = [
                // Step 0: Initial State Setup
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    tcpHolSim_updateExplanation("初始状态：发送方准备按窗口大小 (W=4) 发送数据。接收方期望收到 SEQ 1。");
                    tcpHolSim_updateSenderStatus("准备就绪");
                    tcpHolSim_updateReceiverStatus("等待 SEQ 1");
                    tcpHolSim_updateSenderWindowVisual();
                    tcpHolSim_updateExpectedSeq(1);
                    tcpHolSim_state.animationInProgress = false;
                },
                // Step 1: Send SEQ 1, 2, 3, 4
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    tcpHolSim_updateExplanation("步骤 1: 发送方发送窗口内的数据包 (SEQ 1, 2, 3, 4)。");
                    tcpHolSim_updateSenderStatus("发送 SEQ 1-4");
                    let packetsStartedMoving = 0;
                    const totalPackets = 4;
                    const onAllStarted = () => {
                        packetsStartedMoving++;
                        if (packetsStartedMoving === totalPackets) {
                            tcpHolSim_state.animationInProgress = false; // Unlock after all starts
                        }
                    };

                    [1, 2, 3, 4].forEach((seq, index) => {
                        if (!tcpHolSim_state.senderStartX) {
                            console.warn("tcpHolSim: Positions not calculated yet, delaying step 1.");
                            setTimeout(() => tcpHolSim_steps[1](), 100);
                            return;
                        }
                        const packet = tcpHolSim_createPacketElement(seq);
                        tcpHolSim_startRtoTimerVisual(seq);
                        setTimeout(() => {
                            if (packet && tcpHolSim_state.packets[packet.id]) {
                                tcpHolSim_moveElement(packet, tcpHolSim_state.receiverEndX, tcpHolSim_state.receiverEndY, () => {
                                    if (tcpHolSim_state.packets[packet.id]) tcpHolSim_state.packets[packet.id].state = 'arrived_at_receiver_location';
                                });
                                onAllStarted(); // Count towards unlocking
                            } else {
                                console.warn(`tcpHolSim: Packet ${seq} element creation or state tracking failed.`);
                                onAllStarted(); // Still count
                            }
                        }, index * 400); // Stagger sending
                    });
                },
                // Step 2: SEQ 2 Lost During Transit
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    let packet2Id = Object.keys(tcpHolSim_state.packets).find(id => tcpHolSim_state.packets[id].seq === 2 && !tcpHolSim_state.packets[id].isRetransmit && (tcpHolSim_state.packets[id].state === 'sending' || tcpHolSim_state.packets[id].state === 'arrived_at_receiver_location'));
                    const packet2 = packet2Id ? tcpHolSim_state.packets[packet2Id].element : null;
                    const packet2Info = packet2Id ? tcpHolSim_state.packets[packet2Id] : null;

                    tcpHolSim_updateExplanation("步骤 2: SEQ 2 在传输过程中丢失！");
                    tcpHolSim_updateSenderStatus("等待 ACK...");
                    tcpHolSim_updateReceiverStatus("等待 SEQ 1...");

                    if (packet2 && packet2Info) {
                        packet2.style.transition = 'all 0.5s ease-out';
                        const currentLeft = parseFloat(packet2.style.left);
                        const moveDist = (tcpHolSim_state.receiverEndX - tcpHolSim_state.senderStartX) * 0.3;
                        packet2.style.left = `${currentLeft + moveDist}px`;

                        setTimeout(() => {
                            tcpHolSim_applyLosingCue(packet2, () => {
                                if (!packet2) return;
                                packet2.classList.add('tcpHolSim_packet-lost');
                                packet2Info.state = 'lost';
                                setTimeout(() => {
                                    if (packet2 && packet2.parentNode) {
                                        packet2.parentNode.removeChild(packet2);
                                    }
                                    tcpHolSim_state.animationInProgress = false;
                                }, 800);
                            });
                        }, 500);
                    } else {
                        console.warn("tcpHolSim: Original Packet 2 not found or not in sending state for loss.");
                        let lostPacket2Info = Object.values(tcpHolSim_state.packets).find(p => p.seq === 2 && !p.isRetransmit);
                        if (lostPacket2Info) lostPacket2Info.state = 'lost';
                        tcpHolSim_state.animationInProgress = false;
                    }
                },
                // Step 3: SEQ 1 Arrives, Delivered, ACK 2 Sent
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    let packet1Id = Object.keys(tcpHolSim_state.packets).find(id => tcpHolSim_state.packets[id].seq === 1 && tcpHolSim_state.packets[id].state === 'arrived_at_receiver_location');
                    const packet1 = packet1Id ? tcpHolSim_state.packets[packet1Id].element : null;
                    const packet1Info = packet1Id ? tcpHolSim_state.packets[packet1Id] : null;

                    tcpHolSim_updateExplanation("步骤 3: SEQ 1 到达接收方。接收方将其交付给应用层，并发送 ACK 2。");
                    tcpHolSim_updateReceiverStatus("收到 SEQ 1, 交付应用层, 发送 ACK 2");

                    if (packet1 && packet1Info) {
                        packet1Info.state = 'arrived_in_order';
                        tcpHolSim_applyArrivalCue(packet1);
                        setTimeout(() => {
                            if (!packet1) return;
                            tcpHolSim_updateExpectedSeq(2);
                            tcpHolSim_moveElement(packet1, tcpHolSim_state.receiverEndX, tcpHolSim_state.appLayerY, () => {
                                packet1.style.position = 'static';
                                packet1.classList.add('tcpHolSim_packet-delivered');
                                tcpHolSim_elements.appLayer.appendChild(packet1);
                                tcpHolSim_state.deliveredToAppSeq.add(1);
                                packet1Info.state = 'delivered';
                                tcpHolSim_sortAppLayer();
                                const ack2 = tcpHolSim_createAckElement(2);
                                tcpHolSim_moveElement(ack2, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => {
                                    if (tcpHolSim_state.acks[ack2.id]) tcpHolSim_state.acks[ack2.id].state = 'arrived_at_sender';
                                    tcpHolSim_state.animationInProgress = false; // Unlock after ACK arrives
                                });
                            });
                        }, 600);
                    } else {
                        console.error("tcpHolSim: Packet 1 not found or not in correct state at Step 3.");
                        tcpHolSim_updateExpectedSeq(2);
                        tcpHolSim_state.deliveredToAppSeq.add(1);
                        const ack2 = tcpHolSim_createAckElement(2);
                        tcpHolSim_moveElement(ack2, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => { tcpHolSim_state.animationInProgress = false; });
                    }
                },
                // Step 4: SEQ 3 Arrives, Buffered, Repeat ACK 2
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    let packet3Id = Object.keys(tcpHolSim_state.packets).find(id => tcpHolSim_state.packets[id].seq === 3 && tcpHolSim_state.packets[id].state === 'arrived_at_receiver_location');
                    const packet3 = packet3Id ? tcpHolSim_state.packets[packet3Id].element : null;
                    const packet3Info = packet3Id ? tcpHolSim_state.packets[packet3Id] : null;

                    tcpHolSim_updateExplanation("步骤 4: SEQ 3 到达。因期望 SEQ 2 而失序，被放入缓冲区。接收方重复发送 ACK 2。");
                    tcpHolSim_updateReceiverStatus("收到乱序 SEQ 3, 缓冲, 重复 ACK 2");

                    if (packet3 && packet3Info) {
                        packet3Info.state = 'arrived_ooo';
                        tcpHolSim_applyArrivalCue(packet3);
                        setTimeout(() => {
                            if (!packet3) return;
                            tcpHolSim_addToReceiverBuffer(packet3Info.id);
                            const ack2_dup1 = tcpHolSim_createAckElement(2, true);
                            tcpHolSim_moveElement(ack2_dup1, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => {
                                if (tcpHolSim_state.acks[ack2_dup1.id]) tcpHolSim_state.acks[ack2_dup1.id].state = 'arrived_at_sender';
                                tcpHolSim_state.animationInProgress = false; // Unlock after dup ACK arrives
                            });
                        }, 600);
                    } else {
                        console.error("tcpHolSim: Packet 3 not found or not in correct state at Step 4.");
                        const ack2_dup1 = tcpHolSim_createAckElement(2, true);
                        tcpHolSim_moveElement(ack2_dup1, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => { tcpHolSim_state.animationInProgress = false; });
                    }
                },
                // Step 5: SEQ 4 Arrives, Buffered, Repeat ACK 2 (HOL Blocking Visible)
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    let packet4Id = Object.keys(tcpHolSim_state.packets).find(id => tcpHolSim_state.packets[id].seq === 4 && tcpHolSim_state.packets[id].state === 'arrived_at_receiver_location');
                    const packet4 = packet4Id ? tcpHolSim_state.packets[packet4Id].element : null;
                    const packet4Info = packet4Id ? tcpHolSim_state.packets[packet4Id] : null;

                    tcpHolSim_updateExplanation("步骤 5: SEQ 4 到达。仍然失序，放入缓冲区。再次重复发送 ACK 2。队头阻塞发生！");
                    tcpHolSim_updateReceiverStatus("收到乱序 SEQ 4, 缓冲, 重复 ACK 2");

                    if (packet4 && packet4Info) {
                        packet4Info.state = 'arrived_ooo';
                        tcpHolSim_applyArrivalCue(packet4);
                        setTimeout(() => {
                            if (!packet4) return;
                            tcpHolSim_addToReceiverBuffer(packet4Info.id);
                            const ack2_dup2 = tcpHolSim_createAckElement(2, true);
                            tcpHolSim_moveElement(ack2_dup2, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => {
                                if (tcpHolSim_state.acks[ack2_dup2.id]) tcpHolSim_state.acks[ack2_dup2.id].state = 'arrived_at_sender';
                                tcpHolSim_state.animationInProgress = false; // Unlock after dup ACK arrives
                            });
                        }, 600);
                    } else {
                        console.error("tcpHolSim: Packet 4 not found or not in correct state at Step 5.");
                        const ack2_dup2 = tcpHolSim_createAckElement(2, true);
                        tcpHolSim_moveElement(ack2_dup2, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => { tcpHolSim_state.animationInProgress = false; });
                    }
                },
                // Step 6: Sender Processes original ACK 2, Slides Window, Sends SEQ 5
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    tcpHolSim_updateExplanation("步骤 6: 发送方收到第一个 ACK 2，确认 SEQ 1。窗口滑动至 [2-5]，并发送 SEQ 5。");
                    tcpHolSim_updateSenderStatus("收到 ACK 2, 窗口 -> [2-5], 发送 SEQ 5");

                    // Process the first non-duplicate ACK 2
                    const ack2ToProcessId = Object.keys(tcpHolSim_state.acks).find(id =>
                        tcpHolSim_state.acks[id].ack === 2 &&
                        !tcpHolSim_state.acks[id].isDuplicate &&
                        tcpHolSim_state.acks[id].state === 'arrived_at_sender'
                    );

                    if (ack2ToProcessId) {
                        const ackElement = tcpHolSim_state.acks[ack2ToProcessId].element;
                        if (ackElement && ackElement.parentNode) ackElement.parentNode.removeChild(ackElement);
                        delete tcpHolSim_state.acks[ack2ToProcessId];
                        tcpHolSim_resetRtoTimerVisual(1); // Stop timer for ACKed packet
                        const packet1Info = Object.values(tcpHolSim_state.packets).find(p => p.seq === 1 && !p.isRetransmit);
                        if (packet1Info) packet1Info.state = 'acked';
                    } else {
                        console.warn("tcpHolSim: Original ACK 2 not found or not arrived at sender yet for processing in Step 6.");
                        // Assume ACK logically processed for demo flow
                    }

                    // Slide Window
                    tcpHolSim_state.senderWindowStart = 2;
                    tcpHolSim_updateSenderWindowVisual();

                    // Send SEQ 5
                    const packet5 = tcpHolSim_createPacketElement(5);
                    tcpHolSim_startRtoTimerVisual(5);
                    tcpHolSim_moveElement(packet5, tcpHolSim_state.receiverEndX, tcpHolSim_state.receiverEndY, () => {
                        if (tcpHolSim_state.packets[packet5.id]) tcpHolSim_state.packets[packet5.id].state = 'arrived_at_receiver_location';
                        // Don't unlock here, let next step handle arrival
                    });

                    // Clean up duplicate ACKs that might have arrived
                    const duplicateAckIds = Object.keys(tcpHolSim_state.acks).filter(id => tcpHolSim_state.acks[id].ack === 2 && tcpHolSim_state.acks[id].isDuplicate && tcpHolSim_state.acks[id].state === 'arrived_at_sender');
                    duplicateAckIds.forEach(id => {
                        const dupAckElement = tcpHolSim_state.acks[id].element;
                        if (dupAckElement && dupAckElement.parentNode) dupAckElement.parentNode.removeChild(dupAckElement);
                        delete tcpHolSim_state.acks[id];
                    });


                    tcpHolSim_state.animationInProgress = false; // Unlock after starting SEQ 5 move
                },
                // Step 7: SEQ 5 Arrives, Buffered, Repeat ACK 2
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    let packet5Id = Object.keys(tcpHolSim_state.packets).find(id => tcpHolSim_state.packets[id].seq === 5 && tcpHolSim_state.packets[id].state === 'arrived_at_receiver_location');
                    const packet5 = packet5Id ? tcpHolSim_state.packets[packet5Id].element : null;
                    const packet5Info = packet5Id ? tcpHolSim_state.packets[packet5Id] : null;

                    tcpHolSim_updateExplanation("步骤 7: SEQ 5 到达。因期望 SEQ 2 而失序，被放入缓冲区。再次重复发送 ACK 2。");
                    tcpHolSim_updateReceiverStatus("收到乱序 SEQ 5, 缓冲, 重复 ACK 2");

                    if (packet5 && packet5Info) {
                        packet5Info.state = 'arrived_ooo';
                        tcpHolSim_applyArrivalCue(packet5);
                        setTimeout(() => {
                            if (!packet5) return;
                            tcpHolSim_addToReceiverBuffer(packet5Info.id);
                            const ack2_dup3 = tcpHolSim_createAckElement(2, true);
                            tcpHolSim_moveElement(ack2_dup3, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => {
                                if (tcpHolSim_state.acks[ack2_dup3.id]) tcpHolSim_state.acks[ack2_dup3.id].state = 'arrived_at_sender';
                                tcpHolSim_state.animationInProgress = false; // Unlock after dup ACK arrives
                            });
                        }, 600);
                    } else {
                        console.error("tcpHolSim: Packet 5 not found or not in correct state at Step 7.");
                        const ack2_dup3 = tcpHolSim_createAckElement(2, true);
                        tcpHolSim_moveElement(ack2_dup3, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => { tcpHolSim_state.animationInProgress = false; });
                    }
                },
                // Step 8: RTO Timeout for SEQ 2
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    // Clean up any remaining duplicate ACKs at sender
                    const duplicateAckIds = Object.keys(tcpHolSim_state.acks).filter(id => tcpHolSim_state.acks[id].ack === 2 && tcpHolSim_state.acks[id].isDuplicate && tcpHolSim_state.acks[id].state === 'arrived_at_sender');
                    duplicateAckIds.forEach(id => {
                        const dupAckElement = tcpHolSim_state.acks[id].element;
                        if (dupAckElement && dupAckElement.parentNode) dupAckElement.parentNode.removeChild(dupAckElement);
                        delete tcpHolSim_state.acks[id];
                    });

                    tcpHolSim_updateExplanation("步骤 8: 发送方未收到对 SEQ 2 的确认，其 RTO 计时器到期！");
                    tcpHolSim_updateSenderStatus("SEQ 2 超时!");
                    tcpHolSim_expireRtoTimerVisual(2);
                    tcpHolSim_state.animationInProgress = false;
                },
                // Step 9: Retransmit SEQ 2
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    tcpHolSim_updateExplanation("步骤 9: 发送方超时重传 SEQ 2。");
                    tcpHolSim_updateSenderStatus("重传 SEQ 2");
                    const retransmitPacket2 = tcpHolSim_createPacketElement(2, true);
                    tcpHolSim_resetRtoTimerVisual(2);
                    tcpHolSim_startRtoTimerVisual(2);
                    tcpHolSim_moveElement(retransmitPacket2, tcpHolSim_state.receiverEndX, tcpHolSim_state.receiverEndY, () => {
                        if (tcpHolSim_state.packets[retransmitPacket2.id]) tcpHolSim_state.packets[retransmitPacket2.id].state = 'arrived_at_receiver_location';
                        // Don't unlock here
                    });
                    tcpHolSim_state.animationInProgress = false; // Unlock after move starts
                },
                // Step 10: Retransmitted SEQ 2 Arrives
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    let packet2_retransmit_id = Object.keys(tcpHolSim_state.packets).find(id =>
                        tcpHolSim_state.packets[id].seq === 2 &&
                        tcpHolSim_state.packets[id].isRetransmit &&
                        tcpHolSim_state.packets[id].state === 'arrived_at_receiver_location'
                    );
                    const packet2_retransmit = packet2_retransmit_id ? tcpHolSim_state.packets[packet2_retransmit_id].element : null;
                    const packet2_retransmit_info = packet2_retransmit_id ? tcpHolSim_state.packets[packet2_retransmit_id] : null;

                    tcpHolSim_updateExplanation("步骤 10: 重传的 SEQ 2 到达接收方。正是期望的数据包！");
                    tcpHolSim_updateReceiverStatus("收到重传的 SEQ 2");

                    if (packet2_retransmit && packet2_retransmit_info) {
                        packet2_retransmit_info.state = 'arrived_in_order';
                        tcpHolSim_applyArrivalCue(packet2_retransmit);
                        setTimeout(() => { tcpHolSim_state.animationInProgress = false; }, 600); // Wait for cue
                    } else {
                        console.error("tcpHolSim: Retransmitted Packet 2 element not found or not in correct state at Step 10.");
                        tcpHolSim_state.animationInProgress = false;
                    }
                },
                // Step 11: Deliver SEQ 2, 3, 4, 5, Send ACK 6
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    tcpHolSim_updateExplanation("步骤 11: 接收方交付 SEQ 2 (重传)。然后按序交付缓冲中的 SEQ 3, 4, 5。队头阻塞解除！发送 ACK 6。");
                    tcpHolSim_updateReceiverStatus("交付 SEQ 2, 3, 4, 5, 发送 ACK 6");

                    let packet2_retransmit_id = Object.keys(tcpHolSim_state.packets).find(id =>
                        tcpHolSim_state.packets[id].seq === 2 &&
                        tcpHolSim_state.packets[id].isRetransmit &&
                        tcpHolSim_state.packets[id].state === 'arrived_in_order'
                    );
                    const packet2_retransmit = packet2_retransmit_id ? tcpHolSim_state.packets[packet2_retransmit_id].element : null;
                    const packet2_retransmit_info = packet2_retransmit_id ? tcpHolSim_state.packets[packet2_retransmit_id] : null;

                    if (!packet2_retransmit || !packet2_retransmit_info) {
                        console.error("tcpHolSim: Retransmitted Packet 2 not found or not arrived for delivery at Step 11.");
                        tcpHolSim_state.animationInProgress = false;
                        return;
                    }

                    packet2_retransmit.classList.remove('tcpHolSim_packet-arrived-cue');
                    tcpHolSim_moveElement(packet2_retransmit, tcpHolSim_state.receiverEndX, tcpHolSim_state.appLayerY, () => {
                        packet2_retransmit.style.position = 'static';
                        packet2_retransmit.classList.add('tcpHolSim_packet-delivered');
                        tcpHolSim_elements.appLayer.appendChild(packet2_retransmit);
                        tcpHolSim_state.deliveredToAppSeq.add(2);
                        packet2_retransmit_info.state = 'delivered';
                        tcpHolSim_sortAppLayer();
                        tcpHolSim_updateExpectedSeq(3);

                        tcpHolSim_deliverSequenceToApp(() => {
                            if (tcpHolSim_state.expectedSeqNum === 6) {
                                const ack6 = tcpHolSim_createAckElement(6);
                                tcpHolSim_moveElement(ack6, tcpHolSim_state.senderStartX, tcpHolSim_state.ackReturnY, () => {
                                    if (tcpHolSim_state.acks[ack6.id]) tcpHolSim_state.acks[ack6.id].state = 'arrived_at_sender';
                                    tcpHolSim_state.animationInProgress = false; // Final unlock
                                });
                            } else {
                                console.error(`tcpHolSim: Expected sequence number is ${tcpHolSim_state.expectedSeqNum}, not 6, after delivering buffered packets.`);
                                tcpHolSim_state.animationInProgress = false;
                            }
                        });
                    });
                },
                // Step 12: Sender Processes ACK 6, Slides Window
                () => {
                    tcpHolSim_state.animationInProgress = true;
                    tcpHolSim_updateExplanation("步骤 12: 发送方收到 ACK 6，确认 SEQ 2-5。发送窗口向前滑动至 [6-9]。");
                    tcpHolSim_updateSenderStatus("收到 ACK 6, 窗口 -> [6-9]");

                    const ack6Id = Object.keys(tcpHolSim_state.acks).find(id => tcpHolSim_state.acks[id].ack === 6 && tcpHolSim_state.acks[id].state === 'arrived_at_sender');
                    if (ack6Id) {
                        const ack6Element = tcpHolSim_state.acks[ack6Id].element;
                        if (ack6Element && ack6Element.parentNode) ack6Element.parentNode.removeChild(ack6Element);
                        delete tcpHolSim_state.acks[ack6Id];
                    } else {
                        console.warn("tcpHolSim: ACK 6 not found or not arrived at sender.");
                    }

                    [2, 3, 4, 5].forEach(seq => {
                        tcpHolSim_resetRtoTimerVisual(seq);
                        const packetInfo = Object.values(tcpHolSim_state.packets).find(p => p.seq === seq); // Find any packet with this seq
                        if (packetInfo) packetInfo.state = 'acked';
                    });

                    tcpHolSim_state.senderWindowStart = 6;
                    tcpHolSim_updateSenderWindowVisual();

                    tcpHolSim_updateExplanation("模拟结束。队头阻塞已演示并解除。发送方窗口已更新。可以 '重置' 再来一次。");
                    if (tcpHolSim_elements.nextStepBtn) {
                        tcpHolSim_elements.nextStepBtn.disabled = true;
                        tcpHolSim_elements.nextStepBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                    tcpHolSim_state.animationInProgress = false;
                }
            ];

            function tcpHolSim_initializeSimulation() {
                console.log("tcpHolSim: Resetting simulation...");
                tcpHolSim_state.animationInProgress = true;
                tcpHolSim_elements.channel.querySelectorAll('.tcpHolSim_packet, .tcpHolSim_ack').forEach(el => {
                    el.style.transition = 'none';
                    if (el.parentNode) el.parentNode.removeChild(el);
                });

                tcpHolSim_state.currentStep = 0;
                tcpHolSim_state.packets = {};
                tcpHolSim_state.acks = {};
                tcpHolSim_state.receiverBufferContent = {};
                tcpHolSim_state.deliveredToAppSeq.clear();
                tcpHolSim_state.expectedSeqNum = 1;
                tcpHolSim_state.senderWindowStart = 1;
                tcpHolSim_state.rtoTimersActive = {};

                tcpHolSim_elements.channel.innerHTML = '';
                tcpHolSim_elements.appLayer.innerHTML = '';
                tcpHolSim_elements.bufferSlots.forEach(slot => {
                    slot.innerHTML = '空';
                    slot.classList.add('bg-gray-200');
                });

                for (let i = 1; i <= TCPHOLSIM_MAX_SEQ; i++) {
                    tcpHolSim_resetRtoTimerVisual(i);
                    if (tcpHolSim_elements.senderSeqElements[i]) {
                        tcpHolSim_elements.senderSeqElements[i].classList.remove('opacity-50', 'bg-green-200', 'border-green-400', 'bg-gray-300');
                        tcpHolSim_elements.senderSeqElements[i].classList.add('border-gray-400', 'bg-white');
                    }
                }
                tcpHolSim_updateSenderWindowVisual();
                tcpHolSim_steps[0](); // Run initial setup step

                if (tcpHolSim_elements.nextStepBtn) {
                    tcpHolSim_elements.nextStepBtn.disabled = false;
                    tcpHolSim_elements.nextStepBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
                console.log("tcpHolSim: Simulation Reset Complete. Current Step:", tcpHolSim_state.currentStep);
                // animationInProgress is set to false by step 0
            }

            if (tcpHolSim_elements.nextStepBtn && tcpHolSim_elements.resetBtn) {
                tcpHolSim_elements.nextStepBtn.addEventListener('click', () => {
                    if (tcpHolSim_state.animationInProgress) return;
                    if (tcpHolSim_state.currentStep < tcpHolSim_steps.length) {
                        try {
                            console.log(`tcpHolSim: Executing Step: ${tcpHolSim_state.currentStep}`);
                            tcpHolSim_state.animationInProgress = true;
                            tcpHolSim_steps[tcpHolSim_state.currentStep]();
                            tcpHolSim_state.currentStep++;
                        } catch (error) {
                            console.error(`tcpHolSim: Error executing step ${tcpHolSim_state.currentStep - 1}:`, error);
                            tcpHolSim_updateExplanation(`执行步骤 ${tcpHolSim_state.currentStep - 1} 时出错: ${error.message}. 请尝试重置。`);
                            tcpHolSim_elements.nextStepBtn.disabled = true;
                            tcpHolSim_elements.nextStepBtn.classList.add('opacity-50', 'cursor-not-allowed');
                            tcpHolSim_state.animationInProgress = false;
                        }
                    }
                });
                tcpHolSim_elements.resetBtn.addEventListener('click', tcpHolSim_initializeSimulation);
                tcpHolSim_calculatePositions(); // Initial calculation
                setTimeout(tcpHolSim_initializeSimulation, 100); // Initialize after positions are likely set
                window.addEventListener('resize', tcpHolSim_calculatePositions);
            } else {
                console.error("tcpHolSim: Initialization failed - Next or Reset button not found.");
            }


            // --- TCP Flow Control Simulation (tcpFlowSim_) ---
            const tcpFlowSim_elements = {
                senderBufferEl: document.getElementById('tcpFlowSim_sender-buffer'),
                receiverBufferEl: document.getElementById('tcpFlowSim_receiver-buffer'),
                receiverBufferContainerEl: document.getElementById('tcpFlowSim_receiver-buffer-container'),
                transmissionChannelEl: document.getElementById('tcpFlowSim_transmission-channel'),
                sendPacketBtn: document.getElementById('tcpFlowSim_send-packet-btn'),
                processPacketBtn: document.getElementById('tcpFlowSim_process-packet-btn'),
                resetBtn: document.getElementById('tcpFlowSim_reset-btn'),
                messageContentEl: document.getElementById('tcpFlowSim_message-content'),
                sndNxtEl: document.getElementById('tcpFlowSim_snd-nxt'),
                sndUnaEl: document.getElementById('tcpFlowSim_snd-una'),
                sendWindowSizeEl: document.getElementById('tcpFlowSim_send-window-size'),
                usableWindowSizeEl: document.getElementById('tcpFlowSim_usable-window-size'),
                advertisedRwndEl: document.getElementById('tcpFlowSim_advertised-rwnd'),
                sendWindowSizeTooltipEl: document.getElementById('tcpFlowSim_send-window-size-tooltip'),
                rcvNxtEl: document.getElementById('tcpFlowSim_rcv-nxt'),
                bufferCapacityEl: document.getElementById('tcpFlowSim_buffer-capacity'),
                currentRwndEl: document.getElementById('tcpFlowSim_current-rwnd'),
                recvWindowSizeTooltipEl: document.getElementById('tcpFlowSim_recv-window-size-tooltip')
            };

            const TCP_FLOW_SIM_PACKET_SIZE = 36;
            const TCP_FLOW_SIM_BUFFER_CAPACITY = 10;
            const TCP_FLOW_SIM_MAX_SEQ_NUM = 30;
            const TCP_FLOW_SIM_ANIMATION_DURATION = 1500;
            const TCP_FLOW_SIM_PROBE_INTERVAL = 4000;

            let tcpFlowSim_state = {
                sndNxt: 1,
                sndUna: 1,
                rcvNxt: 1,
                advertisedRwnd: TCP_FLOW_SIM_BUFFER_CAPACITY,
                currentRwnd: TCP_FLOW_SIM_BUFFER_CAPACITY,
                sendWindowSize: TCP_FLOW_SIM_BUFFER_CAPACITY,
                usableWindowSize: TCP_FLOW_SIM_BUFFER_CAPACITY,
                nextPacketToSend: 1,
                receiverBuffer: [], // Stores {seq: number}
                senderPackets: {}, // Stores {seq: element}
                inFlightPackets: {}, // Stores {seq: {type: 'data'|'ack'|'probe', el: element}}
                zeroWindowProbeTimer: null,
                isZeroWindow: false,
                isSimulating: false
            };

            // (Include all helper functions from 传输层.html for the tcpFlowSim_, prefixed with tcpFlowSim_)
            // e.g., tcpFlowSim_initSimulation, tcpFlowSim_createPacketElement, tcpFlowSim_updateSenderUI, etc.
            // ... (implementation of helper functions adapted with tcpFlowSim_ prefix) ...
            function tcpFlowSim_initSimulation() {
                tcpFlowSim_state.isSimulating = false;
                tcpFlowSim_state.sndNxt = 1;
                tcpFlowSim_state.sndUna = 1;
                tcpFlowSim_state.rcvNxt = 1;
                tcpFlowSim_state.advertisedRwnd = TCP_FLOW_SIM_BUFFER_CAPACITY;
                tcpFlowSim_state.currentRwnd = TCP_FLOW_SIM_BUFFER_CAPACITY;
                tcpFlowSim_state.sendWindowSize = TCP_FLOW_SIM_BUFFER_CAPACITY;
                tcpFlowSim_state.usableWindowSize = TCP_FLOW_SIM_BUFFER_CAPACITY;
                tcpFlowSim_state.nextPacketToSend = 1;
                tcpFlowSim_state.receiverBuffer = [];
                tcpFlowSim_state.senderPackets = {};
                tcpFlowSim_state.inFlightPackets = {};
                tcpFlowSim_state.isZeroWindow = false;
                if (tcpFlowSim_state.zeroWindowProbeTimer) {
                    clearTimeout(tcpFlowSim_state.zeroWindowProbeTimer);
                    tcpFlowSim_state.zeroWindowProbeTimer = null;
                }

                // Clear UI elements
                tcpFlowSim_elements.senderBufferEl?.querySelectorAll('.tcpFlowSim_packet, .tcpFlowSim_window-segment').forEach(el => el.remove());
                tcpFlowSim_elements.receiverBufferEl?.querySelectorAll('.tcpFlowSim_packet, .tcpFlowSim_window-segment').forEach(el => el.remove());
                if (tcpFlowSim_elements.transmissionChannelEl) tcpFlowSim_elements.transmissionChannelEl.innerHTML = '';

                // Add initial packets to sender buffer
                if (tcpFlowSim_elements.senderBufferEl) {
                    for (let i = 1; i <= TCP_FLOW_SIM_MAX_SEQ_NUM; i++) {
                        tcpFlowSim_createSenderPacket(i);
                    }
                }

                tcpFlowSim_updateSenderUI();
                tcpFlowSim_updateReceiverUI();

                if (tcpFlowSim_elements.sendPacketBtn) tcpFlowSim_elements.sendPacketBtn.disabled = false;
                if (tcpFlowSim_elements.processPacketBtn) tcpFlowSim_elements.processPacketBtn.disabled = true;
                tcpFlowSim_showMessage("模拟已重置。点击 '发送数据包' 开始体验 TCP 流量控制过程。");
            }

            function tcpFlowSim_createPacketElement(seq, type = 'sender') {
                const packet = document.createElement('div');
                packet.classList.add('tcpFlowSim_packet');
                packet.dataset.seq = seq;
                packet.textContent = seq;
                packet.style.position = 'relative';
                packet.style.left = '0px';
                packet.style.top = '0px';
                if (type === 'receiver') packet.classList.add('tcpFlowSim_received');
                return packet;
            }

            function tcpFlowSim_createSenderPacket(seq) {
                const packet = tcpFlowSim_createPacketElement(seq, 'sender');
                tcpFlowSim_state.senderPackets[seq] = packet;
                if (tcpFlowSim_elements.senderBufferEl) tcpFlowSim_elements.senderBufferEl.appendChild(packet);
                packet.style.position = 'absolute';
                tcpFlowSim_positionPacketInBuffer(packet, seq, tcpFlowSim_elements.senderBufferEl);
            }

            function tcpFlowSim_positionPacketInBuffer(packetEl, seq, bufferEl) {
                if (!bufferEl || !packetEl) return;
                const index = seq - 1;
                const containerWidth = bufferEl.clientWidth;
                const itemsPerRow = containerWidth > 0 ? Math.floor(containerWidth / TCP_FLOW_SIM_PACKET_SIZE) : 1;
                if (itemsPerRow <= 0) return;
                const row = Math.floor(index / itemsPerRow);
                const col = index % itemsPerRow;
                packetEl.style.left = `${col * TCP_FLOW_SIM_PACKET_SIZE}px`;
                packetEl.style.top = `${row * TCP_FLOW_SIM_PACKET_SIZE}px`;
            }

            function tcpFlowSim_updateSenderUI() {
                if (!tcpFlowSim_elements.sndNxtEl) return; // Basic check

                tcpFlowSim_elements.sndNxtEl.textContent = tcpFlowSim_state.sndNxt;
                tcpFlowSim_elements.sndUnaEl.textContent = tcpFlowSim_state.sndUna;
                tcpFlowSim_state.sendWindowSize = tcpFlowSim_state.advertisedRwnd; // Simplified
                tcpFlowSim_elements.sendWindowSizeEl.textContent = tcpFlowSim_state.sendWindowSize;
                tcpFlowSim_elements.advertisedRwndEl.textContent = tcpFlowSim_state.advertisedRwnd;
                tcpFlowSim_state.usableWindowSize = Math.max(0, tcpFlowSim_state.sendWindowSize - (tcpFlowSim_state.sndNxt - tcpFlowSim_state.sndUna));
                tcpFlowSim_elements.usableWindowSizeEl.textContent = tcpFlowSim_state.usableWindowSize;

                if (tcpFlowSim_elements.sendPacketBtn) {
                    tcpFlowSim_elements.sendPacketBtn.disabled = tcpFlowSim_state.isSimulating || (tcpFlowSim_state.usableWindowSize <= 0 || tcpFlowSim_state.nextPacketToSend > TCP_FLOW_SIM_MAX_SEQ_NUM || tcpFlowSim_state.isZeroWindow);
                }

                if (!tcpFlowSim_state.isSimulating) {
                    if (tcpFlowSim_state.isZeroWindow && tcpFlowSim_state.usableWindowSize <= 0) {
                        tcpFlowSim_showMessage(`状态: 接收方窗口为 0 (<code>rwnd</code>=0)，发送暂停。等待零窗口探测...`, 'warning');
                        if (!tcpFlowSim_state.zeroWindowProbeTimer) { tcpFlowSim_state.zeroWindowProbeTimer = setTimeout(tcpFlowSim_sendZeroWindowProbe, TCP_FLOW_SIM_PROBE_INTERVAL); }
                    } else if (tcpFlowSim_state.usableWindowSize <= 0 && tcpFlowSim_state.sndNxt <= TCP_FLOW_SIM_MAX_SEQ_NUM) {
                        tcpFlowSim_showMessage(`状态: 发送窗口已满 (可用窗口=0)，无法发送新数据，等待 ACK...`, 'info');
                    } else if (tcpFlowSim_state.nextPacketToSend > TCP_FLOW_SIM_MAX_SEQ_NUM) {
                        tcpFlowSim_showMessage(`状态: 所有数据包 (${TCP_FLOW_SIM_MAX_SEQ_NUM}) 已发送或发送完毕。`, 'info');
                    } else if (tcpFlowSim_state.usableWindowSize > 0 && !tcpFlowSim_state.isZeroWindow) {
                        tcpFlowSim_showMessage(`状态: 可用窗口=${tcpFlowSim_state.usableWindowSize}，可以发送数据包。`, 'info');
                    }
                }

                tcpFlowSim_updateSenderPacketStates();
                tcpFlowSim_updateSendWindowIndicator();
            }

            function tcpFlowSim_updateReceiverUI() {
                if (!tcpFlowSim_elements.rcvNxtEl) return; // Basic check

                tcpFlowSim_elements.rcvNxtEl.textContent = tcpFlowSim_state.rcvNxt;
                tcpFlowSim_elements.bufferCapacityEl.textContent = TCP_FLOW_SIM_BUFFER_CAPACITY;
                tcpFlowSim_state.currentRwnd = Math.max(0, TCP_FLOW_SIM_BUFFER_CAPACITY - tcpFlowSim_state.receiverBuffer.length);
                tcpFlowSim_elements.currentRwndEl.textContent = tcpFlowSim_state.currentRwnd;

                if (tcpFlowSim_elements.processPacketBtn) {
                    tcpFlowSim_elements.processPacketBtn.disabled = tcpFlowSim_state.isSimulating || tcpFlowSim_state.receiverBuffer.length === 0;
                }

                tcpFlowSim_updateReceiverPacketStates();
                tcpFlowSim_updateRecvWindowIndicator();
            }

            function tcpFlowSim_updateSendWindowIndicator() {
                if (!tcpFlowSim_elements.senderBufferEl || !tcpFlowSim_elements.sendWindowSizeTooltipEl) return;
                tcpFlowSim_elements.senderBufferEl.querySelectorAll('.tcpFlowSim_send-window-segment').forEach(el => el.remove());
                tcpFlowSim_elements.sendWindowSizeTooltipEl.textContent = tcpFlowSim_state.sendWindowSize;
                if (tcpFlowSim_state.sendWindowSize <= 0) return;

                const windowStartSeq = tcpFlowSim_state.sndUna;
                const windowEndSeq = Math.min(tcpFlowSim_state.sndUna + tcpFlowSim_state.sendWindowSize - 1, TCP_FLOW_SIM_MAX_SEQ_NUM);
                if (windowStartSeq > windowEndSeq) return;

                const containerWidth = tcpFlowSim_elements.senderBufferEl.clientWidth;
                const itemsPerRow = containerWidth > 0 ? Math.floor(containerWidth / TCP_FLOW_SIM_PACKET_SIZE) : 1;
                if (itemsPerRow <= 0) return;

                const startSeqIndex = windowStartSeq - 1;
                const endSeqIndex = windowEndSeq - 1;
                const startRow = Math.floor(startSeqIndex / itemsPerRow);
                const startCol = startSeqIndex % itemsPerRow;
                const endRow = Math.floor(endSeqIndex / itemsPerRow);
                const endCol = endSeqIndex % itemsPerRow;

                for (let row = startRow; row <= endRow; row++) {
                    const segStartCol = (row === startRow) ? startCol : 0;
                    const segEndCol = (row === endRow) ? endCol : itemsPerRow - 1;
                    if (segStartCol > segEndCol) continue;

                    const segLeft = segStartCol * TCP_FLOW_SIM_PACKET_SIZE;
                    const segTop = row * TCP_FLOW_SIM_PACKET_SIZE;
                    const segWidth = (segEndCol - segStartCol + 1) * TCP_FLOW_SIM_PACKET_SIZE;
                    const segHeight = TCP_FLOW_SIM_PACKET_SIZE;

                    const segment = document.createElement('div');
                    segment.classList.add('tcpFlowSim_window-segment', 'tcpFlowSim_send-window-segment');
                    segment.style.left = `${segLeft}px`;
                    segment.style.top = `${segTop}px`;
                    segment.style.width = `${Math.min(segWidth, containerWidth - segLeft)}px`;
                    segment.style.height = `${segHeight}px`;
                    tcpFlowSim_elements.senderBufferEl.appendChild(segment);
                }
            }

            function tcpFlowSim_updateRecvWindowIndicator() {
                if (!tcpFlowSim_elements.receiverBufferEl || !tcpFlowSim_elements.recvWindowSizeTooltipEl) return;
                tcpFlowSim_elements.receiverBufferEl.querySelectorAll('.tcpFlowSim_recv-window-segment').forEach(el => el.remove());
                const windowSize = tcpFlowSim_state.currentRwnd;
                tcpFlowSim_elements.recvWindowSizeTooltipEl.textContent = windowSize;
                if (windowSize <= 0) return;

                const windowStartSeq = tcpFlowSim_state.rcvNxt;
                // Receiver window indicates *available slots*, ending at buffer capacity limit
                const windowEndSeq = Math.min(tcpFlowSim_state.rcvNxt + windowSize - 1, TCP_FLOW_SIM_BUFFER_CAPACITY);
                if (windowStartSeq > windowEndSeq) return;

                const containerWidth = tcpFlowSim_elements.receiverBufferEl.clientWidth;
                const itemsPerRow = containerWidth > 0 ? Math.floor(containerWidth / TCP_FLOW_SIM_PACKET_SIZE) : 1;
                if (itemsPerRow <= 0) return;

                const startSeqIndex = windowStartSeq - 1; // Index of the first available slot
                const endSeqIndex = windowEndSeq - 1;   // Index of the last available slot
                const startRow = Math.floor(startSeqIndex / itemsPerRow);
                const startCol = startSeqIndex % itemsPerRow;
                const endRow = Math.floor(endSeqIndex / itemsPerRow);
                const endCol = endSeqIndex % itemsPerRow;

                for (let row = startRow; row <= endRow; row++) {
                    const segStartCol = (row === startRow) ? startCol : 0;
                    const segEndCol = (row === endRow) ? endCol : itemsPerRow - 1;
                    if (segStartCol > segEndCol) continue;

                    const segLeft = segStartCol * TCP_FLOW_SIM_PACKET_SIZE;
                    const segTop = row * TCP_FLOW_SIM_PACKET_SIZE;
                    const segWidth = (segEndCol - segStartCol + 1) * TCP_FLOW_SIM_PACKET_SIZE;
                    const segHeight = TCP_FLOW_SIM_PACKET_SIZE;

                    const segment = document.createElement('div');
                    segment.classList.add('tcpFlowSim_window-segment', 'tcpFlowSim_recv-window-segment');
                    segment.style.left = `${segLeft}px`;
                    segment.style.top = `${segTop}px`;
                    segment.style.width = `${Math.min(segWidth, containerWidth - segLeft)}px`;
                    segment.style.height = `${segHeight}px`;
                    tcpFlowSim_elements.receiverBufferEl.appendChild(segment);
                }
            }

            function tcpFlowSim_updateSenderPacketStates() {
                Object.keys(tcpFlowSim_state.senderPackets).forEach(seq => {
                    const packetEl = tcpFlowSim_state.senderPackets[seq];
                    if (!packetEl) return;
                    const seqNum = parseInt(seq);
                    packetEl.classList.remove('tcpFlowSim_sent', 'tcpFlowSim_acked');
                    packetEl.style.opacity = '1';
                    if (seqNum < tcpFlowSim_state.sndUna) {
                        packetEl.classList.add('tcpFlowSim_acked');
                        packetEl.style.opacity = '0.5';
                    } else if (seqNum < tcpFlowSim_state.sndNxt) {
                        packetEl.classList.add('tcpFlowSim_sent');
                    } else {
                        packetEl.style.opacity = seqNum < tcpFlowSim_state.sndUna + tcpFlowSim_state.sendWindowSize ? '1' : '0.3';
                    }
                    tcpFlowSim_positionPacketInBuffer(packetEl, seqNum, tcpFlowSim_elements.senderBufferEl);
                });
            }

            function tcpFlowSim_updateReceiverPacketStates() {
                if (!tcpFlowSim_elements.receiverBufferEl) return;
                tcpFlowSim_elements.receiverBufferEl.querySelectorAll('.tcpFlowSim_packet').forEach(p => p.remove());
                tcpFlowSim_state.receiverBuffer.forEach(packetInfo => {
                    const packetEl = tcpFlowSim_createPacketElement(packetInfo.seq, 'receiver');
                    packetEl.classList.add('tcpFlowSim_buffered');
                    tcpFlowSim_elements.receiverBufferEl.appendChild(packetEl);
                    tcpFlowSim_positionPacketInBuffer(packetEl, packetInfo.seq, tcpFlowSim_elements.receiverBufferEl);
                });
            }

            function tcpFlowSim_animatePacket(seq, type) {
                tcpFlowSim_state.isSimulating = true;
                tcpFlowSim_updateSenderUI();
                tcpFlowSim_updateReceiverUI();

                const startEl = (type === 'data' || type === 'probe') ? tcpFlowSim_state.senderPackets[seq] : tcpFlowSim_elements.receiverBufferContainerEl;
                const endEl = (type === 'data' || type === 'probe') ? tcpFlowSim_elements.receiverBufferContainerEl : tcpFlowSim_elements.senderBufferEl;

                if (!startEl || !endEl) {
                    console.error(`tcpFlowSim: Cannot animate ${type} for SEQ=${seq}, start or end element not found.`);
                    tcpFlowSim_state.isSimulating = false; tcpFlowSim_updateSenderUI(); tcpFlowSim_updateReceiverUI(); return;
                }

                const startRect = startEl.getBoundingClientRect();
                const endRect = endEl.getBoundingClientRect();
                const channelRect = tcpFlowSim_elements.transmissionChannelEl?.getBoundingClientRect();

                if (!channelRect) {
                    console.error("tcpFlowSim: Transmission channel not found.");
                    tcpFlowSim_state.isSimulating = false; tcpFlowSim_updateSenderUI(); tcpFlowSim_updateReceiverUI(); return;
                }

                const arrow = document.createElement('div');
                arrow.classList.add('tcpFlowSim_arrow', `tcpFlowSim_${type}`);
                arrow.style.position = 'absolute';
                arrow.style.zIndex = '5';
                let textContent = '';
                if (type === 'data') textContent = `SEQ=${seq}`;
                else if (type === 'ack') textContent = `ACK=${tcpFlowSim_state.rcvNxt}, rwnd=${tcpFlowSim_state.currentRwnd}`;
                else if (type === 'probe') textContent = `Probe (SEQ=${seq})`;
                arrow.textContent = textContent;

                let startX, startY, endX, endY;
                if (type === 'data' || type === 'probe') {
                    const senderPacketRect = tcpFlowSim_state.senderPackets[seq] ? tcpFlowSim_state.senderPackets[seq].getBoundingClientRect() : startRect;
                    startX = senderPacketRect.left + senderPacketRect.width / 2 - channelRect.left;
                    startY = senderPacketRect.bottom - channelRect.top + 5;
                    endX = endRect.left + endRect.width / 2 - channelRect.left;
                    endY = endRect.top - channelRect.top - (arrow.offsetHeight || 20) - 5; // Estimate height if needed
                } else { // ACK
                    startX = startRect.left + startRect.width / 2 - channelRect.left;
                    startY = startRect.top - channelRect.top - (arrow.offsetHeight || 20) - 5;
                    endX = endRect.left + endRect.width / 2 - channelRect.left;
                    endY = endRect.bottom - channelRect.top + 5;
                }
                startY = Math.max(0, Math.min(startY, channelRect.height - (arrow.offsetHeight || 20)));
                endY = Math.max(0, Math.min(endY, channelRect.height - (arrow.offsetHeight || 20)));
                arrow.style.left = `${startX}px`;
                arrow.style.top = `${startY}px`;
                arrow.style.opacity = '1';
                if (tcpFlowSim_elements.transmissionChannelEl) tcpFlowSim_elements.transmissionChannelEl.appendChild(arrow);
                tcpFlowSim_state.inFlightPackets[seq] = { type: type, el: arrow };
                void arrow.offsetWidth;
                arrow.style.transform = `translate(${endX - startX}px, ${endY - startY}px)`;

                setTimeout(() => {
                    if (tcpFlowSim_elements.transmissionChannelEl?.contains(arrow)) {
                        tcpFlowSim_elements.transmissionChannelEl.removeChild(arrow);
                    }
                    delete tcpFlowSim_state.inFlightPackets[seq];
                    if (type === 'data') tcpFlowSim_handlePacketArrival(seq);
                    else if (type === 'ack') tcpFlowSim_handleAckArrival(seq);
                    else if (type === 'probe') tcpFlowSim_handleProbeArrival(seq);
                    tcpFlowSim_state.isSimulating = false;
                    tcpFlowSim_updateSenderUI();
                    tcpFlowSim_updateReceiverUI();
                }, TCP_FLOW_SIM_ANIMATION_DURATION);
            }

            function tcpFlowSim_handleSendPacket() {
                if (tcpFlowSim_state.isSimulating || tcpFlowSim_state.usableWindowSize <= 0 || tcpFlowSim_state.nextPacketToSend > TCP_FLOW_SIM_MAX_SEQ_NUM || tcpFlowSim_state.isZeroWindow) { tcpFlowSim_updateSenderUI(); return; }
                const seqToSend = tcpFlowSim_state.nextPacketToSend;
                tcpFlowSim_showMessage(`准备发送: SEQ=${seqToSend}。因为可用窗口 (${tcpFlowSim_state.usableWindowSize}) > 0 且未收到零窗口通知。`, 'info');
                if (tcpFlowSim_state.senderPackets[seqToSend]) {
                    tcpFlowSim_state.senderPackets[seqToSend].classList.add('tcpFlowSim_sent');
                    tcpFlowSim_state.senderPackets[seqToSend].classList.remove('tcpFlowSim_acked');
                    tcpFlowSim_state.senderPackets[seqToSend].style.opacity = '1';
                } else { console.error(`tcpFlowSim: Sender packet element for SEQ=${seqToSend} not found!`); return; }
                tcpFlowSim_state.sndNxt++;
                tcpFlowSim_state.nextPacketToSend++;
                tcpFlowSim_showMessage(`发送中: SEQ=${seqToSend}。SND.NXT 更新为 ${tcpFlowSim_state.sndNxt}。可用窗口减少。`, 'info');
                tcpFlowSim_updateSenderUI();
                tcpFlowSim_animatePacket(seqToSend, 'data');
            }

            function tcpFlowSim_handlePacketArrival(seq) {
                tcpFlowSim_showMessage(`到达: 数据包 SEQ=${seq} 已到达接收方。开始检查...`, 'info');
                if (seq === tcpFlowSim_state.rcvNxt) {
                    if (tcpFlowSim_state.currentRwnd > 0) {
                        tcpFlowSim_showMessage(`处理: SEQ=${seq} 是期望序号 (${tcpFlowSim_state.rcvNxt}) 且接收窗口 (${tcpFlowSim_state.currentRwnd}) > 0。放入缓冲区。`, 'success');
                        tcpFlowSim_state.receiverBuffer.push({ seq: seq });
                        tcpFlowSim_state.receiverBuffer.sort((a, b) => a.seq - b.seq);
                        tcpFlowSim_state.rcvNxt++;
                        tcpFlowSim_updateReceiverUI();
                        tcpFlowSim_showMessage(`准备ACK: 接收方缓存了 SEQ=${seq}，期望下一个是 ${tcpFlowSim_state.rcvNxt}。将发送 ACK=${tcpFlowSim_state.rcvNxt} 并通告当前 <code>rwnd</code>=${tcpFlowSim_state.currentRwnd}。`, 'info');
                        tcpFlowSim_sendAck();
                    } else {
                        tcpFlowSim_showMessage(`丢弃: SEQ=${seq} 是期望序号，但接收缓冲区已满 (<code>rwnd</code>=0)。数据包被丢弃。`, 'warning');
                        tcpFlowSim_showMessage(`准备ACK: 即使丢弃了 SEQ=${seq}，仍需发送 ACK=${tcpFlowSim_state.rcvNxt} (当前期望值)，并明确通告 <code>rwnd</code>=0。`, 'info');
                        tcpFlowSim_sendAck();
                    }
                } else if (seq < tcpFlowSim_state.rcvNxt) {
                    tcpFlowSim_showMessage(`重复: 收到 SEQ=${seq}，但已期望 ${tcpFlowSim_state.rcvNxt}。此为重复包，丢弃。`, 'warning');
                    tcpFlowSim_showMessage(`准备ACK: 为帮助发送方可能存在的丢包检测，重新发送 ACK=${tcpFlowSim_state.rcvNxt} (当前期望值) 及当前 <code>rwnd</code>=${tcpFlowSim_state.currentRwnd}。`, 'info');
                    tcpFlowSim_sendAck();
                } else { // seq > rcvNxt (乱序)
                    // Simplified: In a real scenario, might buffer out-of-order packets if space allows.
                    // For this simulation, we just discard and send duplicate ACK.
                    tcpFlowSim_showMessage(`乱序: 收到 SEQ=${seq}，但期望 ${tcpFlowSim_state.rcvNxt}。此为乱序包 (本模拟简化处理，丢弃)。`, 'warning');
                    tcpFlowSim_showMessage(`准备ACK: 发送重复 ACK=${tcpFlowSim_state.rcvNxt} (当前期望值) 及当前 <code>rwnd</code>=${tcpFlowSim_state.currentRwnd}。`, 'info');
                    tcpFlowSim_sendAck();
                }
            }

            function tcpFlowSim_sendAck() {
                const ackNum = tcpFlowSim_state.rcvNxt;
                const advertisedWindow = tcpFlowSim_state.currentRwnd;
                tcpFlowSim_showMessage(`发送ACK: ACK=${ackNum}, <code>rwnd</code>=${advertisedWindow}。通知发送方已收到 ${ackNum - 1} 及之前的包，并告知剩余空间。`, 'info');
                tcpFlowSim_animatePacket(ackNum, 'ack');
            }

            function tcpFlowSim_handleAckArrival(ackNum) {
                // In this simplified simulation, we use the *current* receiver rwnd
                // A real ACK carries the rwnd value *at the time the ACK was sent*.
                const receivedRwnd = tcpFlowSim_state.currentRwnd;

                tcpFlowSim_showMessage(`收到ACK: ACK=${ackNum}, (假设报文中携带 <code>rwnd</code>=${receivedRwnd})。处理确认信息和窗口更新...`, 'info');

                if (ackNum > tcpFlowSim_state.sndUna) {
                    const newlyAckedCount = ackNum - tcpFlowSim_state.sndUna;
                    tcpFlowSim_showMessage(`有效ACK: ACK=${ackNum} > SND.UNA=${tcpFlowSim_state.sndUna}。确认了 ${newlyAckedCount} 个新数据包。发送窗口向前滑动。`, 'success');
                    tcpFlowSim_state.sndUna = ackNum;
                    if (tcpFlowSim_state.isZeroWindow && receivedRwnd > 0) {
                        tcpFlowSim_state.isZeroWindow = false;
                        if (tcpFlowSim_state.zeroWindowProbeTimer) { clearTimeout(tcpFlowSim_state.zeroWindowProbeTimer); tcpFlowSim_state.zeroWindowProbeTimer = null; }
                        tcpFlowSim_showMessage(`窗口重开: 收到的 ACK 中 <code>rwnd</code>=${receivedRwnd} > 0。解除零窗口状态，停止探测，可以恢复发送。`, 'success');
                    }
                } else {
                    tcpFlowSim_showMessage(`重复ACK: ACK=${ackNum} <= SND.UNA=${tcpFlowSim_state.sndUna}。未确认新数据。`, 'info');
                }

                if (tcpFlowSim_state.advertisedRwnd !== receivedRwnd) {
                    tcpFlowSim_showMessage(`窗口更新: 收到的 ACK 中 <code>rwnd</code>=${receivedRwnd} 与发送方记录 (${tcpFlowSim_state.advertisedRwnd}) 不同。更新发送方记录的接收窗口。`, 'info');
                    tcpFlowSim_state.advertisedRwnd = receivedRwnd;
                    if (tcpFlowSim_state.advertisedRwnd === 0) {
                        tcpFlowSim_state.isZeroWindow = true;
                    } else {
                        if (tcpFlowSim_state.isZeroWindow) { // Window opened
                            tcpFlowSim_state.isZeroWindow = false;
                            if (tcpFlowSim_state.zeroWindowProbeTimer) { clearTimeout(tcpFlowSim_state.zeroWindowProbeTimer); tcpFlowSim_state.zeroWindowProbeTimer = null; }
                            tcpFlowSim_showMessage(`窗口重开: (可能在重复 ACK 中) <code>rwnd</code>=${receivedRwnd} > 0，解除零窗口。`, 'success');
                        }
                    }
                } else if (tcpFlowSim_state.isZeroWindow && receivedRwnd === 0) {
                    tcpFlowSim_showMessage(`维持零窗口: 收到的 ACK 确认 <code>rwnd</code> 仍为 0。继续等待探测或窗口更新。`, 'warning');
                    if (!tcpFlowSim_state.zeroWindowProbeTimer) {
                        tcpFlowSim_state.zeroWindowProbeTimer = setTimeout(tcpFlowSim_sendZeroWindowProbe, TCP_FLOW_SIM_PROBE_INTERVAL);
                    }
                }

                tcpFlowSim_updateSenderUI();
            }

            function tcpFlowSim_handleProcessPacket() {
                if (tcpFlowSim_state.isSimulating || tcpFlowSim_state.receiverBuffer.length === 0) return;
                tcpFlowSim_showMessage(`应用处理: 模拟上层应用从接收缓冲区读取数据...`, 'info');
                const processedPacket = tcpFlowSim_state.receiverBuffer.shift();
                tcpFlowSim_showMessage(`处理完成: 应用读取了 SEQ=${processedPacket.seq}。接收缓冲区空间增加。`, 'success');
                tcpFlowSim_updateReceiverUI();
                tcpFlowSim_showMessage(`准备ACK: 因缓冲区空间增加，发送新的 ACK=${tcpFlowSim_state.rcvNxt}，通告增大了的 <code>rwnd</code>=${tcpFlowSim_state.currentRwnd}，以便发送方可以发送更多数据。`, 'info');
                tcpFlowSim_sendAck();
            }

            function tcpFlowSim_sendZeroWindowProbe() {
                if (!tcpFlowSim_state.isZeroWindow || tcpFlowSim_state.isSimulating) {
                    if (tcpFlowSim_state.isZeroWindow && !tcpFlowSim_state.zeroWindowProbeTimer) { tcpFlowSim_state.zeroWindowProbeTimer = setTimeout(tcpFlowSim_sendZeroWindowProbe, TCP_FLOW_SIM_PROBE_INTERVAL); }
                    return;
                }
                const probeSeq = tcpFlowSim_state.sndUna; // Probe based on the oldest unacknowledged seq
                if (probeSeq < tcpFlowSim_state.sndNxt && tcpFlowSim_state.senderPackets[probeSeq]) {
                    tcpFlowSim_showMessage(`零窗口探测: 发送方等待超时 (${TCP_FLOW_SIM_PROBE_INTERVAL / 1000}s)，发送探测包 (基于 SEQ=${probeSeq}) 以查询接收方窗口是否更新。`, 'warning');
                    tcpFlowSim_animatePacket(probeSeq, 'probe');
                } else {
                    tcpFlowSim_showMessage(`探测失败: 无法基于 SEQ=${probeSeq} 发送探测 (可能已确认或无此包)。稍后重试...`, 'error');
                    if (tcpFlowSim_state.zeroWindowProbeTimer) clearTimeout(tcpFlowSim_state.zeroWindowProbeTimer);
                    tcpFlowSim_state.zeroWindowProbeTimer = setTimeout(tcpFlowSim_sendZeroWindowProbe, TCP_FLOW_SIM_PROBE_INTERVAL);
                }
            }

            function tcpFlowSim_handleProbeArrival(seq) {
                tcpFlowSim_showMessage(`探测到达: 接收方收到来自发送方的零窗口探测包 (基于 SEQ=${seq})。`, 'info');
                tcpFlowSim_showMessage(`探测响应: 接收方回复 ACK=${tcpFlowSim_state.rcvNxt} 并携带当前 <code>rwnd</code>=${tcpFlowSim_state.currentRwnd}。`, 'info');
                tcpFlowSim_sendAck();
            }

            let tcpFlowSim_messageTimeout;
            function tcpFlowSim_showMessage(msg, type = 'info') {
                clearTimeout(tcpFlowSim_messageTimeout);
                const newMessageDiv = document.createElement('div');
                newMessageDiv.innerHTML = msg; // Use innerHTML for <code> tag rendering

                const messageArea = document.getElementById('tcpFlowSim_message-area');
                const messageContentEl = tcpFlowSim_elements.messageContentEl;
                if (!messageArea || !messageContentEl) return;

                messageArea.classList.remove('bg-blue-50', 'border-blue-300', 'bg-green-50', 'border-green-300', 'bg-yellow-50', 'border-yellow-300', 'bg-red-50', 'border-red-300');
                messageContentEl.classList.remove('text-blue-700', 'text-green-700', 'text-amber-700', 'text-red-700');

                switch (type) {
                    case 'success': messageArea.classList.add('bg-green-50', 'border-green-300'); messageContentEl.classList.add('text-green-700'); break;
                    case 'warning': messageArea.classList.add('bg-yellow-50', 'border-yellow-300'); messageContentEl.classList.add('text-amber-700'); break;
                    case 'error': messageArea.classList.add('bg-red-50', 'border-red-300'); messageContentEl.classList.add('text-red-700'); break;
                    default: messageArea.classList.add('bg-blue-50', 'border-blue-300'); messageContentEl.classList.add('text-blue-700'); break;
                }

                messageContentEl.style.top = '-150%'; // Move old message out up
                setTimeout(() => {
                    messageContentEl.innerHTML = ''; // Clear old content
                    messageContentEl.appendChild(newMessageDiv); // Add new content
                    messageContentEl.style.top = '150%'; // Position new message below
                    void messageContentEl.offsetWidth; // Force reflow
                    messageContentEl.style.transition = 'top 0.5s ease-in-out'; // Apply transition
                    messageContentEl.style.top = '50%'; // Animate new message in
                    messageContentEl.style.transform = 'translateY(-50%)';
                }, 250); // Wait for old message to move out
            }

            if (tcpFlowSim_elements.sendPacketBtn) tcpFlowSim_elements.sendPacketBtn.addEventListener('click', tcpFlowSim_handleSendPacket);
            if (tcpFlowSim_elements.processPacketBtn) tcpFlowSim_elements.processPacketBtn.addEventListener('click', tcpFlowSim_handleProcessPacket);
            if (tcpFlowSim_elements.resetBtn) tcpFlowSim_elements.resetBtn.addEventListener('click', tcpFlowSim_initSimulation);
            window.addEventListener('resize', () => {
                if (!tcpFlowSim_state.isSimulating) {
                    tcpFlowSim_updateSenderPacketStates();
                    tcpFlowSim_updateReceiverPacketStates();
                    tcpFlowSim_updateSendWindowIndicator();
                    tcpFlowSim_updateRecvWindowIndicator();
                }
            });
            tcpFlowSim_initSimulation(); // Initial setup


            // --- TCP Congestion Control Simulation (tcpCongestionSim_) ---
            const tcpCongestionSim_elements = {
                statusIndicator: document.getElementById('tcpCongestionSim_status-indicator'),
                cwndValue: document.getElementById('tcpCongestionSim_cwnd-value'),
                ssthreshValue: document.getElementById('tcpCongestionSim_ssthresh-value'),
                rttCounter: document.getElementById('tcpCongestionSim_rtt-counter'),
                dupAckDisplay: document.getElementById('tcpCongestionSim_dup-ack-display'),
                packetArea: document.getElementById('tcpCongestionSim_packet-area'),
                explanationArea: document.getElementById('tcpCongestionSim_explanation-area'),
                startButton: document.getElementById('tcpCongestionSim_start-button'),
                lossButton: document.getElementById('tcpCongestionSim_loss-button'),
                dupAckButton: document.getElementById('tcpCongestionSim_dup-ack-button'),
                resetButton: document.getElementById('tcpCongestionSim_reset-button'),
                chartCanvas: document.getElementById('tcpCongestionSim_congestionChart')
            };

            let tcpCongestionSim_state = {
                cwnd: 1,
                ssthresh: 64,
                phase: 'slow-start', // slow-start, congestion-avoidance, fast-recovery, timeout
                rtt: 0,
                dupAcks: 0,
                chart: null,
                chartData: {
                    labels: [],
                    datasets: [
                        { label: 'cwnd (MSS)', data: [], borderColor: 'rgb(59, 130, 246)', backgroundColor: 'rgba(59, 130, 246, 0.1)', tension: 0.1, fill: true, pointRadius: 3, pointHoverRadius: 6 },
                        { label: 'ssthresh (MSS)', data: [], borderColor: 'rgb(16, 185, 129)', backgroundColor: 'rgba(16, 185, 129, 0.1)', borderDash: [5, 5], tension: 0.1, fill: false, pointRadius: 3, pointHoverRadius: 6 }
                    ]
                },
                simulationRunning: false
            };
            const TCP_CONGESTION_SIM_MAX_CHART_POINTS = 50;

            // (Include all helper functions from 传输层.html for the tcpVis_, prefixed with tcpCongestionSim_)
            // e.g., tcpCongestionSim_updateUI, tcpCongestionSim_visualizePackets, tcpCongestionSim_initializeChart, etc.
            // ... (implementation of helper functions adapted with tcpCongestionSim_ prefix) ...
            function tcpCongestionSim_updateUI(explanation = "", highlightState = false) {
                if (!tcpCongestionSim_elements.statusIndicator) return; // Basic check

                const prevStateHtml = tcpCongestionSim_elements.statusIndicator.innerHTML;
                const stateInfo = tcpCongestionSim_getStateInfo(tcpCongestionSim_state.phase);

                tcpCongestionSim_elements.statusIndicator.innerHTML = stateInfo.html;
                tcpCongestionSim_elements.statusIndicator.className = `tcpCongestionSim_status-indicator ${stateInfo.className}`;

                if (highlightState && prevStateHtml !== stateInfo.html) {
                    tcpCongestionSim_elements.statusIndicator.classList.add('tcpCongestionSim_highlight-state-change');
                    setTimeout(() => tcpCongestionSim_elements.statusIndicator.classList.remove('tcpCongestionSim_highlight-state-change'), 1000);
                }

                tcpCongestionSim_elements.cwndValue.textContent = `${tcpCongestionSim_state.cwnd} MSS`;
                tcpCongestionSim_elements.ssthreshValue.textContent = `${tcpCongestionSim_state.ssthresh} MSS`;
                tcpCongestionSim_elements.rttCounter.textContent = tcpCongestionSim_state.rtt;
                tcpCongestionSim_elements.dupAckDisplay.textContent = tcpCongestionSim_state.dupAcks;

                if (explanation && tcpCongestionSim_elements.explanationArea) {
                    tcpCongestionSim_elements.explanationArea.innerHTML = explanation.replace(/\n/g, '<br>');
                }

                tcpCongestionSim_updateChartData();

                if (tcpCongestionSim_elements.startButton) tcpCongestionSim_elements.startButton.disabled = false;
                if (tcpCongestionSim_elements.lossButton) tcpCongestionSim_elements.lossButton.disabled = !tcpCongestionSim_state.simulationRunning;
                if (tcpCongestionSim_elements.dupAckButton) tcpCongestionSim_elements.dupAckButton.disabled = !tcpCongestionSim_state.simulationRunning || tcpCongestionSim_state.phase === 'fast-recovery' || tcpCongestionSim_state.dupAcks >= 3;
                if (tcpCongestionSim_elements.resetButton) tcpCongestionSim_elements.resetButton.disabled = false;
                tcpCongestionSim_visualizePackets();
            }

            function tcpCongestionSim_visualizePackets(action = 'ack') {
                if (!tcpCongestionSim_elements.packetArea) return;
                tcpCongestionSim_elements.packetArea.innerHTML = '';
                const numPackets = Math.min(Math.max(1, Math.floor(tcpCongestionSim_state.cwnd)), 30);
                for (let i = 0; i < numPackets; i++) {
                    const packet = document.createElement('div');
                    packet.classList.add('tcpCongestionSim_packet');
                    tcpCongestionSim_elements.packetArea.appendChild(packet);
                    setTimeout(() => {
                        packet.classList.add('tcpCongestionSim_sent');
                        setTimeout(() => {
                            packet.classList.remove('tcpCongestionSim_sent');
                            if (action === 'ack') { packet.classList.add('tcpCongestionSim_ack'); }
                            else if (action === 'lost') { packet.classList.add('tcpCongestionSim_lost'); }
                            else if (action === 'dup-ack') { packet.classList.add('tcpCongestionSim_duplicate-ack'); }
                        }, 400 + i * 10);
                    }, i * 15);
                }
            }

            function tcpCongestionSim_getStateInfo(s) {
                let text = '', iconClass = '', cssClass = '';
                switch (s) {
                    case 'slow-start': text = '慢启动'; iconClass = 'fas fa-rocket text-blue-500'; cssClass = 'tcpCongestionSim_status-slow-start'; break;
                    case 'congestion-avoidance': text = '拥塞避免'; iconClass = 'fas fa-walking text-green-600'; cssClass = 'tcpCongestionSim_status-congestion-avoidance'; break;
                    case 'timeout': text = '超时恢复'; iconClass = 'fas fa-exclamation-triangle text-red-600'; cssClass = 'tcpCongestionSim_status-timeout'; break;
                    case 'fast-recovery': text = '快速恢复'; iconClass = 'fas fa-shipping-fast text-yellow-600'; cssClass = 'tcpCongestionSim_status-fast-recovery'; break;
                    default: text = '未知'; iconClass = 'fas fa-question-circle text-gray-500'; cssClass = '';
                }
                return { html: `<i class="${iconClass}"></i><span>${text}</span>`, className: cssClass };
            }

            function tcpCongestionSim_updateChartData() {
                if (!tcpCongestionSim_state.chart) return;
                const { labels, datasets } = tcpCongestionSim_state.chartData;
                labels.push(tcpCongestionSim_state.rtt);
                datasets[0].data.push(tcpCongestionSim_state.cwnd);
                datasets[1].data.push(tcpCongestionSim_state.ssthresh);
                if (labels.length > TCP_CONGESTION_SIM_MAX_CHART_POINTS) {
                    labels.shift();
                    datasets[0].data.shift();
                    datasets[1].data.shift();
                }
                tcpCongestionSim_state.chart.update();
            }

            function tcpCongestionSim_initializeChart() {
                if (!tcpCongestionSim_elements.chartCanvas) return;
                const ctx = tcpCongestionSim_elements.chartCanvas.getContext('2d');
                if (tcpCongestionSim_state.chart) { tcpCongestionSim_state.chart.destroy(); }
                tcpCongestionSim_state.chart = new Chart(ctx, {
                    type: 'line',
                    data: tcpCongestionSim_state.chartData,
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        scales: { x: { title: { display: true, text: '轮次 (RTT)' } }, y: { title: { display: true, text: '窗口大小 (MSS)' }, beginAtZero: true } },
                        plugins: { legend: { position: 'top' }, title: { display: true, text: 'cwnd 与 ssthresh 变化曲线' } }
                    }
                });
            }

            function tcpCongestionSim_resetSimulation() {
                tcpCongestionSim_state.cwnd = 1;
                tcpCongestionSim_state.ssthresh = 64;
                tcpCongestionSim_state.phase = 'slow-start';
                tcpCongestionSim_state.rtt = 0;
                tcpCongestionSim_state.dupAcks = 0;
                tcpCongestionSim_state.simulationRunning = false;
                tcpCongestionSim_state.chartData.labels = [];
                tcpCongestionSim_state.chartData.datasets[0].data = [];
                tcpCongestionSim_state.chartData.datasets[1].data = [];
                const initialExplanation = `... (Initial Explanation Text) ...`; // Add initial text here
                tcpCongestionSim_updateUI(initialExplanation, true);
                tcpCongestionSim_initializeChart();
                if (tcpCongestionSim_elements.packetArea) tcpCongestionSim_elements.packetArea.innerHTML = '';
                if (tcpCongestionSim_elements.startButton) tcpCongestionSim_elements.startButton.textContent = '开始/下一步 (ACK)';
                if (tcpCongestionSim_elements.lossButton) tcpCongestionSim_elements.lossButton.disabled = true;
                if (tcpCongestionSim_elements.dupAckButton) tcpCongestionSim_elements.dupAckButton.disabled = true;
            }

            function tcpCongestionSim_handleAck() {
                let explanation = "", highlight = false;
                if (!tcpCongestionSim_state.simulationRunning) {
                    tcpCongestionSim_state.simulationRunning = true;
                    if (tcpCongestionSim_elements.startButton) tcpCongestionSim_elements.startButton.textContent = '下一步 (ACK)';
                    explanation = `... (Simulation Start Explanation) ...`;
                    tcpCongestionSim_updateUI(explanation, true);
                    return;
                }
                tcpCongestionSim_state.rtt++;
                tcpCongestionSim_state.dupAcks = 0;
                const oldCwnd = tcpCongestionSim_state.cwnd;
                if (tcpCongestionSim_state.phase === 'slow-start') {
                    tcpCongestionSim_state.cwnd *= 2;
                    explanation = `RTT ${tcpCongestionSim_state.rtt}: 收到 ACK。仍处 <strong>慢启动</strong>。cwnd: ${oldCwnd} -> ${tcpCongestionSim_state.cwnd} (指数增)。`;
                    if (tcpCongestionSim_state.cwnd >= tcpCongestionSim_state.ssthresh) {
                        tcpCongestionSim_state.phase = 'congestion-avoidance';
                        explanation += ` cwnd ≥ ssthresh (${tcpCongestionSim_state.ssthresh})，切换到 <strong>拥塞避免</strong>。`;
                        highlight = true;
                    }
                } else if (tcpCongestionSim_state.phase === 'congestion-avoidance') {
                    tcpCongestionSim_state.cwnd++;
                    explanation = `RTT ${tcpCongestionSim_state.rtt}: 收到 ACK。处 <strong>拥塞避免</strong>。cwnd: ${oldCwnd} -> ${tcpCongestionSim_state.cwnd} (线性增)。`;
                } else if (tcpCongestionSim_state.phase === 'fast-recovery') {
                    tcpCongestionSim_state.cwnd = tcpCongestionSim_state.ssthresh;
                    tcpCongestionSim_state.phase = 'congestion-avoidance';
                    explanation = `RTT ${tcpCongestionSim_state.rtt}: 收到新 ACK，退出快速恢复。cwnd=${tcpCongestionSim_state.ssthresh}，进入<strong>拥塞避免</strong>。`;
                    highlight = true;
                }
                tcpCongestionSim_updateUI(explanation, highlight);
                tcpCongestionSim_visualizePackets('ack');
            }

            function tcpCongestionSim_handleTimeout() {
                if (!tcpCongestionSim_state.simulationRunning) return;
                tcpCongestionSim_state.rtt++;
                const oldCwnd = tcpCongestionSim_state.cwnd;
                tcpCongestionSim_state.phase = 'timeout';
                tcpCongestionSim_state.ssthresh = Math.max(Math.floor(oldCwnd / 2), 1);
                tcpCongestionSim_state.cwnd = 1;
                tcpCongestionSim_state.dupAcks = 0;
                const explanation = `... (Timeout Explanation) ...`;
                tcpCongestionSim_updateUI(explanation, true);
                setTimeout(() => {
                    if (tcpCongestionSim_state.phase === 'timeout') {
                        tcpCongestionSim_state.phase = 'slow-start';
                        tcpCongestionSim_updateUI(explanation + `<br>已退回 <strong>慢启动</strong>。`, false);
                    }
                }, 1500);
                tcpCongestionSim_visualizePackets('lost');
            }

            function tcpCongestionSim_handleDuplicateAck() {
                if (!tcpCongestionSim_state.simulationRunning || tcpCongestionSim_state.phase === 'fast-recovery') return;
                tcpCongestionSim_state.dupAcks++;
                let explanation = `RTT ${tcpCongestionSim_state.rtt}: 收到第 ${tcpCongestionSim_state.dupAcks} 个重复 ACK。`;
                let highlight = false;
                if (tcpCongestionSim_state.dupAcks === 3) {
                    const oldCwnd = tcpCongestionSim_state.cwnd;
                    // Simplified Reno: Set ssthresh, set cwnd to ssthresh, enter Congestion Avoidance
                    tcpCongestionSim_state.ssthresh = Math.max(Math.floor(oldCwnd / 2), 1);
                    tcpCongestionSim_state.cwnd = tcpCongestionSim_state.ssthresh; // Go directly to Congestion Avoidance
                    tcpCongestionSim_state.phase = 'congestion-avoidance'; // Directly enter CA
                    highlight = true;
                    explanation = `... (Fast Retransmit/Recovery Explanation - Reno Simplified) ...`;
                    tcpCongestionSim_state.dupAcks = 0; // Reset after handling
                } else {
                    explanation += ` cwnd=${tcpCongestionSim_state.cwnd}。等待第 3 个重复 ACK。`;
                }
                tcpCongestionSim_updateUI(explanation, highlight);
                tcpCongestionSim_visualizePackets('dup-ack');
            }

            if (tcpCongestionSim_elements.startButton) tcpCongestionSim_elements.startButton.addEventListener('click', tcpCongestionSim_handleAck);
            if (tcpCongestionSim_elements.lossButton) tcpCongestionSim_elements.lossButton.addEventListener('click', tcpCongestionSim_handleTimeout);
            if (tcpCongestionSim_elements.dupAckButton) tcpCongestionSim_elements.dupAckButton.addEventListener('click', tcpCongestionSim_handleDuplicateAck);
            if (tcpCongestionSim_elements.resetButton) tcpCongestionSim_elements.resetButton.addEventListener('click', tcpCongestionSim_resetSimulation);
            tcpCongestionSim_resetSimulation(); // Initial setup


            // --- Final Initialization ---
            // (Call any other init functions if needed)

        }); // End of DOMContentLoaded listener

    </script>
</body>

</html>